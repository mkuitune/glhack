!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASCII_CHARMAX	glh_font.cpp	17;"	d	file:
ASCII_CHARMIN	glh_font.cpp	16;"	d	file:
ASCII_CHARNUM	glh_font.cpp	15;"	d	file:
ActiveProgram	glhack.cpp	/^ActiveProgram::ActiveProgram():component_count_(g_component_max_count){}$/;"	f	class:glh::ActiveProgram
ActiveProgram	glhack.cpp	/^class ActiveProgram {$/;"	c	namespace:glh	file:
AdjacencyListGraph	glh_dynamic_graph.h	/^class AdjacencyListGraph{$/;"	c	namespace:glh
AlignedArray	shims_and_types.h	/^    AlignedArray():data_(nullptr), capacity_(0), size_(0)$/;"	f	class:glh::AlignedArray
AlignedArray	shims_and_types.h	/^    AlignedArray(AlignedArray&& old){$/;"	f	class:glh::AlignedArray
AlignedArray	shims_and_types.h	/^    AlignedArray(const AlignedArray& old)$/;"	f	class:glh::AlignedArray
AlignedArray	shims_and_types.h	/^    AlignedArray(size_t count, const T& value = T()):data_(nullptr), capacity_(0), size_(0)$/;"	f	class:glh::AlignedArray
AlignedArray	shims_and_types.h	/^class AlignedArray$/;"	c	namespace:glh
Animation	glh_timebased_signals.h	/^class Animation{$/;"	c	namespace:glh
AnnotatedResult	annotated_result.h	/^    AnnotatedResult(AnnotatedResult&& moved)$/;"	f	class:glh::AnnotatedResult
AnnotatedResult	annotated_result.h	/^    AnnotatedResult(const AnnotatedResult& r)$/;"	f	class:glh::AnnotatedResult
AnnotatedResult	annotated_result.h	/^    explicit AnnotatedResult(const T& value):valid_(true)$/;"	f	class:glh::AnnotatedResult
AnnotatedResult	annotated_result.h	/^    explicit AnnotatedResult(const std::string& message):valid_(false),message_(message)$/;"	f	class:glh::AnnotatedResult
AnnotatedResult	annotated_result.h	/^class AnnotatedResult$/;"	c	namespace:glh
AnyButton	glbase.h	/^    typedef std::pair<ButtonSource, int> AnyButton;$/;"	t	class:glh::Input
App	glbase.cpp	/^App::App(AppConfig config):config_(config)$/;"	f	class:glh::App
App	glbase.h	/^class App$/;"	c	namespace:glh
AppConfig	glbase.h	/^struct AppConfig$/;"	s	namespace:glh
AppInit	glbase.h	/^typedef std::function<bool(App*)> AppInit;$/;"	t	namespace:glh
AppRender	glbase.h	/^typedef std::function<void(App*)> AppRender;$/;"	t	namespace:glh
AppResize	glbase.h	/^typedef std::function<void(App*, int, int)> AppResize;$/;"	t	namespace:glh
AppServices	glh_app_services.h	/^class AppServices{$/;"	c	namespace:glh
AppUpdate	glbase.h	/^typedef std::function<bool(App*)> AppUpdate;$/;"	t	namespace:glh
Arbitrary	glh_timebased_signals.h	/^        enum t{Arbitrary};};$/;"	e	enum:glh::Animation::ChannelName::t
AreEqual	persistent_containers.h	/^class AreEqual { public:$/;"	c	namespace:glh
ArenaQueue	shims_and_types.h	/^    ArenaQueue():size_(0), max_size_(128){$/;"	f	class:glh::ArenaQueue
ArenaQueue	shims_and_types.h	/^class ArenaQueue{$/;"	c	namespace:glh
ArgWrap	masp_classwrap.h	/^    ArgWrap(VecIterator i, VecIterator end):i_(i), end_(end){}$/;"	f	class:masp::ArgWrap
ArgWrap	masp_classwrap.h	/^class ArgWrap{$/;"	c	namespace:masp
Array	shims_and_types.h	/^    Array(size_t hint):data_(hint){}$/;"	f	class:glh::Array
Array	shims_and_types.h	/^class Array$/;"	c	namespace:glh
ArrayN	math_tools.h	/^    ArrayN(){set_zero();}$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(T x){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(T x, T y){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(T x, T y, T z){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(T x, T y, T z, T w){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(const ArrayN& in){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(const T* data){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^    ArrayN(const complement_t& in){$/;"	f	struct:glh::ArrayN
ArrayN	math_tools.h	/^struct ArrayN{$/;"	s	namespace:glh
AssetManagerPtr	asset_manager.h	/^typedef std::shared_ptr<AssetManager> AssetManagerPtr;$/;"	t	namespace:glh
Autotimer	glbase.h	/^    Autotimer(){t = progtime();}$/;"	f	class:glh::Autotimer
Autotimer	glbase.h	/^class Autotimer{$/;"	c	namespace:glh
BIGENDIAN	conversion.c	60;"	d	file:
BIGENDIAN	conversion.c	62;"	d	file:
BOOLEAN	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
Backspace	glbase.h	/^        Backspace = GLFW_KEY_BACKSPACE,  $/;"	e	enum:glh::Input::Key
BakedFontHandle	glh_font.h	/^typedef std::pair<std::string, double> BakedFontHandle;$/;"	t	namespace:glh
BiMap	shims_and_types.h	/^class BiMap$/;"	c	namespace:glh
BlendSettings	glhack.h	/^        BlendSettings():blend_active_(false){}$/;"	f	struct:glh::RenderPassSettings::BlendSettings
BlendSettings	glhack.h	/^        BlendSettings(GLenum  source_factor, GLenum  dest_factor):$/;"	f	struct:glh::RenderPassSettings::BlendSettings
BlendSettings	glhack.h	/^    struct BlendSettings{$/;"	s	class:glh::RenderPassSettings
Box	math_tools.h	/^    Box(){$/;"	f	struct:glh::Box
Box	math_tools.h	/^    Box(const vec_t& min, const vec_t& max):min_(min), max_(max){}$/;"	f	struct:glh::Box
Box	math_tools.h	/^struct Box$/;"	s	namespace:glh
Box2f	math_tools.h	/^typedef Box<float, 2> Box2f;$/;"	t	namespace:glh
Box2i	math_tools.h	/^typedef Box<int, 2>   Box2i;$/;"	t	namespace:glh
Box3f	math_tools.h	/^typedef Box<float, 3> Box3f;$/;"	t	namespace:glh
Buffer	glhack.h	/^    enum Buffer{ BufferColor = GL_COLOR_BUFFER_BIT, BufferDepth = GL_DEPTH_BUFFER_BIT, BufferStencil = GL_STENCIL_BUFFER_BIT };$/;"	g	class:glh::RenderPassSettings
BufferColor	glhack.h	/^    enum Buffer{ BufferColor = GL_COLOR_BUFFER_BIT, BufferDepth = GL_DEPTH_BUFFER_BIT, BufferStencil = GL_STENCIL_BUFFER_BIT };$/;"	e	enum:glh::RenderPassSettings::Buffer
BufferDepth	glhack.h	/^    enum Buffer{ BufferColor = GL_COLOR_BUFFER_BIT, BufferDepth = GL_DEPTH_BUFFER_BIT, BufferStencil = GL_STENCIL_BUFFER_BIT };$/;"	e	enum:glh::RenderPassSettings::Buffer
BufferHandle	glbuffers.h	/^    BufferHandle(const BufferSignature& sig): mapped_sig_(sig), handle_(0), on_gpu_(false){ glGenBuffers(1, &handle_);}$/;"	f	class:glh::BufferHandle
BufferHandle	glbuffers.h	/^class BufferHandle {$/;"	c	namespace:glh
BufferHandle	glh_typedefs.h	/^        BufferHandle  = 1,$/;"	e	enum:glh::EntityType::t
BufferHandlePtr	glbuffers.h	/^typedef std::shared_ptr<BufferHandle>  BufferHandlePtr;$/;"	t	namespace:glh
BufferSet	glbuffers.h	/^class BufferSet {$/;"	c	namespace:glh
BufferSet	glh_typedefs.h	/^        BufferSet     = 6,$/;"	e	enum:glh::EntityType::t
BufferSignature	glbuffers.h	/^    BufferSignature():components_(0), size_bytes_(0){}$/;"	f	struct:glh::BufferSignature
BufferSignature	glbuffers.h	/^    BufferSignature(const TypeId::t type, const int32_t components):type_(type), components_(components), size_bytes_(0){}$/;"	f	struct:glh::BufferSignature
BufferSignature	glbuffers.h	/^struct BufferSignature {$/;"	s	namespace:glh
BufferStencil	glhack.h	/^    enum Buffer{ BufferColor = GL_COLOR_BUFFER_BIT, BufferDepth = GL_DEPTH_BUFFER_BIT, BufferStencil = GL_STENCIL_BUFFER_BIT };$/;"	e	enum:glh::RenderPassSettings::Buffer
ButtonActivated	glh_uicontext.h	/^            ButtonActivated, ButtonDeactivated, MouseMoved$/;"	e	enum:glh::UiContext::Event::t
ButtonDeactivated	glh_uicontext.h	/^            ButtonActivated, ButtonDeactivated, MouseMoved$/;"	e	enum:glh::UiContext::Event::t
ButtonSource	glbase.h	/^    enum ButtonSource{Mouse, Keyboard, Custom};$/;"	g	class:glh::Input
ButtonState	glbase.h	/^    enum ButtonState{Held,Released};$/;"	g	class:glh::Input
CALLMEMBER	masp_classwrap.h	279;"	d
CASE	stb_image.c	2485;"	d	file:
CASE	stb_image.c	2498;"	d	file:
CASE	stb_image.c	2501;"	d	file:
CASE	stb_image.c	2514;"	d	file:
CASE	stb_image.c	853;"	d	file:
CASE	stb_image.c	871;"	d	file:
CHUNK_BUFFER_SIZE	persistent_containers.h	55;"	d
COLOR_BLACK	glh_names.h	65;"	d
COLOR_BLUE	glh_names.h	60;"	d
COLOR_CYAN	glh_names.h	63;"	d
COLOR_DELTA	glh_uicontext.cpp	49;"	d	file:
COLOR_GREEN	glh_names.h	59;"	d
COLOR_PURPLE	glh_names.h	62;"	d
COLOR_RED	glh_names.h	58;"	d
COLOR_WHITE	glh_names.h	64;"	d
COLOR_YELLOW	glh_names.h	61;"	d
COMBO	stb_image.c	852;"	d	file:
COPY_PARAM_V	masp.cpp	104;"	d	file:
COPY_PARAM_V	masp.cpp	116;"	d	file:
CURRENT_NODE	persistent_containers.h	1147;"	d
Camera	glh_scenemanagement.h	/^    Camera(SceneTree::Node* node):node_(node){$/;"	f	class:glh::Camera
Camera	glh_scenemanagement.h	/^class Camera : public SceneObject{$/;"	c	namespace:glh
Camera	glh_typedefs.h	/^        Camera         = 2001,$/;"	e	enum:glh::EntityType::t
CapsLock	glbase.h	/^        CapsLock = GLFW_KEY_CAPS_LOCK,  $/;"	e	enum:glh::Input::Key
ChannelName	glh_timebased_signals.h	/^    struct ChannelName{$/;"	s	class:glh::Animation
ChannelType	glh_typedefs.h	/^class ChannelType$/;"	c	namespace:glh
Channels	gltexture.h	/^    enum Channels{R, RGB, RGBA};$/;"	g	class:glh::TextureType
ChildContainer	glh_scenemanagement.h	/^        typedef std::vector<Node*> ChildContainer;$/;"	t	class:glh::SceneTree::Node
Chunk	persistent_containers.h	/^    Chunk(){$/;"	f	struct:glh::Chunk
Chunk	persistent_containers.h	/^struct Chunk$/;"	s	namespace:glh
ChunkBox	persistent_containers.h	/^    ChunkBox()$/;"	f	class:glh::ChunkBox
ChunkBox	persistent_containers.h	/^class ChunkBox$/;"	c	namespace:glh
ChunkMap	glh_mesh.h	/^typedef std::map<ChannelType::s, VertexChunk> ChunkMap;$/;"	t	namespace:glh
Collectable	managed_structures.h	/^class Collectable$/;"	c
Collector	managed_structures.h	/^class Collector$/;"	c
CollisionNode	persistent_containers.h	/^        enum NodeType{EmptyNode, ValueNode, CollisionNode};$/;"	e	enum:glh::PMapPool::Node::NodeType
Color	glh_typedefs.h	/^            Color    = 2,$/;"	e	enum:glh::ChannelType::s
Color	math_tools.h	/^    Color():r(0.f),g(0.f), b(0.f),a(0.f){}$/;"	f	struct:glh::Color
Color	math_tools.h	/^    Color(const vec4& v):r(v[0]), g(v[1]), b(v[2]), a(v[3]){}$/;"	f	struct:glh::Color
Color	math_tools.h	/^    Color(float rr, float gg, float bb, float aa):r(rr), g(gg), b(bb), a(aa){}$/;"	f	struct:glh::Color
Color	math_tools.h	/^struct Color{$/;"	s	namespace:glh
ColorInterpolation	glh_uicontext.h	/^        enum t{ ColorInterpolation };$/;"	e	enum:glh::UiContext::Technique::t
ColorMask	glhack.h	/^        ColorMask():$/;"	f	struct:glh::RenderPassSettings::ColorMask
ColorMask	glhack.h	/^        ColorMask(GLboolean r, GLboolean g, GLboolean b, GLboolean a):$/;"	f	struct:glh::RenderPassSettings::ColorMask
ColorMask	glhack.h	/^    struct ColorMask{$/;"	s	class:glh::RenderPassSettings
Compilable	glhack.cpp	/^    enum Compilable {Shader = 0, Program = 1};$/;"	g	namespace:glh::__anon7	file:
ConstOption	shims_and_types.h	/^    ConstOption(const T* value):ptr(value){}$/;"	f	class:glh::ConstOption
ConstOption	shims_and_types.h	/^class ConstOption$/;"	c	namespace:glh
Container	shims_and_types.h	/^    typedef std::vector<T>                      Container;$/;"	t	struct:glh::SortedArray
Custom	glbase.h	/^    enum ButtonSource{Mouse, Keyboard, Custom};$/;"	e	enum:glh::Input::ButtonSource
DIR	win32_dirent.h	/^struct DIR {$/;"	s
DIR	win32_dirent.h	/^typedef struct DIR DIR;$/;"	t	typeref:struct:DIR
DIRENT_H	win32_dirent.h	93;"	d
DNL	stb_image.c	1594;"	d	file:
DTTOIF	win32_dirent.h	193;"	d
DT_BLK	win32_dirent.h	189;"	d
DT_CHR	win32_dirent.h	188;"	d
DT_DIR	win32_dirent.h	185;"	d
DT_FIFO	win32_dirent.h	186;"	d
DT_REG	win32_dirent.h	184;"	d
DT_SOCK	win32_dirent.h	187;"	d
DT_UNKNOWN	win32_dirent.h	183;"	d
DataContainer	shims_and_types.h	/^    typedef std::vector<T>                   DataContainer;$/;"	t	class:glh::Pool
Deallocator	glh_image.h	/^    typedef std::function<void(float*)> Deallocator;$/;"	t	class:glh::Image32
Deallocator	glh_image.h	/^    typedef std::function<void(uint8_t*)> Deallocator;$/;"	t	class:glh::Image8
DeclInterface	shims_and_types.h	25;"	d
DefaultAssetManager	asset_manager.cpp	/^    DefaultAssetManager(const char* config_file):config_file_path(config_file)$/;"	f	class:glh::DefaultAssetManager
DefaultAssetManager	asset_manager.cpp	/^class DefaultAssetManager : public AssetManager {$/;"	c	namespace:glh	file:
DefaultMesh	glh_mesh.cpp	/^DefaultMesh::DefaultMesh(){load_defaults(*this);}$/;"	f	class:glh::DefaultMesh
DefaultMesh	glh_mesh.h	/^class DefaultMesh {$/;"	c	namespace:glh
DefaultMesh	glh_typedefs.h	/^        DefaultMesh   = 7,$/;"	e	enum:glh::EntityType::t
DefaultMeshPtr	glh_mesh.h	/^typedef std::shared_ptr<DefaultMesh> DefaultMeshPtr;$/;"	t	namespace:glh
Del	glbase.h	/^        Del = GLFW_KEY_DEL,        $/;"	e	enum:glh::Input::Key
DelimEnum	masp.cpp	/^enum DelimEnum{$/;"	g	namespace:masp	file:
DepthMask	glhack.h	/^        DepthMask():flag_(GL_FALSE){}$/;"	f	struct:glh::RenderPassSettings::DepthMask
DepthMask	glhack.h	/^        DepthMask(GLboolean flag):flag_(flag){}$/;"	f	struct:glh::RenderPassSettings::DepthMask
DepthMask	glhack.h	/^    struct DepthMask{$/;"	s	class:glh::RenderPassSettings
DfsForestSort	glh_dynamic_graph.h	/^    DfsForestSort(const graph_t& graph):graph_(graph){$/;"	f	class:glh::DfsForestSort
DfsForestSort	glh_dynamic_graph.h	/^class DfsForestSort{$/;"	c	namespace:glh
Dim	math_tools.h	/^struct Dim{$/;"	s
Directory	iotools.h	/^    enum t{File, Directory, Unsupported};$/;"	e	enum:FilesystemReference::t
DirectoryBrowser	directory_browser.h	/^    DirectoryBrowser(){}$/;"	f	class:DirectoryBrowser
DirectoryBrowser	directory_browser.h	/^class DirectoryBrowser{$/;"	c
Down	glbase.h	/^        Down = GLFW_KEY_DOWN,       $/;"	e	enum:glh::Input::Key
Down	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	m	class:glh::Movement
DynamicGraph	glh_dynamic_graph.h	/^class DynamicGraph{$/;"	c	namespace:glh
DynamicNode	glh_dynamic_graph.h	/^        DynamicNode(const char* typestring):typename_(typestring){}$/;"	f	struct:glh::DynamicGraph::DynamicNode
DynamicNode	glh_dynamic_graph.h	/^    struct DynamicNode{$/;"	s	class:glh::DynamicGraph
DynamicNodeRef	glh_dynamic_graph.h	/^    DynamicNodeRef(DynamicGraph::DynamicNode* node, const std::string& name):node_(node), name_(name){}$/;"	f	struct:glh::DynamicNodeRef
DynamicNodeRef	glh_dynamic_graph.h	/^    DynamicNodeRef(DynamicGraph::DynamicNode* node, const std::string& name, glh::DynamicGraph& graph)$/;"	f	struct:glh::DynamicNodeRef
DynamicNodeRef	glh_dynamic_graph.h	/^struct DynamicNodeRef{$/;"	s	namespace:glh
DynamicSystem	glh_timebased_signals.h	/^class DynamicSystem{$/;"	c	namespace:glh
EIGEN_DONT_ALIGN	math_tools.h	7;"	d
EOI	stb_image.c	1596;"	d	file:
Easing	glh_timebased_signals.h	/^    struct Easing{$/;"	s	class:glh::Animation
Empty	glh_dynamic_graph.h	/^        enum t{Empty, Scalar, Vector2, Vector3, Vector4};$/;"	e	enum:glh::DynamicGraph::Value::t
EmptyNode	persistent_containers.h	/^        enum NodeType{EmptyNode, ValueNode, CollisionNode};$/;"	e	enum:glh::PMapPool::Node::NodeType
End	glbase.h	/^        End = GLFW_KEY_END,        $/;"	e	enum:glh::Input::Key
Enter	glbase.h	/^        Enter = GLFW_KEY_ENTER,      $/;"	e	enum:glh::Input::Key
EntityType	glh_typedefs.h	/^class EntityType{$/;"	c	namespace:glh
Env	masp.cpp	/^    Env()$/;"	f	class:masp::Masp::Env
Env	masp.cpp	/^class Masp::Env$/;"	c	class:masp::Masp	file:
Esc	glbase.h	/^        Esc = GLFW_KEY_ESC,        $/;"	e	enum:glh::Input::Key
EvaluationException	masp.h	/^    EvaluationException(const char* msg):msg_(msg){}$/;"	f	class:masp::EvaluationException
EvaluationException	masp.h	/^    EvaluationException(const std::string& msg):msg_(msg){}$/;"	f	class:masp::EvaluationException
EvaluationException	masp.h	/^class EvaluationException $/;"	c	namespace:masp
Event	glh_timebased_signals.h	/^        Event(){}$/;"	f	class:glh::DynamicSystem::Event
Event	glh_timebased_signals.h	/^        Event(event_t event):event_(event), is_done_(false){}$/;"	f	class:glh::DynamicSystem::Event
Event	glh_timebased_signals.h	/^    class Event{$/;"	c	class:glh::DynamicSystem
Event	glh_uicontext.h	/^        Event(const t& event):event_(event), button_(Input::any_button(Input::Custom, 0)){$/;"	f	struct:glh::UiContext::Event
Event	glh_uicontext.h	/^        Event(const t& event, const Input::AnyButton& button):event_(event), button_(button){$/;"	f	struct:glh::UiContext::Event
Event	glh_uicontext.h	/^    struct Event{$/;"	s	class:glh::UiContext
EventContainer	glbase.h	/^    typedef Pool<InputEvent> EventContainer;$/;"	t	class:glh::UserInput
EventType	glbase.h	/^    enum EventType{MouseMove, MouseWheelMove, MouseButton, Key};$/;"	g	class:glh::InputEvent
ExplicitTransform	math_tools.h	/^    ExplicitTransform(){initialize();}$/;"	f	struct:glh::ExplicitTransform
ExplicitTransform	math_tools.h	/^struct ExplicitTransform{$/;"	s	namespace:glh
F1	glbase.h	/^        F1 = GLFW_KEY_F1,         $/;"	e	enum:glh::Input::Key
F10	glbase.h	/^        F10 = GLFW_KEY_F10,        $/;"	e	enum:glh::Input::Key
F11	glbase.h	/^        F11 = GLFW_KEY_F11,        $/;"	e	enum:glh::Input::Key
F12	glbase.h	/^        F12 = GLFW_KEY_F12,        $/;"	e	enum:glh::Input::Key
F13	glbase.h	/^        F13 = GLFW_KEY_F13,        $/;"	e	enum:glh::Input::Key
F14	glbase.h	/^        F14 = GLFW_KEY_F14,        $/;"	e	enum:glh::Input::Key
F15	glbase.h	/^        F15 = GLFW_KEY_F15,        $/;"	e	enum:glh::Input::Key
F16	glbase.h	/^        F16 = GLFW_KEY_F16,        $/;"	e	enum:glh::Input::Key
F17	glbase.h	/^        F17 = GLFW_KEY_F17,        $/;"	e	enum:glh::Input::Key
F18	glbase.h	/^        F18 = GLFW_KEY_F18,        $/;"	e	enum:glh::Input::Key
F19	glbase.h	/^        F19 = GLFW_KEY_F19,        $/;"	e	enum:glh::Input::Key
F2	glbase.h	/^        F2 = GLFW_KEY_F2,         $/;"	e	enum:glh::Input::Key
F2	glh_generators.cpp	/^        double F2;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
F20	glbase.h	/^        F20 = GLFW_KEY_F20,        $/;"	e	enum:glh::Input::Key
F21	glbase.h	/^        F21 = GLFW_KEY_F21,        $/;"	e	enum:glh::Input::Key
F22	glbase.h	/^        F22 = GLFW_KEY_F22,        $/;"	e	enum:glh::Input::Key
F23	glbase.h	/^        F23 = GLFW_KEY_F23,        $/;"	e	enum:glh::Input::Key
F24	glbase.h	/^        F24 = GLFW_KEY_F24,        $/;"	e	enum:glh::Input::Key
F25	glbase.h	/^        F25 = GLFW_KEY_F25,        $/;"	e	enum:glh::Input::Key
F3	glbase.h	/^        F3 = GLFW_KEY_F3,         $/;"	e	enum:glh::Input::Key
F3	glh_generators.cpp	/^        double F3;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
F4	glbase.h	/^        F4 = GLFW_KEY_F4,         $/;"	e	enum:glh::Input::Key
F4	glh_generators.cpp	/^        double F4;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
F5	glbase.h	/^        F5 = GLFW_KEY_F5,         $/;"	e	enum:glh::Input::Key
F6	glbase.h	/^        F6 = GLFW_KEY_F6,         $/;"	e	enum:glh::Input::Key
F7	glbase.h	/^        F7 = GLFW_KEY_F7,         $/;"	e	enum:glh::Input::Key
F8	glbase.h	/^        F8 = GLFW_KEY_F8,         $/;"	e	enum:glh::Input::Key
F9	glbase.h	/^        F9 = GLFW_KEY_F9,         $/;"	e	enum:glh::Input::Key
FAST_BITS	stb_image.c	951;"	d	file:
FAULTY_SCOPE_CLOSING	masp.cpp	/^    enum Result{SCOPE_LEFT_OPEN, FAULTY_SCOPE_CLOSING, OK};$/;"	e	enum:masp::ScopeError::Result	file:
FILENAME_MAX	win32_dirent.h	176;"	d
FILE_ATTRIBUTE_DEVICE	win32_dirent.h	118;"	d
FIX	stb_truetype.h	1402;"	d
FIXED_COLOR	glh_uicontext.cpp	52;"	d	file:
FIXMASK	stb_truetype.h	1403;"	d
FIXSHIFT	stb_truetype.h	1401;"	d
FLOAT	masp.h	/^    enum Type{INT, FLOAT};$/;"	e	enum:masp::Number::Type
FLT_MAX	conversion.c	56;"	d	file:
FUNCTION	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
F_avg	stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon33	file:
F_avg_first	stb_image.c	/^   F_avg_first, F_paeth_first$/;"	e	enum:__anon33	file:
F_none	stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon33	file:
F_paeth	stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon33	file:
F_paeth_first	stb_image.c	/^   F_avg_first, F_paeth_first$/;"	e	enum:__anon33	file:
F_sub	stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon33	file:
F_up	stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon33	file:
File	iotools.h	/^    enum t{File, Directory, Unsupported};$/;"	e	enum:FilesystemReference::t
FilesystemReference	iotools.h	/^    FilesystemReference(std::string name, std::string fullpath, t type):$/;"	f	struct:FilesystemReference
FilesystemReference	iotools.h	/^struct FilesystemReference{$/;"	s
FixedStack	shims_and_types.h	/^    FixedStack():level_(0){}$/;"	f	class:glh::FixedStack
FixedStack	shims_and_types.h	/^class FixedStack$/;"	c	namespace:glh
Float	gltexture.h	/^    enum Pixel{UnsignedByte, Float};$/;"	e	enum:glh::TextureType::Pixel
Float32	glh_typedefs.h	/^    enum t{Float32};$/;"	e	enum:glh::TypeId::t
Focus	glh_scenemanagement.h	/^        Focus(FocusContext& ctx):ctx_(ctx){}$/;"	f	struct:glh::FocusContext::Focus
Focus	glh_scenemanagement.h	/^    struct Focus{$/;"	s	class:glh::FocusContext
FocusContext	glh_scenemanagement.h	/^class FocusContext{$/;"	c	namespace:glh
FontCharData	glh_font.cpp	/^struct FontCharData{$/;"	s	namespace:glh	file:
FontConfig	glh_font.h	/^struct FontConfig{$/;"	s	namespace:glh
FontContext	glh_font.cpp	/^FontContext::FontContext(const std::string& font_directory)$/;"	f	class:glh::FontContext
FontContext	glh_font.h	/^class FontContext {$/;"	c	namespace:glh
FontManager	glh_scene_extensions.h	/^    FontManager(GraphicsManager* gm, const std::string& font_directory):context_(font_directory),$/;"	f	class:glh::FontManager
FontManager	glh_scene_extensions.h	/^class FontManager$/;"	c	namespace:glh
FontManagerPtr	glh_scene_extensions.h	/^typedef std::unique_ptr<FontManager> FontManagerPtr;$/;"	t	namespace:glh
FullRenderable	glhack.h	/^    FullRenderable():program_(0),meshdata_on_gpu_(false), mesh_(0), meshdata_dirty_(false){}$/;"	f	class:glh::FullRenderable
FullRenderable	glhack.h	/^class FullRenderable {$/;"	c	namespace:glh
FullRenderablePtr	glhack.h	/^typedef std::shared_ptr<FullRenderable> FullRenderablePtr;$/;"	t	namespace:glh
FunBase	masp_classwrap.h	/^class FunBase{public:$/;"	c	namespace:masp
FunBasePtr	masp_classwrap.h	/^typedef std::shared_ptr<FunBase> FunBasePtr;$/;"	t	namespace:masp
FunMap	masp_classwrap.h	/^    FunMap(Masp& m){$/;"	f	class:masp::FunMap
FunMap	masp_classwrap.h	/^class FunMap{public:$/;"	c	namespace:masp
FunWrap0_0	masp_classwrap.h	/^    FunWrap0_0(funt fun):fun_(fun){}$/;"	f	class:masp::FunWrap0_0
FunWrap0_0	masp_classwrap.h	/^class FunWrap0_0 : public FunBase{public:$/;"	c	namespace:masp
FunWrap0_1	masp_classwrap.h	/^    FunWrap0_1(funt fun):fun_(fun){}$/;"	f	class:masp::FunWrap0_1
FunWrap0_1	masp_classwrap.h	/^class FunWrap0_1 : public FunBase{public:$/;"	c	namespace:masp
FunWrap1_0	masp_classwrap.h	/^    FunWrap1_0(funt fun):fun_(fun){}$/;"	f	class:masp::FunWrap1_0
FunWrap1_0	masp_classwrap.h	/^class FunWrap1_0 : public FunBase{public:$/;"	c	namespace:masp
FunWrap1_1	masp_classwrap.h	/^    FunWrap1_1(funt fun):fun_(fun){}$/;"	f	class:masp::FunWrap1_1
FunWrap1_1	masp_classwrap.h	/^class FunWrap1_1 : public FunBase{public:$/;"	c	namespace:masp
FunWrap1_2	masp_classwrap.h	/^    FunWrap1_2(funt fun):fun_(fun){}$/;"	f	class:masp::FunWrap1_2
FunWrap1_2	masp_classwrap.h	/^class FunWrap1_2 : public FunBase{public:$/;"	c	namespace:masp
Function	masp.cpp	/^struct Function{PrimitiveFunction fun;};$/;"	s	namespace:masp	file:
G2	glh_generators.cpp	/^        double G2;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
G3	glh_generators.cpp	/^        double G3;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
G4	glh_generators.cpp	/^        double G4;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
GLH_CAMERA_TO_SCREEN	glh_names.h	46;"	d
GLH_CHANNEL_POSITION	glh_names.h	16;"	d
GLH_CHANNEL_ROTATION	glh_names.h	15;"	d
GLH_CHANNEL_SCALE	glh_names.h	17;"	d
GLH_CHANNEL_TIME	glh_names.h	19;"	d
GLH_COLOR_ALBEDO	glh_names.h	49;"	d
GLH_COLOR_DELTA	glh_names.h	33;"	d
GLH_COLOR_PICKER_PROGRAM	glh_names.h	39;"	d
GLH_CONSTANT_ALBEDO_PROGRAM	glh_names.h	40;"	d
GLH_LOCAL_TO_WORLD	glh_names.h	44;"	d
GLH_LOG_EXPR	glsystem.h	22;"	d
GLH_PRIMARY_COLOR	glh_names.h	34;"	d
GLH_PROPERTY_1	glh_names.h	25;"	d
GLH_PROPERTY_2	glh_names.h	26;"	d
GLH_PROPERTY_BIAS	glh_names.h	28;"	d
GLH_PROPERTY_COLOR	glh_names.h	23;"	d
GLH_PROPERTY_DELTA	glh_names.h	31;"	d
GLH_PROPERTY_INTERPOLANT	glh_names.h	30;"	d
GLH_PROPERTY_POSITION_DELTA	glh_names.h	22;"	d
GLH_PROPERTY_SCALE	glh_names.h	29;"	d
GLH_PROPERTY_TIME_DELTA	glh_names.h	20;"	d
GLH_RAND_SEED	math_tools.h	496;"	d
GLH_SECONDARY_COLOR	glh_names.h	35;"	d
GLH_WORLD_TO_CAMERA	glh_names.h	45;"	d
GLH_WORLD_TO_SCREEN	glh_names.h	47;"	d
GarbageCollecting	managed_structures.h	/^class GarbageCollecting$/;"	c
GlyphCoords	glh_font.h	/^struct GlyphCoords{$/;"	s	namespace:glh
GlyphPane	glh_scene_extensions.h	/^    GlyphPane(GraphicsManager* gm, const std::string& program_name, const std::string& background_program_name, FontManager* fontmanager, const std::string& pane_name)$/;"	f	class:glh::GlyphPane
GlyphPane	glh_scene_extensions.h	/^class GlyphPane: public SceneObject$/;"	c	namespace:glh
GlyphPane	glh_typedefs.h	/^        GlyphPane      = 2005,$/;"	e	enum:glh::EntityType::t
Grad	glh_generators.cpp	/^        Grad(double x, double y, double z):x_(x), y_(y), z_(z), w_(0.0){}$/;"	f	struct:glh::SimplexNoise::Grad
Grad	glh_generators.cpp	/^        Grad(double x, double y, double z, double w):x_(x), y_(y), z_(z), w_(w){}$/;"	f	struct:glh::SimplexNoise::Grad
Grad	glh_generators.cpp	/^    struct Grad$/;"	s	struct:glh::SimplexNoise	file:
GraphicsException	glsystem.h	/^    GraphicsException(const char* msg):msg_(msg){}$/;"	f	class:glh::GraphicsException
GraphicsException	glsystem.h	/^    GraphicsException(const std::string& msg):msg_(msg){}$/;"	f	class:glh::GraphicsException
GraphicsException	glsystem.h	/^class GraphicsException{$/;"	c	namespace:glh
GraphicsManagerInt	glhack.cpp	/^    GraphicsManagerInt():current_program_(0){}$/;"	f	class:glh::GraphicsManagerInt
GraphicsManagerInt	glhack.cpp	/^class GraphicsManagerInt : public GraphicsManager$/;"	c	namespace:glh	file:
HASKEY	shims_and_types.h	793;"	d
HASKEY	shims_and_types.h	832;"	d
HDR_BUFLEN	stb_image.c	4214;"	d	file:
HIPART	conversion.c	86;"	d	file:
HIPART	conversion.c	89;"	d	file:
Held	glbase.h	/^    enum ButtonState{Held,Released};$/;"	e	enum:glh::Input::ButtonState
Home	glbase.h	/^        Home = GLFW_KEY_HOME,       $/;"	e	enum:glh::Input::Key
IDCT_1D	stb_image.c	1208;"	d	file:
IFN	glh_scene_extensions.cpp	115;"	d	file:
IFN	glh_scene_extensions.cpp	120;"	d	file:
IFN	glh_scene_extensions.cpp	150;"	d	file:
IFN	glh_scene_extensions.cpp	85;"	d	file:
IFTODT	win32_dirent.h	192;"	d
INCLUDE_STB_IMAGE_WRITE_H	stb_image_write.h	55;"	d
INDLIST	shims_and_types.h	830;"	d
INDSTACK	shims_and_types.h	791;"	d
INDVAL	shims_and_types.h	792;"	d
INDVAL	shims_and_types.h	831;"	d
INT	masp.h	/^    enum Type{INT, FLOAT};$/;"	e	enum:masp::Number::Type
IObject	masp.h	/^class IObject{$/;"	c	namespace:masp
IdGenerator	glh_typedefs.cpp	/^ObjectRoster::IdGenerator::IdGenerator(){$/;"	f	class:glh::ObjectRoster::IdGenerator
IdGenerator	glh_typedefs.h	/^    class IdGenerator{$/;"	c	class:glh::ObjectRoster
Image32	glh_image.cpp	/^Image32::Image32():width_(0), height_(0), channels_(0), data_(0), stride_(0),dealloc_(free_floatarray){}$/;"	f	class:glh::Image32
Image32	glh_image.cpp	/^Image32::Image32(Image32&& rhs):width_(rhs.width_), height_(rhs.height_), $/;"	f	class:glh::Image32
Image32	glh_image.cpp	/^Image32::Image32(const int w, const int h, const int chan):$/;"	f	class:glh::Image32
Image32	glh_image.cpp	/^Image32::Image32(const int w, const int h, const int chan, float* data, Deallocator dealloc):$/;"	f	class:glh::Image32
Image32	glh_image.h	/^class Image32 {$/;"	c	namespace:glh
Image32	glh_typedefs.h	/^        Image32       = 1011,$/;"	e	enum:glh::EntityType::t
Image8	glh_image.cpp	/^Image8::Image8():width_(0), height_(0), channels_(0), data_(0), stride_(0), dealloc_(free_uint8tarray){}$/;"	f	class:glh::Image8
Image8	glh_image.cpp	/^Image8::Image8(Image8&& rhs):width_(rhs.width_), height_(rhs.height_), $/;"	f	class:glh::Image8
Image8	glh_image.cpp	/^Image8::Image8(const int w, const int h, const int chan):$/;"	f	class:glh::Image8
Image8	glh_image.cpp	/^Image8::Image8(const int w, const int h, const int chan, uint8_t* data, Deallocator dealloc):$/;"	f	class:glh::Image8
Image8	glh_image.h	/^class Image8{$/;"	c	namespace:glh
Image8	glh_typedefs.h	/^        Image8        = 1010,$/;"	e	enum:glh::EntityType::t
Impl_s	glh_generators.cpp	/^        Impl_s()$/;"	f	struct:glh::SimplexNoise::Impl_s
Impl_s	glh_generators.cpp	/^    struct Impl_s$/;"	s	struct:glh::SimplexNoise	file:
Index	glh_typedefs.h	/^    enum t{Value,Index, T_LAST};$/;"	e	enum:glh::ChannelType::t
Input	glbase.h	/^class Input$/;"	c	namespace:glh
InputEvent	glbase.h	/^    InputEvent(){}$/;"	f	class:glh::InputEvent
InputEvent	glbase.h	/^    InputEvent(const EventType t, const Input::ButtonState s, int idv):type(t), dim1(0), dim2(0), state(s), id(idv){}$/;"	f	class:glh::InputEvent
InputEvent	glbase.h	/^    InputEvent(const EventType t, const int d1, const int d2, const int idv):type(t), dim1(d1), dim2(d2), id(idv){}$/;"	f	class:glh::InputEvent
InputEvent	glbase.h	/^class InputEvent$/;"	c	namespace:glh
InputFile	iotools.cpp	/^InputFile::InputFile(const char* path):file_(path, std::ios::in|std::ios::binary){}$/;"	f	class:InputFile
InputFile	iotools.h	/^    InputFile(const InputFile& i){}$/;"	f	class:InputFile
InputFile	iotools.h	/^class InputFile{$/;"	c
Insert	glbase.h	/^        Insert = GLFW_KEY_INSERT,     $/;"	e	enum:glh::Input::Key
Inserter1	shims_and_types.h	/^    Inserter1(Container& parent):parent_(parent){}$/;"	f	struct:glh::Inserter1
Inserter1	shims_and_types.h	/^struct Inserter1{$/;"	s	namespace:glh
Inserter2	shims_and_types.h	/^    Inserter2(Container& parent):parent_(parent){}$/;"	f	struct:glh::Inserter2
Inserter2	shims_and_types.h	/^struct Inserter2{$/;"	s	namespace:glh
InternalFormat	gltexture.h	/^    enum InternalFormat{R8, RGB8, RGBA8}; \/\/ TODO: add rest as needed (srgb, rgb32f etc.)$/;"	g	class:glh::TextureType
InterpolatingMap	math_tools.h	/^class InterpolatingMap{$/;"	c	namespace:glh
InterpolationType	math_tools.h	/^class InterpolationType{ public:$/;"	c	namespace:glh
InverseMap	shims_and_types.h	/^    typedef std::map<Value,Key> InverseMap;$/;"	t	class:glh::BiMap
Iterator	glh_scenemanagement.h	/^            Iterator(Node* n):i_(n->begin()), end_(n->end()){}$/;"	f	struct:glh::SceneTree::tree_iterator::Iterator
Iterator	glh_scenemanagement.h	/^        struct Iterator{$/;"	s	class:glh::SceneTree::tree_iterator
Key	glbase.h	/^    enum EventType{MouseMove, MouseWheelMove, MouseButton, Key};$/;"	e	enum:glh::InputEvent::EventType
Key	glbase.h	/^    enum Key{$/;"	g	class:glh::Input
KeyCallback	glbase.h	/^    typedef std::function<void(int, const Input::ButtonState&)> KeyCallback;$/;"	t	class:glh::UserInput
KeyInserter	shims_and_types.h	/^        KeyInserter(BiMap& parent, const Value& v):parent_(parent), v_(v){}$/;"	f	struct:glh::BiMap::KeyInserter
KeyInserter	shims_and_types.h	/^    struct KeyInserter$/;"	s	class:glh::BiMap
KeyValue	persistent_containers.h	/^    struct KeyValue{uint32_t hash; K first; V second;};$/;"	s	class:glh::PMapPool
KeyValueList	persistent_containers.h	/^    typedef typename PListPool<const KeyValue*>::List KeyValueList;$/;"	t	class:glh::PMapPool
KeyValueListPool	persistent_containers.h	/^    typedef          PListPool<const KeyValue*>       KeyValueListPool;$/;"	t	class:glh::PMapPool
Keyboard	glbase.h	/^    enum ButtonSource{Mouse, Keyboard, Custom};$/;"	e	enum:glh::Input::ButtonSource
Kp0	glbase.h	/^        Kp0 = GLFW_KEY_KP_0,       $/;"	e	enum:glh::Input::Key
Kp1	glbase.h	/^        Kp1 = GLFW_KEY_KP_1,       $/;"	e	enum:glh::Input::Key
Kp2	glbase.h	/^        Kp2 = GLFW_KEY_KP_2,       $/;"	e	enum:glh::Input::Key
Kp3	glbase.h	/^        Kp3 = GLFW_KEY_KP_3,       $/;"	e	enum:glh::Input::Key
Kp4	glbase.h	/^        Kp4 = GLFW_KEY_KP_4,       $/;"	e	enum:glh::Input::Key
Kp5	glbase.h	/^        Kp5 = GLFW_KEY_KP_5,       $/;"	e	enum:glh::Input::Key
Kp6	glbase.h	/^        Kp6 = GLFW_KEY_KP_6,       $/;"	e	enum:glh::Input::Key
Kp7	glbase.h	/^        Kp7 = GLFW_KEY_KP_7,       $/;"	e	enum:glh::Input::Key
Kp8	glbase.h	/^        Kp8 = GLFW_KEY_KP_8,       $/;"	e	enum:glh::Input::Key
Kp9	glbase.h	/^        Kp9 = GLFW_KEY_KP_9,       $/;"	e	enum:glh::Input::Key
KpAdd	glbase.h	/^        KpAdd = GLFW_KEY_KP_ADD,     $/;"	e	enum:glh::Input::Key
KpDecimal	glbase.h	/^        KpDecimal = GLFW_KEY_KP_DECIMAL, $/;"	e	enum:glh::Input::Key
KpDivide	glbase.h	/^        KpDivide = GLFW_KEY_KP_DIVIDE,  $/;"	e	enum:glh::Input::Key
KpEnter	glbase.h	/^        KpEnter = GLFW_KEY_KP_ENTER,   $/;"	e	enum:glh::Input::Key
KpEqual	glbase.h	/^        KpEqual = GLFW_KEY_KP_EQUAL,   $/;"	e	enum:glh::Input::Key
KpMultiply	glbase.h	/^        KpMultiply = GLFW_KEY_KP_MULTIPLY,$/;"	e	enum:glh::Input::Key
KpNumLock	glbase.h	/^        KpNumLock = GLFW_KEY_KP_NUM_LOCK,$/;"	e	enum:glh::Input::Key
KpSubtract	glbase.h	/^        KpSubtract = GLFW_KEY_KP_SUBTRACT,$/;"	e	enum:glh::Input::Key
LAST_TYPE	glh_typedefs.h	/^        LAST_TYPE$/;"	e	enum:glh::EntityType::t
LEFT_BRACE	masp.cpp	/^    LEFT_BRACE    = 2,$/;"	e	enum:masp::DelimEnum	file:
LEFT_BRACKET	masp.cpp	/^    LEFT_BRACKET  = 4,$/;"	e	enum:masp::DelimEnum	file:
LEFT_PAREN	masp.cpp	/^    LEFT_PAREN    = 0,$/;"	e	enum:masp::DelimEnum	file:
LIST	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
LOWPART	conversion.c	87;"	d	file:
LOWPART	conversion.c	90;"	d	file:
Lalt	glbase.h	/^        Lalt = GLFW_KEY_LALT,       $/;"	e	enum:glh::Input::Key
Last	glbase.h	/^        Last = GLFW_KEY_LAST$/;"	e	enum:glh::Input::Key
Layout	glh_layout_tools.h	/^struct Layout{$/;"	s	namespace:glh
Lctrl	glbase.h	/^        Lctrl = GLFW_KEY_LCTRL,      $/;"	e	enum:glh::Input::Key
Left	glbase.h	/^        Left = GLFW_KEY_LEFT,       $/;"	e	enum:glh::Input::Key
Left	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	m	class:glh::Movement
LeftBound	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	m	class:glh::Movement
LeftButton	glbase.h	/^    enum MouseButton{LeftButton = 0, RightButton = 1, MiddleButton = 2};$/;"	e	enum:glh::Input::MouseButton
Lerp	math_tools.h	/^template<class I, class G> class Lerp { public: $/;"	c	namespace:glh
LimitedIncrementalValue	glh_dynamic_graph.h	/^    LimitedIncrementalValue():value_(0.0), minimum_(-1.e37), maximum_(1.e37), DynamicGraph::DynamicNode("LimitedIncrementalValue"){$/;"	f	class:glh::LimitedIncrementalValue
LimitedIncrementalValue	glh_dynamic_graph.h	/^    LimitedIncrementalValue(double value, double min, double max):value_(value), minimum_(min), maximum_(max), DynamicGraph::DynamicNode("LimitedIncrementalValue"){$/;"	f	class:glh::LimitedIncrementalValue
LimitedIncrementalValue	glh_dynamic_graph.h	/^class LimitedIncrementalValue : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
Linear	glh_timebased_signals.h	/^        enum t{Linear, Smoothstep};$/;"	e	enum:glh::Animation::Easing::t
Linear	math_tools.h	/^    enum t{Nearest, Linear};$/;"	e	enum:glh::InterpolationType::t
List	glh_dynamic_graph.h	/^    List():head_(0), creator_(0){}$/;"	f	struct:glh::List
List	glh_dynamic_graph.h	/^    List(NodeCreator* node_creator):head_(0), creator_(node_creator){}$/;"	f	struct:glh::List
List	glh_dynamic_graph.h	/^    List(const List& other):head_(other.head_), creator_(other.creator_){}$/;"	f	struct:glh::List
List	glh_dynamic_graph.h	/^struct List {$/;"	s	namespace:glh
List	masp.h	/^typedef glh::PListPool<Value>::List        List;$/;"	t	namespace:masp
List	persistent_containers.h	/^        List(List&& temp_list):pool_(temp_list.pool_), head_(temp_list.head_)$/;"	f	class:glh::PListPool::List
List	persistent_containers.h	/^        List(PListPool& pool, Node* head):pool_(pool), head_(head){if(head_) pool_.add_ref(head_);}$/;"	f	class:glh::PListPool::List
List	persistent_containers.h	/^        List(const List& old_list):pool_(old_list.pool_), head_(old_list.head_)$/;"	f	class:glh::PListPool::List
List	persistent_containers.h	/^    class List$/;"	c	class:glh::PListPool
ListNode	glh_dynamic_graph.h	/^        ListNode(const T& data):data_(data), next_(0){}$/;"	f	struct:glh::List::ListNode
ListNode	glh_dynamic_graph.h	/^    struct ListNode{$/;"	s	struct:glh::List
ListPool	masp.h	/^typedef glh::PListPool<Value>              ListPool;$/;"	t	namespace:masp
ListPool	shims_and_types.h	/^    typedef Pool<Node> ListPool;$/;"	t	class:glh::PooledList
Lshift	glbase.h	/^        Lshift = GLFW_KEY_LSHIFT,     $/;"	e	enum:glh::Input::Key
Lsuper	glbase.h	/^        Lsuper = GLFW_KEY_LSUPER,     $/;"	e	enum:glh::Input::Key
MAP	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
MAPPING_LAST	glprogramvars.h	/^    enum Mapping{Uniform, StreamIn, StreamOut, MAPPING_LAST};$/;"	e	enum:glh::ShaderVar::Mapping
MARKER_none	stb_image.c	1322;"	d	file:
MASP_VERSION	masp.h	206;"	d
MIN_LOOP	tinymt32.c	17;"	d	file:
MIN_LOOP	tinymt64.c	18;"	d	file:
Map	masp.h	/^typedef MapPool::Map   Map;$/;"	t	namespace:masp
Map	persistent_containers.h	/^        Map(Map&& map):pool_(map.pool_), root_(map.root_)$/;"	f	class:glh::PMapPool::Map
Map	persistent_containers.h	/^        Map(PMapPool& pool, Node* root):pool_(pool), root_(root)$/;"	f	class:glh::PMapPool::Map
Map	persistent_containers.h	/^        Map(const Map& map):pool_(map.pool_), root_(map.root_)$/;"	f	class:glh::PMapPool::Map
Map	persistent_containers.h	/^    class Map$/;"	c	class:glh::PMapPool
Map	shims_and_types.h	/^    typedef std::map<Key,Value> Map;$/;"	t	class:glh::BiMap
MapHash	persistent_containers.h	/^class MapHash { public:$/;"	c	namespace:glh
MapPool	masp.h	/^typedef glh::PMapPool<Value, Value, ValuesAreEqual, ValueHash> MapPool;$/;"	t	namespace:masp
Mapping	glprogramvars.h	/^    enum Mapping{Uniform, StreamIn, StreamOut, MAPPING_LAST};$/;"	g	class:glh::ShaderVar
Masp	masp.cpp	/^Masp::Masp()$/;"	f	class:masp::Masp
Masp	masp.h	/^class Masp$/;"	c	namespace:masp
Mat4	glh_typedefs.h	/^        Mat4          = 1009,$/;"	e	enum:glh::EntityType::t
Mat4	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
Math	math_tools.h	/^class Math$/;"	c	namespace:glh
MemFunWrap0_0	masp_classwrap.h	/^    MemFunWrap0_0(funt fun):fun_(fun){}$/;"	f	class:masp::MemFunWrap0_0
MemFunWrap0_0	masp_classwrap.h	/^class MemFunWrap0_0 : public FunBase{public:$/;"	c	namespace:masp
MemFunWrap0_1	masp_classwrap.h	/^    MemFunWrap0_1(funt fun):fun_(fun){}$/;"	f	class:masp::MemFunWrap0_1
MemFunWrap0_1	masp_classwrap.h	/^class MemFunWrap0_1 : public FunBase{public:$/;"	c	namespace:masp
MemFunWrap1_0	masp_classwrap.h	/^    MemFunWrap1_0(funt fun):fun_(fun){}$/;"	f	class:masp::MemFunWrap1_0
MemFunWrap1_0	masp_classwrap.h	/^class MemFunWrap1_0 : public FunBase{public:$/;"	c	namespace:masp
MemFunWrap1_1	masp_classwrap.h	/^    MemFunWrap1_1(funt fun):fun_(fun){}$/;"	f	class:masp::MemFunWrap1_1
MemFunWrap1_1	masp_classwrap.h	/^class MemFunWrap1_1 : public FunBase{public:$/;"	c	namespace:masp
MemFunWrap1_2	masp_classwrap.h	/^    MemFunWrap1_2(funt fun):fun_(fun){}$/;"	f	class:masp::MemFunWrap1_2
MemFunWrap1_2	masp_classwrap.h	/^class MemFunWrap1_2 : public FunBase{public:$/;"	c	namespace:masp
Menu	glbase.h	/^        Menu = GLFW_KEY_MENU,       $/;"	e	enum:glh::Input::Key
MiddleButton	glbase.h	/^    enum MouseButton{LeftButton = 0, RightButton = 1, MiddleButton = 2};$/;"	e	enum:glh::Input::MouseButton
MixNode	glh_dynamic_graph.h	/^    MixNode():DynamicGraph::DynamicNode("MixNode"){$/;"	f	class:glh::MixNode
MixNode	glh_dynamic_graph.h	/^class MixNode : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
MixScalar	glh_dynamic_graph.h	/^     MixScalar(float fst, float snd):DynamicGraph::DynamicNode("MixScalar"){$/;"	f	class:glh::MixScalar
MixScalar	glh_dynamic_graph.h	/^    MixScalar():DynamicGraph::DynamicNode("MixScalar"){$/;"	f	class:glh::MixScalar
MixScalar	glh_dynamic_graph.h	/^class MixScalar : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
Modifiers	glh_scene_extensions.h	/^    Modifiers():shift_(false), ctrl_(false){}$/;"	f	struct:glh::Modifiers
Modifiers	glh_scene_extensions.h	/^struct Modifiers$/;"	s	namespace:glh
Mouse	glbase.h	/^    enum ButtonSource{Mouse, Keyboard, Custom};$/;"	e	enum:glh::Input::ButtonSource
MouseButton	glbase.h	/^    enum EventType{MouseMove, MouseWheelMove, MouseButton, Key};$/;"	e	enum:glh::InputEvent::EventType
MouseButton	glbase.h	/^    enum MouseButton{LeftButton = 0, RightButton = 1, MiddleButton = 2};$/;"	g	class:glh::Input
MouseMove	glbase.h	/^    enum EventType{MouseMove, MouseWheelMove, MouseButton, Key};$/;"	e	enum:glh::InputEvent::EventType
MouseMoveCallback	glbase.h	/^    typedef std::function<void(int x, int y)>                   MouseMoveCallback;$/;"	t	class:glh::UserInput
MouseMoved	glh_uicontext.h	/^            ButtonActivated, ButtonDeactivated, MouseMoved$/;"	e	enum:glh::UiContext::Event::t
MouseWheelCallback	glbase.h	/^    typedef std::function<void(int x)>                          MouseWheelCallback;$/;"	t	class:glh::UserInput
MouseWheelMove	glbase.h	/^    enum EventType{MouseMove, MouseWheelMove, MouseButton, Key};$/;"	e	enum:glh::InputEvent::EventType
Movement	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	c	namespace:glh
MovementMapper	glh_uicontext.h	/^    typedef std::function<void(vec3, SceneTree::Node*)> MovementMapper; \/\/> Maps a delta vector in normalized device coordinates to node interaction$/;"	t	namespace:glh
MovementMapperGen	glh_uicontext.h	/^    typedef std::function<MovementMapper(App*, const mat4&, SceneTree*, SceneTree::Node*)> MovementMapperGen;$/;"	t	namespace:glh
NAME_MAX	win32_dirent.h	179;"	d
NIL	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
NOMINMAX	glsystem.h	8;"	d
NUMBER	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
NUMBER_ARRAY	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
NamedBufferHandles	glbuffers.h	/^typedef std::map<std::string, BufferHandlePtr > NamedBufferHandles;$/;"	t	namespace:glh
Nearest	math_tools.h	/^    enum t{Nearest, Linear};$/;"	e	enum:glh::InterpolationType::t
NegX	gltexture.h	/^                PosX, NegX,$/;"	e	enum:glh::TextureType::Target
NegY	gltexture.h	/^                PosY, NegY, $/;"	e	enum:glh::TextureType::Target
NegZ	gltexture.h	/^                PosZ, NegZ};$/;"	e	enum:glh::TextureType::Target
Node	glh_scenemanagement.h	/^        Node():renderable_(0){$/;"	f	class:glh::SceneTree::Node
Node	glh_scenemanagement.h	/^        Node(FullRenderable* renderable):renderable_(renderable){$/;"	f	class:glh::SceneTree::Node
Node	glh_scenemanagement.h	/^        Node(FullRenderable* renderable, int id):renderable_(renderable), id_(id){$/;"	f	class:glh::SceneTree::Node
Node	glh_scenemanagement.h	/^    class Node : public SceneObject{$/;"	c	class:glh::SceneTree
Node	persistent_containers.h	/^        Node():used(0), child_array(0){}$/;"	f	struct:glh::PMapPool::Node
Node	persistent_containers.h	/^    struct Node$/;"	s	class:glh::PListPool
Node	persistent_containers.h	/^    struct Node$/;"	s	class:glh::PMapPool
Node	shims_and_types.h	/^    struct Node{$/;"	s	class:glh::PooledList
NodeChildIterator	persistent_containers.h	/^        NodeChildIterator(Node* node_in):node(node_in), iterating(false), node_has_children(false)$/;"	f	struct:glh::PMapPool::NodeChildIterator
NodeChildIterator	persistent_containers.h	/^    struct NodeChildIterator$/;"	s	class:glh::PMapPool
NodeCreator	glh_dynamic_graph.h	/^    struct NodeCreator {$/;"	s	struct:glh::List
NodeFocusState	glh_dynamic_graph.h	/^    NodeFocusState(SceneTree::Node* node, FocusContext& context):node_(node), context_(context), DynamicGraph::DynamicNode("NodeFocusState"){$/;"	f	class:glh::NodeFocusState
NodeFocusState	glh_dynamic_graph.h	/^class NodeFocusState : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
NodeReciever	glh_dynamic_graph.h	/^    NodeReciever(SceneTree::Node* node):node_(node), DynamicGraph::DynamicNode("NodeReciever"){$/;"	f	class:glh::NodeReciever
NodeReciever	glh_dynamic_graph.h	/^class NodeReciever : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
NodeSource	glh_dynamic_graph.h	/^    NodeSource(SceneTree::Node* node, std::list<std::string> vars):node_(node), vars_(vars), DynamicGraph::DynamicNode("NodeSource"){$/;"	f	class:glh::NodeSource
NodeSource	glh_dynamic_graph.h	/^class NodeSource : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
NodeType	persistent_containers.h	/^        enum NodeType{EmptyNode, ValueNode, CollisionNode};$/;"	g	struct:glh::PMapPool::Node
NodeValueIterator	persistent_containers.h	/^        NodeValueIterator():node(0), keyvalue(0), iteration_ongoing(false){}$/;"	f	struct:glh::PMapPool::NodeValueIterator
NodeValueIterator	persistent_containers.h	/^        NodeValueIterator(Node* node_in):node(node_in), keyvalue(0), iteration_ongoing(false)$/;"	f	struct:glh::PMapPool::NodeValueIterator
NodeValueIterator	persistent_containers.h	/^    struct NodeValueIterator$/;"	s	class:glh::PMapPool
Normal	glh_typedefs.h	/^            Normal   = 1, $/;"	e	enum:glh::ChannelType::s
Number	masp.h	/^struct Number{$/;"	s	namespace:masp
NumberArray	masp.h	/^typedef std::vector<Number> NumberArray;$/;"	t	namespace:masp
OBJECT	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
OK	masp.cpp	/^    enum Result{SCOPE_LEFT_OPEN, FAULTY_SCOPE_CLOSING, OK};$/;"	e	enum:masp::ScopeError::Result	file:
OPDEF	masp.cpp	2105;"	d	file:
ObjectRoster	glh_typedefs.h	/^class ObjectRoster {$/;"	c	namespace:glh
Orthographic	glh_scenemanagement.h	/^        Orthographic,           \/\/ Maps mesh coordinates to view with scaling$/;"	m	class:glh::Camera::Projection
OutOfRangeException	shims_and_types.h	/^    OutOfRangeException(const char* msg):msg_(msg){}$/;"	f	class:glh::OutOfRangeException
OutOfRangeException	shims_and_types.h	/^    OutOfRangeException(const std::string& msg):msg_(msg){}$/;"	f	class:glh::OutOfRangeException
OutOfRangeException	shims_and_types.h	/^class OutOfRangeException{$/;"	c	namespace:glh
OutputFile	iotools.cpp	/^OutputFile::OutputFile(const char* path)$/;"	f	class:OutputFile
OutputFile	iotools.cpp	/^OutputFile::OutputFile(const char* path, bool append)$/;"	f	class:OutputFile
OutputFile	iotools.h	/^    OutputFile(const OutputFile& o){}$/;"	f	class:OutputFile
OutputFile	iotools.h	/^class OutputFile{$/;"	c
PARSE_FLOAT	masp.cpp	/^typedef enum ParseResult_t{PARSE_NIL, PARSE_INT, PARSE_FLOAT} ParseResult;$/;"	e	enum:masp::ParseResult_t	file:
PARSE_INT	masp.cpp	/^typedef enum ParseResult_t{PARSE_NIL, PARSE_INT, PARSE_FLOAT} ParseResult;$/;"	e	enum:masp::ParseResult_t	file:
PARSE_NIL	masp.cpp	/^typedef enum ParseResult_t{PARSE_NIL, PARSE_INT, PARSE_FLOAT} ParseResult;$/;"	e	enum:masp::ParseResult_t	file:
PATH_MAX	win32_dirent.h	173;"	d
PIf	math_tools.h	23;"	d
PListPool	persistent_containers.h	/^    PListPool()$/;"	f	class:glh::PListPool
PListPool	persistent_containers.h	/^class PListPool$/;"	c	namespace:glh
PMapPool	persistent_containers.h	/^class PMapPool$/;"	c	namespace:glh
PNG_TYPE	stb_image.c	2395;"	d	file:
PRE_LOOP	tinymt32.c	18;"	d	file:
PRIMARY_COLOR	glh_uicontext.cpp	50;"	d	file:
Pagedown	glbase.h	/^        Pagedown = GLFW_KEY_PAGEDOWN,   $/;"	e	enum:glh::Input::Key
Pageup	glbase.h	/^        Pageup = GLFW_KEY_PAGEUP,     $/;"	e	enum:glh::Input::Key
ParamMap	glhack.h	/^        ParamMap(RenderEnvironment& env, const std::string& name):env_(env), name_(name){}$/;"	f	struct:glh::RenderEnvironment::ParamMap
ParamMap	glhack.h	/^    struct ParamMap{$/;"	s	class:glh::RenderEnvironment
ParseResult	masp.cpp	/^typedef enum ParseResult_t{PARSE_NIL, PARSE_INT, PARSE_FLOAT} ParseResult;$/;"	t	namespace:masp	typeref:enum:masp::ParseResult_t	file:
ParseResult_t	masp.cpp	/^typedef enum ParseResult_t{PARSE_NIL, PARSE_INT, PARSE_FLOAT} ParseResult;$/;"	g	namespace:masp	file:
PathArray	glh_scenemanagement.h	/^typedef std::vector<std::string> PathArray;$/;"	t	namespace:glh
Pause	glbase.h	/^        Pause = GLFW_KEY_PAUSE,      $/;"	e	enum:glh::Input::Key
PickedContext	glh_scenemanagement.h	/^        PickedContext(RenderPicker& picker):picker_(picker){}$/;"	f	struct:glh::RenderPicker::PickedContext
PickedContext	glh_scenemanagement.h	/^    struct PickedContext{$/;"	s	class:glh::RenderPicker
Pixel	gltexture.h	/^    enum Pixel{UnsignedByte, Float};$/;"	g	class:glh::TextureType
PixelSpaceOrthographic	glh_scenemanagement.h	/^        PixelSpaceOrthographic, \/\/ Maps mesh coordinates to view with default that mesh coordinates are in pixel space.$/;"	m	class:glh::Camera::Projection
Plane	geometry.h	/^    Plane(double a, double b, double c, double d):a_(a), b_(b), c_(c), d_(d){}$/;"	f	struct:glh::Plane
Plane	geometry.h	/^struct Plane{$/;"	s	namespace:glh
Point	geometry.h	/^template<class T> struct Point{T x, y, z;};$/;"	s	namespace:glh
Polygon	geometry.h	/^template<class T> struct Polygon{std::list<Point<T>> points;};$/;"	s	namespace:glh
Polygon3	geometry.h	/^typedef Polygon<float>  Polygon3;$/;"	t	namespace:glh
Polygon3d	geometry.h	/^typedef Polygon<double> Polygon3d;$/;"	t	namespace:glh
Polygon3i	geometry.h	/^typedef Polygon<int>    Polygon3i;$/;"	t	namespace:glh
Pool	shims_and_types.h	/^    Pool():live_count_(0){}$/;"	f	class:glh::Pool
Pool	shims_and_types.h	/^class Pool {$/;"	c	namespace:glh
PooledList	shims_and_types.h	/^    PooledList(ListPool& pool_):head_(nullptr), tail_(nullptr){}$/;"	f	class:glh::PooledList
PooledList	shims_and_types.h	/^class PooledList {$/;"	c	namespace:glh
PosX	gltexture.h	/^                PosX, NegX,$/;"	e	enum:glh::TextureType::Target
PosY	gltexture.h	/^                PosY, NegY, $/;"	e	enum:glh::TextureType::Target
PosZ	gltexture.h	/^                PosZ, NegZ};$/;"	e	enum:glh::TextureType::Target
Position	glh_typedefs.h	/^    enum s{ Position = 0,$/;"	e	enum:glh::ChannelType::s
PrefixHelper	masp.cpp	/^typedef std::string (*PrefixHelper)(const Value& v);$/;"	t	class:masp::std	file:
PrimitiveFunction	masp.h	/^typedef std::function<Value(Masp& m, Vector& args, Map& env)> PrimitiveFunction;$/;"	t	namespace:masp
Program	glhack.cpp	/^    enum Compilable {Shader = 0, Program = 1};$/;"	e	enum:glh::__anon7::Compilable	file:
ProgramHandle	glh_typedefs.h	/^        ProgramHandle = 5,$/;"	e	enum:glh::EntityType::t
Projection	glh_scenemanagement.h	/^    enum class Projection{$/;"	c	class:glh::Camera
QUOTE	masp.cpp	/^    QUOTE         = 7$/;"	e	enum:masp::DelimEnum	file:
R	gltexture.h	/^    enum Channels{R, RGB, RGBA};$/;"	e	enum:glh::TextureType::Channels
R	masp_classwrap.h	/^PrimitiveFunction wrap_member(R (T::*mmbr)(P0)){$/;"	f	namespace:masp
R	masp_classwrap.h	/^PrimitiveFunction wrap_member(R (T::*mmbr)(P0, P1)){$/;"	f	namespace:masp
R	masp_classwrap.h	/^PrimitiveFunction wrap_member(R (T::*mmbr)(void)){$/;"	f	namespace:masp
R8	gltexture.h	/^    enum InternalFormat{R8, RGB8, RGBA8}; \/\/ TODO: add rest as needed (srgb, rgb32f etc.)$/;"	e	enum:glh::TextureType::InternalFormat
RESTART	stb_image.c	1339;"	d	file:
RGB	gltexture.h	/^    enum Channels{R, RGB, RGBA};$/;"	e	enum:glh::TextureType::Channels
RGB8	gltexture.h	/^    enum InternalFormat{R8, RGB8, RGBA8}; \/\/ TODO: add rest as needed (srgb, rgb32f etc.)$/;"	e	enum:glh::TextureType::InternalFormat
RGBA	gltexture.h	/^    enum Channels{R, RGB, RGBA};$/;"	e	enum:glh::TextureType::Channels
RGBA8	gltexture.h	/^    enum InternalFormat{R8, RGB8, RGBA8}; \/\/ TODO: add rest as needed (srgb, rgb32f etc.)$/;"	e	enum:glh::TextureType::InternalFormat
RIGHT_BRACE	masp.cpp	/^    RIGHT_BRACE   = 3,$/;"	e	enum:masp::DelimEnum	file:
RIGHT_BRACKET	masp.cpp	/^    RIGHT_BRACKET = 5,$/;"	e	enum:masp::DelimEnum	file:
RIGHT_PAREN	masp.cpp	/^    RIGHT_PAREN   = 1,$/;"	e	enum:masp::DelimEnum	file:
RX	math_tools.h	/^    enum euler_t{RX = 0, RY = 1, RZ = 2};$/;"	e	enum:Dim::euler_t
RY	math_tools.h	/^    enum euler_t{RX = 0, RY = 1, RZ = 2};$/;"	e	enum:Dim::euler_t
RZ	math_tools.h	/^    enum euler_t{RX = 0, RY = 1, RZ = 2};$/;"	e	enum:Dim::euler_t
Ralt	glbase.h	/^        Ralt = GLFW_KEY_RALT,       $/;"	e	enum:glh::Input::Key
Random	math_tools.h	/^    Random(){init(GLH_RAND_SEED);}$/;"	f	struct:glh::Random
Random	math_tools.h	/^    Random(int seed){init(seed);}$/;"	f	struct:glh::Random
Random	math_tools.h	/^struct Random<float>$/;"	s	namespace:glh
Random	math_tools.h	/^struct Random<int32_t>$/;"	s	namespace:glh
Random	math_tools.h	/^struct Random{$/;"	s	namespace:glh
RandomRange	math_tools.h	/^    RandomRange(float start_, float end_):start(start_), end(end_){init();}$/;"	f	struct:glh::RandomRange
RandomRange	math_tools.h	/^    RandomRange(float start_, float end_, int seed):random(seed),start(start_), end(end_){init();}$/;"	f	struct:glh::RandomRange
RandomRange	math_tools.h	/^    RandomRange(int32_t start_, int32_t end_):start(start_), end(end_){init();}$/;"	f	struct:glh::RandomRange
RandomRange	math_tools.h	/^    RandomRange(int32_t start_, int32_t end_, int seed):random(seed),start(start_), end(end_){init();}$/;"	f	struct:glh::RandomRange
RandomRange	math_tools.h	/^struct RandomRange$/;"	s	namespace:glh
RandomRange	math_tools.h	/^struct RandomRange<float>$/;"	s	namespace:glh
RandomRange	math_tools.h	/^struct RandomRange<int32_t>$/;"	s	namespace:glh
Range	math_tools.h	/^    Range(T range_start, T increment, T range_end):$/;"	f	class:glh::Range
Range	math_tools.h	/^    Range(T range_start, T range_end):$/;"	f	class:glh::Range
Range	math_tools.h	/^template<class T> class Range {$/;"	c	namespace:glh
Rctrl	glbase.h	/^        Rctrl = GLFW_KEY_RCTRL,      $/;"	e	enum:glh::Input::Key
Ref	persistent_containers.h	/^        struct Ref$/;"	s	struct:glh::PMapPool::Node
Released	glbase.h	/^    enum ButtonState{Held,Released};$/;"	e	enum:glh::Input::ButtonState
RenderEnvironment	glhack.h	/^class RenderEnvironment{$/;"	c	namespace:glh
RenderPass	glh_scenemanagement.h	/^    RenderPass():active_filter_(pass_all), camera_(0){}$/;"	f	class:glh::RenderPass
RenderPass	glh_scenemanagement.h	/^class RenderPass : public SceneObject{$/;"	c	namespace:glh
RenderPass	glh_typedefs.h	/^        RenderPass     = 2002,$/;"	e	enum:glh::EntityType::t
RenderPassSettings	glhack.cpp	/^RenderPassSettings::RenderPassSettings():$/;"	f	class:glh::RenderPassSettings
RenderPassSettings	glhack.cpp	/^RenderPassSettings::RenderPassSettings(BlendSettings& blend_settings){$/;"	f	class:glh::RenderPassSettings
RenderPassSettings	glhack.cpp	/^RenderPassSettings::RenderPassSettings(ColorMask& color_mask_param){$/;"	f	class:glh::RenderPassSettings
RenderPassSettings	glhack.cpp	/^RenderPassSettings::RenderPassSettings(DepthMask& depth_mask_param){$/;"	f	class:glh::RenderPassSettings
RenderPassSettings	glhack.cpp	/^RenderPassSettings::RenderPassSettings(const GLuint clear_mask, const Color& color, const GLclampd depth)$/;"	f	class:glh::RenderPassSettings
RenderPassSettings	glhack.h	/^class RenderPassSettings$/;"	c	namespace:glh
RenderPicker	glh_scenemanagement.h	/^    RenderPicker(App& app):app_(app){}$/;"	f	class:glh::RenderPicker
RenderPicker	glh_scenemanagement.h	/^class RenderPicker{$/;"	c	namespace:glh
RenderPickerPtr	glh_scenemanagement.h	/^typedef std::shared_ptr<RenderPicker> RenderPickerPtr;$/;"	t	namespace:glh
RenderQueue	glh_scenemanagement.h	/^    RenderQueue(){}$/;"	f	class:glh::RenderQueue
RenderQueue	glh_scenemanagement.h	/^class RenderQueue{$/;"	c	namespace:glh
Result	masp.cpp	/^    enum Result{SCOPE_LEFT_OPEN, FAULTY_SCOPE_CLOSING, OK};$/;"	g	struct:masp::ScopeError	file:
Right	glbase.h	/^        Right = GLFW_KEY_RIGHT,      $/;"	e	enum:glh::Input::Key
Right	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	m	class:glh::Movement
RightBound	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	m	class:glh::Movement
RightButton	glbase.h	/^    enum MouseButton{LeftButton = 0, RightButton = 1, MiddleButton = 2};$/;"	e	enum:glh::Input::MouseButton
Rshift	glbase.h	/^        Rshift = GLFW_KEY_RSHIFT,     $/;"	e	enum:glh::Input::Key
Rsuper	glbase.h	/^        Rsuper = GLFW_KEY_RSUPER,     $/;"	e	enum:glh::Input::Key
SCAN_header	stb_image.c	/^   SCAN_header$/;"	e	enum:__anon24	file:
SCAN_load	stb_image.c	/^   SCAN_load=0,$/;"	e	enum:__anon24	file:
SCAN_type	stb_image.c	/^   SCAN_type,$/;"	e	enum:__anon24	file:
SCOPE_LEFT_OPEN	masp.cpp	/^    enum Result{SCOPE_LEFT_OPEN, FAULTY_SCOPE_CLOSING, OK};$/;"	e	enum:masp::ScopeError::Result	file:
SECONDARY_COLOR	glh_uicontext.cpp	51;"	d	file:
SEMICOLON	masp.cpp	/^    SEMICOLON     = 6,$/;"	e	enum:masp::DelimEnum	file:
SOF	stb_image.c	1597;"	d	file:
SOI	stb_image.c	1595;"	d	file:
SOS	stb_image.c	1598;"	d	file:
STBI_HAS_LROTL	stb_image.c	378;"	d	file:
STBI_INCLUDE_STB_IMAGE_H	stb_image.c	65;"	d	file:
STBI_NOTUSED	stb_image.c	375;"	d	file:
STBI_NO_WRITE	stb_image.c	372;"	d	file:
STBI_VERSION	stb_image.c	196;"	d	file:
STBI_default	stb_image.c	/^   STBI_default = 0, \/\/ only used for req_comp$/;"	e	enum:__anon21	file:
STBI_grey	stb_image.c	/^   STBI_grey       = 1,$/;"	e	enum:__anon21	file:
STBI_grey_alpha	stb_image.c	/^   STBI_grey_alpha = 2,$/;"	e	enum:__anon21	file:
STBI_rgb	stb_image.c	/^   STBI_rgb        = 3,$/;"	e	enum:__anon21	file:
STBI_rgb_alpha	stb_image.c	/^   STBI_rgb_alpha  = 4$/;"	e	enum:__anon21	file:
STBTT_MACSTYLE_BOLD	stb_truetype.h	669;"	d
STBTT_MACSTYLE_DONTCARE	stb_truetype.h	668;"	d
STBTT_MACSTYLE_ITALIC	stb_truetype.h	670;"	d
STBTT_MACSTYLE_NONE	stb_truetype.h	672;"	d
STBTT_MACSTYLE_UNDERSCORE	stb_truetype.h	671;"	d
STBTT_MAC_EID_ARABIC	stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon43
STBTT_MAC_EID_CHINESE_TRAD	stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon43
STBTT_MAC_EID_GREEK	stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon43
STBTT_MAC_EID_HEBREW	stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon43
STBTT_MAC_EID_JAPANESE	stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon43
STBTT_MAC_EID_KOREAN	stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon43
STBTT_MAC_EID_ROMAN	stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon43
STBTT_MAC_EID_RUSSIAN	stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon43
STBTT_MAC_LANG_ARABIC	stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon45
STBTT_MAC_LANG_CHINESE_SIMPLIFIED	stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon45
STBTT_MAC_LANG_CHINESE_TRAD	stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon45
STBTT_MAC_LANG_DUTCH	stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon45
STBTT_MAC_LANG_ENGLISH	stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon45
STBTT_MAC_LANG_FRENCH	stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon45
STBTT_MAC_LANG_GERMAN	stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon45
STBTT_MAC_LANG_HEBREW	stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon45
STBTT_MAC_LANG_ITALIAN	stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon45
STBTT_MAC_LANG_JAPANESE	stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon45
STBTT_MAC_LANG_KOREAN	stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon45
STBTT_MAC_LANG_RUSSIAN	stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon45
STBTT_MAC_LANG_SPANISH	stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon45
STBTT_MAC_LANG_SWEDISH	stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon45
STBTT_MS_EID_SHIFTJIS	stb_truetype.h	/^   STBTT_MS_EID_SHIFTJIS      =2,$/;"	e	enum:__anon42
STBTT_MS_EID_SYMBOL	stb_truetype.h	/^   STBTT_MS_EID_SYMBOL        =0,$/;"	e	enum:__anon42
STBTT_MS_EID_UNICODE_BMP	stb_truetype.h	/^   STBTT_MS_EID_UNICODE_BMP   =1,$/;"	e	enum:__anon42
STBTT_MS_EID_UNICODE_FULL	stb_truetype.h	/^   STBTT_MS_EID_UNICODE_FULL  =10$/;"	e	enum:__anon42
STBTT_MS_LANG_CHINESE	stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon44
STBTT_MS_LANG_DUTCH	stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon44
STBTT_MS_LANG_ENGLISH	stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon44
STBTT_MS_LANG_FRENCH	stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon44
STBTT_MS_LANG_GERMAN	stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon44
STBTT_MS_LANG_HEBREW	stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon44
STBTT_MS_LANG_ITALIAN	stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon44
STBTT_MS_LANG_JAPANESE	stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon44
STBTT_MS_LANG_KOREAN	stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon44
STBTT_MS_LANG_RUSSIAN	stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon44
STBTT_MS_LANG_SPANISH	stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon44
STBTT_MS_LANG_SWEDISH	stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon44
STBTT_PLATFORM_ID_ISO	stb_truetype.h	/^   STBTT_PLATFORM_ID_ISO       =2,$/;"	e	enum:__anon40
STBTT_PLATFORM_ID_MAC	stb_truetype.h	/^   STBTT_PLATFORM_ID_MAC       =1,$/;"	e	enum:__anon40
STBTT_PLATFORM_ID_MICROSOFT	stb_truetype.h	/^   STBTT_PLATFORM_ID_MICROSOFT =3$/;"	e	enum:__anon40
STBTT_PLATFORM_ID_UNICODE	stb_truetype.h	/^   STBTT_PLATFORM_ID_UNICODE   =0,$/;"	e	enum:__anon40
STBTT_UNICODE_EID_ISO_10646	stb_truetype.h	/^   STBTT_UNICODE_EID_ISO_10646      =2,$/;"	e	enum:__anon41
STBTT_UNICODE_EID_UNICODE_1_0	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_0    =0,$/;"	e	enum:__anon41
STBTT_UNICODE_EID_UNICODE_1_1	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_1    =1,$/;"	e	enum:__anon41
STBTT_UNICODE_EID_UNICODE_2_0_BMP	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,$/;"	e	enum:__anon41
STBTT_UNICODE_EID_UNICODE_2_0_FULL	stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4$/;"	e	enum:__anon41
STBTT_assert	stb_truetype.h	375;"	d
STBTT_free	stb_truetype.h	370;"	d
STBTT_iceil	stb_truetype.h	363;"	d
STBTT_ifloor	stb_truetype.h	362;"	d
STBTT_malloc	stb_truetype.h	369;"	d
STBTT_memcpy	stb_truetype.h	385;"	d
STBTT_memset	stb_truetype.h	386;"	d
STBTT_sort	stb_truetype.h	356;"	d
STBTT_strlen	stb_truetype.h	380;"	d
STBTT_vcurve	stb_truetype.h	/^      STBTT_vcurve$/;"	e	enum:__anon37
STBTT_vline	stb_truetype.h	/^      STBTT_vline,$/;"	e	enum:__anon37
STBTT_vmove	stb_truetype.h	/^      STBTT_vmove=1,$/;"	e	enum:__anon37
STB_IMAGE_WRITE_IMPLEMENTATION	glh_image.cpp	9;"	d	file:
STB_TRUETYPE_IMPLEMENTATION	glh_font.cpp	11;"	d	file:
STB_TRUETYPE_IMPLEMENTATION	glh_font.cpp	13;"	d	file:
STRING	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
SX	math_tools.h	/^    enum scale_t{SX = 0, SY = 1, SZ = 2};$/;"	e	enum:Dim::scale_t
SY	math_tools.h	/^    enum scale_t{SX = 0, SY = 1, SZ = 2};$/;"	e	enum:Dim::scale_t
SYMBOL	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
SZ	math_tools.h	/^    enum scale_t{SX = 0, SY = 1, SZ = 2};$/;"	e	enum:Dim::scale_t
S_IEXEC	win32_dirent.h	144;"	d
S_IFBLK	win32_dirent.h	150;"	d
S_IFCHR	win32_dirent.h	129;"	d
S_IFDIR	win32_dirent.h	126;"	d
S_IFFIFO	win32_dirent.h	132;"	d
S_IFIFO	win32_dirent.h	147;"	d
S_IFLNK	win32_dirent.h	153;"	d
S_IFMT	win32_dirent.h	123;"	d
S_IFREG	win32_dirent.h	135;"	d
S_IFSOCK	win32_dirent.h	156;"	d
S_IREAD	win32_dirent.h	138;"	d
S_IRGRP	win32_dirent.h	163;"	d
S_IROTH	win32_dirent.h	166;"	d
S_IRUSR	win32_dirent.h	160;"	d
S_ISBLK	win32_dirent.h	207;"	d
S_ISCHR	win32_dirent.h	206;"	d
S_ISDIR	win32_dirent.h	202;"	d
S_ISFIFO	win32_dirent.h	201;"	d
S_ISLNK	win32_dirent.h	204;"	d
S_ISREG	win32_dirent.h	203;"	d
S_ISSOCK	win32_dirent.h	205;"	d
S_IWGRP	win32_dirent.h	164;"	d
S_IWOTH	win32_dirent.h	167;"	d
S_IWRITE	win32_dirent.h	141;"	d
S_IWUSR	win32_dirent.h	161;"	d
S_IXGRP	win32_dirent.h	165;"	d
S_IXOTH	win32_dirent.h	168;"	d
S_IXUSR	win32_dirent.h	162;"	d
S_LAST	glh_typedefs.h	/^            S_LAST$/;"	e	enum:glh::ChannelType::s
Sampler	gltexture.h	/^class Sampler{$/;"	c	namespace:glh
Sampler1D	math_tools.h	/^    Sampler1D():interpolation_technique_(InterpolationType::Linear), sample_count_(0){}$/;"	f	class:glh::Sampler1D
Sampler1D	math_tools.h	/^    Sampler1D(Sampler1D&& sampler){$/;"	f	class:glh::Sampler1D
Sampler1D	math_tools.h	/^    Sampler1D(int sample_count):sample_count_(sample_count), samples_(sample_count_),$/;"	f	class:glh::Sampler1D
Sampler1D	math_tools.h	/^template<class Value, class Interp = Lerp<double, Value>> class Sampler1D {$/;"	c	namespace:glh
Sampler2D	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
Scalar	glh_dynamic_graph.h	/^        enum t{Empty, Scalar, Vector2, Vector3, Vector4};$/;"	e	enum:glh::DynamicGraph::Value::t
Scalar	glh_timebased_signals.h	/^        enum t{Scalar, Verson};}; \/\/ Either regular scalar or rotation encoded in verson (unit quaternion).$/;"	e	enum:glh::Animation::VarType::t
Scalar	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
ScalarOffset	glh_dynamic_graph.h	/^    ScalarOffset():DynamicGraph::DynamicNode("ScalarOffset"){$/;"	f	class:glh::ScalarOffset
ScalarOffset	glh_dynamic_graph.h	/^class ScalarOffset : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
ScalarRamp	glh_dynamic_graph.h	/^    ScalarRamp():lower_(0.0f), higher_(1.0f), easing_(Animation::Easing::Linear), DynamicGraph::DynamicNode("ScalarRamp"){$/;"	f	class:glh::ScalarRamp
ScalarRamp	glh_dynamic_graph.h	/^    ScalarRamp(float lower, float higher):lower_(lower), higher_(higher), easing_(Animation::Easing::Linear), DynamicGraph::DynamicNode("ScalarRamp"){$/;"	f	class:glh::ScalarRamp
ScalarRamp	glh_dynamic_graph.h	/^class ScalarRamp : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
SceneAssets	glh_scene_extensions.h	/^    SceneAssets(){}$/;"	f	class:glh::SceneAssets
SceneAssets	glh_scene_extensions.h	/^class SceneAssets{$/;"	c	namespace:glh
SceneTree	glh_scenemanagement.h	/^    SceneTree(){$/;"	f	class:glh::SceneTree
SceneTree	glh_scenemanagement.h	/^class SceneTree{$/;"	c	namespace:glh
SceneTreeNode	glh_typedefs.h	/^        SceneTreeNode  = 2004,$/;"	e	enum:glh::EntityType::t
ScopeError	masp.cpp	/^    ScopeError():result(OK){}$/;"	f	struct:masp::ScopeError
ScopeError	masp.cpp	/^    ScopeError(Result res,char c, int cn , int l):result(res), line(l), scope(c), char_on_line(cn){}$/;"	f	struct:masp::ScopeError
ScopeError	masp.cpp	/^struct ScopeError$/;"	s	namespace:masp	file:
ScrollLock	glbase.h	/^        ScrollLock = GLFW_KEY_SCROLL_LOCK,$/;"	e	enum:glh::Input::Key
SelectionWorld	glh_uicontext.h	/^    SelectionWorld(const std::string& name):name_(name){$/;"	f	struct:glh::SelectionWorld
SelectionWorld	glh_uicontext.h	/^struct SelectionWorld{$/;"	s	namespace:glh
Shader	glhack.cpp	/^    enum Compilable {Shader = 0, Program = 1};$/;"	e	enum:glh::__anon7::Compilable	file:
ShaderMappingTokens	glprogramvars.h	/^typedef BiMap<ShaderVar::Mapping, std::string> ShaderMappingTokens;$/;"	t	namespace:glh
ShaderProgram	glh_typedefs.h	/^        ShaderProgram = 4,$/;"	e	enum:glh::EntityType::t
ShaderProgram	glhack.cpp	/^    ShaderProgram(GraphicsManagerInt* manager, cstring& program_name):manager_(manager), name_(program_name), program_handle(0),$/;"	f	class:glh::ShaderProgram
ShaderProgram	glhack.cpp	/^class ShaderProgram : public ProgramHandle{$/;"	c	namespace:glh	file:
ShaderProgramPtr	glhack.cpp	/^typedef std::shared_ptr<ShaderProgram> ShaderProgramPtr;$/;"	t	namespace:glh	file:
ShaderTypeTokens	glprogramvars.h	/^typedef BiMap<ShaderVar::Type, std::string> ShaderTypeTokens;$/;"	t	namespace:glh
ShaderVar	glh_typedefs.h	/^        ShaderVar     = 3,$/;"	e	enum:glh::EntityType::t
ShaderVar	glprogramvars.h	/^    ShaderVar(Mapping m, Type t, cstring& varname):mapping(m), type(t), name(varname), program_location(0){}$/;"	f	class:glh::ShaderVar
ShaderVar	glprogramvars.h	/^class ShaderVar {$/;"	c	namespace:glh
ShaderVarList	glhack.h	/^typedef std::list<ShaderVar> ShaderVarList;$/;"	t	namespace:glh
ShaderVarList	glprogramvars.h	/^typedef std::list<ShaderVar> ShaderVarList;$/;"	t	namespace:glh
Signature	glh_timebased_signals.h	/^    struct Signature{VarType type; ChannelName name;};$/;"	s	class:glh::Animation
SimplexNoise	glh_generators.cpp	/^struct SimplexNoise$/;"	s	namespace:glh	file:
Smoothstep	glh_timebased_signals.h	/^        enum t{Linear, Smoothstep};$/;"	e	enum:glh::Animation::Easing::t
Smoothstep	math_tools.h	/^template<class I, class G> class Smoothstep { public: $/;"	c	namespace:glh
SortedArray	shims_and_types.h	/^    SortedArray(InputIterator first, InputIterator last, const Compare& c = Compare()):data_(first, last), cmp_(c)$/;"	f	struct:glh::SortedArray
SortedArray	shims_and_types.h	/^    SortedArray(const Compare& c = Compare()):data_(), cmp_(c){}$/;"	f	struct:glh::SortedArray
SortedArray	shims_and_types.h	/^struct SortedArray$/;"	s	namespace:glh
Space	glbase.h	/^        Space = GLFW_KEY_SPACE,      $/;"	e	enum:glh::Input::Key
Special	glbase.h	/^        Special = GLFW_KEY_SPECIAL,    $/;"	e	enum:glh::Input::Key
StreamIn	glprogramvars.h	/^    enum Mapping{Uniform, StreamIn, StreamOut, MAPPING_LAST};$/;"	e	enum:glh::ShaderVar::Mapping
StreamOut	glprogramvars.h	/^    enum Mapping{Uniform, StreamIn, StreamOut, MAPPING_LAST};$/;"	e	enum:glh::ShaderVar::Mapping
StringNumerator	shims_and_types.h	/^    StringNumerator(){}$/;"	f	class:glh::StringNumerator
StringNumerator	shims_and_types.h	/^class StringNumerator{$/;"	c	namespace:glh
SuperFastHash	math_tools.cpp	/^uint32_t SuperFastHash (const char* data, int len) {$/;"	f	namespace:__anon19
SystemInput	glh_dynamic_graph.h	/^    SystemInput(App* app):app_(app), previous_time_(-1.0),DynamicGraph::DynamicNode("SystemInput"){$/;"	f	class:glh::SystemInput
SystemInput	glh_dynamic_graph.h	/^class SystemInput : public DynamicGraph::DynamicNode{$/;"	c	namespace:glh
TINYMT32_H	tinymt32.h	2;"	d
TINYMT32_MASK	tinymt32.h	26;"	d
TINYMT32_MEXP	tinymt32.h	22;"	d
TINYMT32_MUL	tinymt32.h	27;"	d
TINYMT32_SH0	tinymt32.h	23;"	d
TINYMT32_SH1	tinymt32.h	24;"	d
TINYMT32_SH8	tinymt32.h	25;"	d
TINYMT32_T	tinymt32.h	/^struct TINYMT32_T {$/;"	s
TINYMT64_H	tinymt64.h	2;"	d
TINYMT64_MASK	tinymt64.h	26;"	d
TINYMT64_MEXP	tinymt64.h	22;"	d
TINYMT64_MUL	tinymt64.h	27;"	d
TINYMT64_SH0	tinymt64.h	23;"	d
TINYMT64_SH1	tinymt64.h	24;"	d
TINYMT64_SH8	tinymt64.h	25;"	d
TINYMT64_T	tinymt64.h	/^struct TINYMT64_T {$/;"	s
TINYTHREAD_VERSION	tinythread.h	94;"	d
TINYTHREAD_VERSION_MAJOR	tinythread.h	90;"	d
TINYTHREAD_VERSION_MINOR	tinythread.h	92;"	d
TO_TYPE	masp_classwrap.h	/^TO_TYPE(IObject*){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	/^TO_TYPE(Number){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	/^TO_TYPE(bool){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	/^TO_TYPE(const char*){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	/^TO_TYPE(double){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	/^TO_TYPE(int){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	/^TO_TYPE(std::string){$/;"	f	namespace:masp
TO_TYPE	masp_classwrap.h	127;"	d
TO_TYPE	masp_classwrap.h	88;"	d
TYPE_LAST	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
T_LAST	glh_typedefs.h	/^    enum t{Value,Index, T_LAST};$/;"	e	enum:glh::ChannelType::t
Tab	glbase.h	/^        Tab = GLFW_KEY_TAB,        $/;"	e	enum:glh::Input::Key
Target	gltexture.h	/^    enum Target{Texture2D,$/;"	g	class:glh::TextureType
Technique	glh_uicontext.h	/^    struct Technique{$/;"	s	class:glh::UiContext
TextField	glh_scene_extensions.h	/^class TextField {$/;"	c	namespace:glh
TextField	glh_typedefs.h	/^        TextField      = 2003,$/;"	e	enum:glh::EntityType::t
TextLine	shims_and_types.h	/^    TextLine():line_number(0){}$/;"	f	struct:glh::TextLine
TextLine	shims_and_types.h	/^    TextLine(const char* bfr, int lineno):string(bfr), line_number(lineno){}$/;"	f	struct:glh::TextLine
TextLine	shims_and_types.h	/^    TextLine(const std::string& str, int lineno):string(str), line_number(lineno){}$/;"	f	struct:glh::TextLine
TextLine	shims_and_types.h	/^struct TextLine$/;"	s	namespace:glh
TextLinePtr	glh_scene_extensions.h	/^    typedef std::shared_ptr<TextLine> TextLinePtr;$/;"	t	class:glh::TextField
Texture	glh_typedefs.h	/^            Texture  = 3,$/;"	e	enum:glh::ChannelType::s
Texture	glh_typedefs.h	/^        Texture       = 8,$/;"	e	enum:glh::EntityType::t
Texture	gltexture.cpp	/^Texture::Texture():on_gpu_(false), bound_texture_object_(0),image_(0), dirty_(true){$/;"	f	class:glh::Texture
Texture	gltexture.h	/^class Texture {$/;"	c	namespace:glh
Texture2D	gltexture.h	/^    enum Target{Texture2D,$/;"	e	enum:glh::TextureType::Target
TexturePtr	gltexture.h	/^typedef std::shared_ptr<Texture> TexturePtr;$/;"	t	namespace:glh
TextureType	gltexture.h	/^class TextureType {$/;"	c	namespace:glh
TextureUnitData	gltexture.h	/^struct TextureUnitData{const uint8_t* bound_image; Texture* bound_texture; size_t stored_size;};$/;"	s	namespace:glh
Transform	glh_scenemanagement.h	/^typedef ExplicitTransform<float> Transform;$/;"	t	namespace:glh
Triangle	geometry.h	/^    Triangle(const point3& a, const point3& b, const point3& c): p0(a), p1(b), p2(c) {}$/;"	f	struct:glh::Triangle
Triangle	geometry.h	/^struct Triangle{$/;"	s	namespace:glh
Type	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	g	class:glh::ShaderVar
Type	masp.h	/^    enum Type{INT, FLOAT};$/;"	g	struct:masp::Number
Type	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	g	namespace:masp
TypeId	glh_typedefs.h	/^class TypeId{$/;"	c	namespace:glh
UICTX_SELECT_NAME	glh_names.h	13;"	d
UiContext	glh_uicontext.h	/^    UiContext(GraphicsManager& manager, glh::App& app, DynamicGraph& graph, SceneTree& scene):$/;"	f	class:glh::UiContext
UiContext	glh_uicontext.h	/^class UiContext{$/;"	c	namespace:glh
Uniform	glprogramvars.h	/^    enum Mapping{Uniform, StreamIn, StreamOut, MAPPING_LAST};$/;"	e	enum:glh::ShaderVar::Mapping
Unknown	glbase.h	/^        Unknown = GLFW_KEY_UNKNOWN,    $/;"	e	enum:glh::Input::Key
Unknown	glh_typedefs.h	/^        Unknown       = 0,$/;"	e	enum:glh::EntityType::t
UnsignedByte	gltexture.h	/^    enum Pixel{UnsignedByte, Float};$/;"	e	enum:glh::TextureType::Pixel
UnstructuredMesh	geometry.h	/^class UnstructuredMesh$/;"	c	namespace:glh
UnstructuredMeshImp	geometry.cpp	/^class UnstructuredMeshImp : public UnstructuredMesh$/;"	c	namespace:glh	file:
Unsupported	iotools.h	/^    enum t{File, Directory, Unsupported};$/;"	e	enum:FilesystemReference::t
Up	glbase.h	/^        Up = GLFW_KEY_UP,         $/;"	e	enum:glh::Input::Key
Up	glh_scene_extensions.h	/^enum class Movement{ Up, Down, Left, Right, LeftBound, RightBound, None };$/;"	m	class:glh::Movement
UserInput	glbase.h	/^class UserInput$/;"	c	namespace:glh
VECTOR	masp.h	/^enum Type{NIL, BOOLEAN, NUMBER, NUMBER_ARRAY, STRING, SYMBOL, VECTOR, LIST, MAP, OBJECT, FUNCTION};$/;"	e	enum:masp::Type
VRefIterator	masp.h	/^typedef List::iterator VRefIterator;$/;"	t	namespace:masp
Value	glh_dynamic_graph.h	/^        Value():type_(Empty){}$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^        Value(float x, float y):type_(Vector2), value_(x, y, 0.f, 0.f){}$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^        Value(float x, float y, float z):type_(Vector3), value_(x, y, z, 0.f){}$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^        Value(t type):type_(type){}$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^        Value(t type, const array4& value):type_(type), value_(value){}$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^        Value(t type, const vec4& value):type_(type), value_(value){}$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^        Value(t type, float value):type_(type){$/;"	f	struct:glh::DynamicGraph::Value
Value	glh_dynamic_graph.h	/^    struct Value{$/;"	s	class:glh::DynamicGraph
Value	glh_typedefs.h	/^    enum t{Value,Index, T_LAST};$/;"	e	enum:glh::ChannelType::t
Value	masp.cpp	/^Value::Value():type(NIL){}$/;"	f	class:masp::Value
Value	masp.cpp	/^Value::Value(Value&& v)$/;"	f	class:masp::Value
Value	masp.cpp	/^Value::Value(const Value& v)$/;"	f	class:masp::Value
Value	masp.h	/^class Value$/;"	c	namespace:masp
ValueDeleter	masp.h	/^class ValueDeleter{$/;"	c	namespace:masp
ValueHash	masp.h	/^class ValueHash { public:$/;"	c	namespace:masp
ValueInserter	shims_and_types.h	/^        ValueInserter(BiMap& parent, const Key& k):parent_(parent), k_(k){}$/;"	f	struct:glh::BiMap::ValueInserter
ValueInserter	shims_and_types.h	/^    struct ValueInserter$/;"	s	class:glh::BiMap
ValueNode	persistent_containers.h	/^        enum NodeType{EmptyNode, ValueNode, CollisionNode};$/;"	e	enum:glh::PMapPool::Node::NodeType
ValueParser	masp.cpp	/^    ValueParser(Masp& masp):masp_(masp)$/;"	f	class:masp::ValueParser
ValueParser	masp.cpp	/^class ValueParser$/;"	c	namespace:masp	file:
ValuePtr	masp.h	/^typedef std::shared_ptr<Value> ValuePtr;$/;"	t	namespace:masp
ValuesAreEqual	masp.h	/^class ValuesAreEqual { public:$/;"	c	namespace:masp
VarType	glh_timebased_signals.h	/^    struct VarType{$/;"	s	class:glh::Animation
Vec2	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
Vec3	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
Vec4	glh_typedefs.h	/^        Vec4          = 1008,$/;"	e	enum:glh::EntityType::t
Vec4	glprogramvars.h	/^    enum Type{Scalar, Vec2, Vec3, Vec4, Mat4, Sampler2D, TYPE_LAST};$/;"	e	enum:glh::ShaderVar::Type
VecIterator	masp.h	/^typedef Vector::iterator VecIterator;$/;"	t	namespace:masp
Vector	masp.h	/^    typedef std::deque<Value> Vector;$/;"	t	class:masp::Value
Vector	masp.h	/^typedef Value::Vector Vector;$/;"	t	namespace:masp
Vector2	glh_dynamic_graph.h	/^        enum t{Empty, Scalar, Vector2, Vector3, Vector4};$/;"	e	enum:glh::DynamicGraph::Value::t
Vector3	glh_dynamic_graph.h	/^        enum t{Empty, Scalar, Vector2, Vector3, Vector4};$/;"	e	enum:glh::DynamicGraph::Value::t
Vector4	glh_dynamic_graph.h	/^        enum t{Empty, Scalar, Vector2, Vector3, Vector4};$/;"	e	enum:glh::DynamicGraph::Value::t
Verson	glh_timebased_signals.h	/^        enum t{Scalar, Verson};}; \/\/ Either regular scalar or rotation encoded in verson (unit quaternion).$/;"	e	enum:glh::Animation::VarType::t
VertexChunk	glbuffers.h	/^    VertexChunk(){}$/;"	f	class:glh::VertexChunk
VertexChunk	glbuffers.h	/^    VertexChunk(VertexChunk&& vc):sig_(vc.sig_), data_(std::move(vc.data_)){}$/;"	f	class:glh::VertexChunk
VertexChunk	glbuffers.h	/^    VertexChunk(const BufferSignature& t):sig_(t){}$/;"	f	class:glh::VertexChunk
VertexChunk	glbuffers.h	/^    VertexChunk(const VertexChunk& vc):sig_(vc.sig_), data_(vc.data_){}$/;"	f	class:glh::VertexChunk
VertexChunk	glbuffers.h	/^class VertexChunk {$/;"	c	namespace:glh
VertexChunk	glh_typedefs.h	/^        VertexChunk   = 2,$/;"	e	enum:glh::EntityType::t
WDIR	win32_dirent.h	248;"	d
WIN32_LEAN_AND_MEAN	fast_mutex.h	51;"	d
WIN32_LEAN_AND_MEAN	fast_mutex.h	56;"	d
WIN32_LEAN_AND_MEAN	tinythread.h	71;"	d
WIN32_LEAN_AND_MEAN	tinythread.h	76;"	d
WrappedObject	masp_classwrap.h	/^    WrappedObject(){}$/;"	f	class:masp::WrappedObject
WrappedObject	masp_classwrap.h	/^    WrappedObject(C0&& c0):t_(new T(std::forward<C0>(c0))){}$/;"	f	class:masp::WrappedObject
WrappedObject	masp_classwrap.h	/^    WrappedObject(C0&& c0, C1&& c1):t_(new T(std::forward<C0>(c0), std::forward<C1>(c1))){}$/;"	f	class:masp::WrappedObject
WrappedObject	masp_classwrap.h	/^    WrappedObject(T* ptr):t_(ptr){}$/;"	f	class:masp::WrappedObject
WrappedObject	masp_classwrap.h	/^    WrappedObject(std::shared_ptr<T> t):t_(t){}$/;"	f	class:masp::WrappedObject
WrappedObject	masp_classwrap.h	/^class WrappedObject : public IObject { public:$/;"	c	namespace:masp
X	math_tools.h	/^    enum coord_t{X = 0, Y = 1, Z = 2};$/;"	e	enum:Dim::coord_t
Y	math_tools.h	/^    enum coord_t{X = 0, Y = 1, Z = 2};$/;"	e	enum:Dim::coord_t
YCbCr_to_RGB_row	stb_image.c	/^static void YCbCr_to_RGB_row(uint8 *out, const uint8 *y, const uint8 *pcb, const uint8 *pcr, int count, int step)$/;"	f	file:
Z	math_tools.h	/^    enum coord_t{X = 0, Y = 1, Z = 2};$/;"	e	enum:Dim::coord_t
ZFAST_BITS	stb_image.c	1952;"	d	file:
ZFAST_MASK	stb_image.c	1953;"	d	file:
_CONDITION_EVENT_ALL	tinythread.cpp	53;"	d	file:
_CONDITION_EVENT_ONE	tinythread.cpp	52;"	d	file:
_CRT_SECURE_NO_WARNINGS	stb_image.c	190;"	d	file:
_DIRENT_HAVE_D_NAMLEN	win32_dirent.h	114;"	d
_DIRENT_HAVE_D_TYPE	win32_dirent.h	111;"	d
_D_ALLOC_NAMLEN	win32_dirent.h	213;"	d
_D_EXACT_NAMLEN	win32_dirent.h	210;"	d
_FAST_MUTEX_ASM_	fast_mutex.h	44;"	d
_FAST_MUTEX_H_	fast_mutex.h	25;"	d
_FAST_MUTEX_SYS_	fast_mutex.h	46;"	d
_TINYTHREAD_H_	tinythread.h	25;"	d
_TTHREAD_CPP11_	tinythread.h	98;"	d
_TTHREAD_CPP11_PARTIAL_	tinythread.h	103;"	d
_TTHREAD_DISABLE_ASSIGNMENT	tinythread.h	108;"	d
_TTHREAD_DISABLE_ASSIGNMENT	tinythread.h	112;"	d
_TTHREAD_DISABLE_ASSIGNMENT	tinythread.h	712;"	d
_TTHREAD_PLATFORM_DEFINED_	fast_mutex.h	36;"	d
_TTHREAD_PLATFORM_DEFINED_	tinythread.h	65;"	d
_TTHREAD_POSIX_	fast_mutex.h	34;"	d
_TTHREAD_POSIX_	tinythread.h	63;"	d
_TTHREAD_WIN32_	fast_mutex.h	32;"	d
_TTHREAD_WIN32_	tinythread.h	61;"	d
_USE_MATH_DEFINES	math_tools.h	13;"	d
_WDIR	win32_dirent.h	/^struct _WDIR {$/;"	s
_WDIR	win32_dirent.h	/^typedef struct _WDIR _WDIR;$/;"	t	typeref:struct:_WDIR
_X86_	win32_dirent.h	96;"	d
__STB_INCLUDE_STB_TRUETYPE_H__	stb_truetype.h	398;"	d
__UNDEF_LEAN_AND_MEAN	fast_mutex.h	52;"	d
__UNDEF_LEAN_AND_MEAN	fast_mutex.h	57;"	d
__UNDEF_LEAN_AND_MEAN	tinythread.h	72;"	d
__UNDEF_LEAN_AND_MEAN	tinythread.h	77;"	d
__intmax_t	tinythread.h	/^typedef long long __intmax_t;$/;"	t	namespace:tthread
_as_double	tinythread.h	/^    static double _as_double() { return double(N) \/ double(D); }$/;"	f	class:tthread::ratio
_pthread_t_to_ID	tinythread.cpp	/^static thread::id _pthread_t_to_ID(const pthread_t &aHandle)$/;"	f	namespace:tthread
_thread_start_info	tinythread.cpp	/^struct _thread_start_info {$/;"	s	namespace:tthread	file:
_wait	tinythread.cpp	/^void condition_variable::_wait()$/;"	f	class:tthread::condition_variable
_wclosedir	win32_dirent.h	/^_wclosedir($/;"	f
_wdirent	win32_dirent.h	/^struct _wdirent {$/;"	s
_wdirent	win32_dirent.h	/^typedef struct _wdirent _wdirent;$/;"	t	typeref:struct:_wdirent
_wopendir	win32_dirent.h	/^_wopendir($/;"	f
_wreaddir	win32_dirent.h	/^_wreaddir($/;"	f
_wrewinddir	win32_dirent.h	/^_wrewinddir($/;"	f
a	math_tools.h	/^    float a;$/;"	m	struct:glh::Color
a_	geometry.h	/^    double a_,b_,c_,d_; \/\/> ax + by + cz + d = 0$/;"	m	struct:glh::Plane
a_	glhack.h	/^        GLboolean r_;GLboolean g_; GLboolean b_; GLboolean a_;$/;"	m	struct:glh::RenderPassSettings::ColorMask
aabb_scale_	glh_scenemanagement.h	/^    float aabb_scale_; \/\/ Orthographic projection scale $/;"	m	class:glh::Camera
accum_number_hash	masp.cpp	/^uint32_t accum_number_hash(const uint32_t& p, const Number& n){return p * hash_of_number(n);}$/;"	f	namespace:masp
accum_value_hash	masp.cpp	/^uint32_t accum_value_hash(const uint32_t& p, const Value& v){return p * v.get_hash();}$/;"	f	namespace:masp
activate_texture_unit	glhack.cpp	/^static void activate_texture_unit(int texture_unit){$/;"	f	namespace:glh
active_filter_	glh_scenemanagement.h	/^    RenderQueue::node_filter_fun_t active_filter_;$/;"	m	class:glh::RenderPass
add	glh_dynamic_graph.h	/^    void add(glh::DynamicGraph& graph){$/;"	f	struct:glh::DynamicNodeRef
add	glh_scenemanagement.h	/^    void add(SceneTree& scene){$/;"	f	class:glh::RenderQueue
add	glh_scenemanagement.h	/^    void add(SceneTree& scene, node_filter_fun_t filter){$/;"	f	class:glh::RenderQueue
add	glh_scenemanagement.h	/^    void add(SceneTree::Node* node){$/;"	f	class:glh::RenderQueue
add	glh_timebased_signals.h	/^    void add(T id, const std::function<bool (float)>& event){$/;"	f	class:glh::DynamicSystem
add	glh_timebased_signals.h	/^    void add(obj_id id, const std::function<bool (float)>& event){events_[id] = Event(event);}$/;"	f	class:glh::DynamicSystem
add	masp_classwrap.h	/^    void add(const char* name, PrimitiveFunction fun){$/;"	f	class:masp::FunMap
add	persistent_containers.h	/^        List add(const T& data) const$/;"	f	class:glh::PListPool::List
add	persistent_containers.h	/^        Map add(const K& key, const V& value)$/;"	f	class:glh::PMapPool::Map
add	persistent_containers.h	/^        Map add(const KI i_key, const KI key_end, const VI i_value, const VI value_end) const$/;"	f	class:glh::PMapPool::Map
add	persistent_containers.h	/^    List add(const List& old, I i_begin, I i_end)$/;"	f	class:glh::PListPool
add	persistent_containers.h	/^    Map add(const Map& old, KI i_key, KI key_end, VI i_value, VI value_end)$/;"	f	class:glh::PMapPool
add	persistent_containers.h	/^    Map add(const Map& old, KVI i_elems, KVI elems_end)$/;"	f	class:glh::PMapPool
add	persistent_containers.h	/^    Map add(const Map& old, const K& key, const V& value)$/;"	f	class:glh::PMapPool
add	persistent_containers.h	/^    Map add(const Map& old, const KeyValue* keyvalue)$/;"	f	class:glh::PMapPool
add	shims_and_types.h	/^Inserter1<C> add(C& c, const V& v)$/;"	f	namespace:glh
add	shims_and_types.h	/^Inserter1<SortedArray<T>> add(SortedArray<T>& c, const T& p)$/;"	f	namespace:glh
add	shims_and_types.h	/^Inserter1<std::list<T>> add(std::list<T>& c, const T& p)$/;"	f	namespace:glh
add	shims_and_types.h	/^Inserter2<Map> add(Map& map, const typename Map::key_type& k, const typename Map::mapped_type& v)$/;"	f	namespace:glh
add_child	glh_scenemanagement.h	/^        void add_child(Node* node){$/;"	f	class:glh::SceneTree::Node
add_data	shims_and_types.h	/^    void add_data(size_t count)$/;"	f	class:glh::AlignedArray
add_edge	glh_dynamic_graph.h	/^    void add_edge(const V& from, const V& to){$/;"	f	class:glh::AdjacencyListGraph
add_elem	persistent_containers.h	/^    Node* add_elem(I i_begin, I i_end) $/;"	f	class:glh::PListPool
add_end	persistent_containers.h	/^        List add_end(I ibegin, I iend)$/;"	f	class:glh::PListPool::List
add_input	glh_dynamic_graph.h	/^        void add_input(const std::string& varname, Value::t type){$/;"	f	struct:glh::DynamicGraph::DynamicNode
add_input	glh_dynamic_graph.h	/^        void add_input(const std::string& varname, Value::t type, const V& val){$/;"	f	struct:glh::DynamicGraph::DynamicNode
add_input	glh_dynamic_graph.h	/^        void add_input(const std::string& varname, const float val){$/;"	f	struct:glh::DynamicGraph::DynamicNode
add_key_callback	glbase.cpp	/^void add_key_callback(App& app, const UserInput::KeyCallback& cb){$/;"	f	namespace:glh
add_link	glh_dynamic_graph.h	/^        void add_link(const std::string& sinkname, const node_id_t& linked_node, const var_id_t& source_var){$/;"	f	struct:glh::DynamicGraph::DynamicNode
add_link	glh_dynamic_graph.h	/^    bool add_link(const node_id_t& sourcename, const var_id_t& sourcevar,$/;"	f	class:glh::DynamicGraph
add_mouse_button_callback	glbase.cpp	/^void add_mouse_button_callback(App& app, const UserInput::KeyCallback& cb){$/;"	f	namespace:glh
add_mouse_move_callback	glbase.cpp	/^void add_mouse_move_callback(App& app, const UserInput::MouseMoveCallback& cb){$/;"	f	namespace:glh
add_mouse_wheel_callback	glbase.cpp	/^void add_mouse_wheel_callback(App& app, const UserInput::MouseWheelCallback& cb){$/;"	f	namespace:glh
add_node	glh_dynamic_graph.h	/^    bool add_node(const std::string& name, const dynamic_node_ptr_t& nodeptr){$/;"	f	class:glh::DynamicGraph
add_node	glh_scenemanagement.h	/^    Node* add_node(Node* parent){$/;"	f	class:glh::SceneTree
add_node	glh_scenemanagement.h	/^    Node* add_node(Node* parent, FullRenderable* r){$/;"	f	class:glh::SceneTree
add_node	glh_scenemanagement.h	/^    void add_node(SceneTree::Node* node){$/;"	f	class:glh::RenderPicker
add_quad_to_scene	glh_scene_util.cpp	/^SceneTree::Node* add_quad_to_scene(GraphicsManager* gm, SceneTree& scene, ProgramHandle& program, vec2 dims, SceneTree::Node* parent){$/;"	f	namespace:glh
add_range	shims_and_types.h	/^void add_range(Container& c, Iter start, Iter end)$/;"	f	namespace:glh
add_rec	glh_scenemanagement.h	/^    void add_rec(SceneTree::Node* noderoot){$/;"	f	class:glh::RenderQueue
add_rec	glh_scenemanagement.h	/^    void add_rec(SceneTree::Node* noderoot, node_filter_fun_t filter){$/;"	f	class:glh::RenderQueue
add_ref	persistent_containers.h	/^    void add_ref(Node* n)$/;"	f	class:glh::PListPool
add_ref	persistent_containers.h	/^    void add_ref(Node* n)$/;"	f	class:glh::PMapPool
add_selection_world	glh_uicontext.h	/^    SelectionWorld* add_selection_world(const std::string& name, Camera* pass_camera){$/;"	f	class:glh::UiContext
add_settings	glh_scenemanagement.h	/^    void add_settings(const RenderPassSettings& settings){$/;"	f	class:glh::RenderPass
add_technique	glh_uicontext.h	/^    void add_technique(Technique::t technique, SceneTree::Node* node){$/;"	f	class:glh::UiContext
add_to_each_dim	math_tools.h	/^    void add_to_each_dim(const ExplicitTransform& e){$/;"	f	struct:glh::ExplicitTransform
add_var	glh_dynamic_graph.h	/^    void add_var(const std::string& name){$/;"	f	class:glh::NodeReciever
add_vertex_nocheck	glh_dynamic_graph.h	/^    vertex_id add_vertex_nocheck(const V& v){$/;"	f	class:glh::AdjacencyListGraph
advance	persistent_containers.h	/^        void advance()$/;"	f	class:glh::PMapPool::node_iterator
aligned_alloc	allocators.cpp	/^unsigned char* aligned_alloc(size_t size)$/;"	f
aligned_free	allocators.cpp	/^void aligned_free(void* p)$/;"	f
all_are_float	masp.cpp	/^bool all_are_float(NumberArray& arr)$/;"	f	namespace:masp
all_are_int	masp.cpp	/^bool all_are_int(NumberArray& arr)$/;"	f	namespace:masp
all_are_of_type	masp.cpp	/^bool all_are_of_type(VI begin, VI end, Type t, size_t* out_size)$/;"	f	namespace:masp
all_pairs	math_tools.h	/^std::list<std::pair<typename V::value_type, typename V::value_type>> all_pairs(V& seq)$/;"	f	namespace:glh
alloc	shims_and_types.h	/^    void alloc(const T& t, size_t level)$/;"	f	class:glh::FixedStack
alloc_float_array	glh_image.cpp	/^    float*  alloc_float_array(int size){return new float[size];}$/;"	f	namespace:glh::__anon5
alloc_str	masp.cpp	/^void Value::alloc_str(const char* str)$/;"	f	class:masp::Value
alloc_str	masp.cpp	/^void Value::alloc_str(const char* str, const char* str_end)$/;"	f	class:masp::Value
alloc_str	masp.cpp	/^void Value::alloc_str(const std::string& str)$/;"	f	class:masp::Value
alloc_uint8t_array	glh_image.cpp	/^    uint8_t*  alloc_uint8t_array(int size){return new uint8_t[size];}$/;"	f	namespace:glh::__anon4
allocate_texture_units	glhack.cpp	/^    void allocate_texture_units(){$/;"	f	class:glh::ShaderProgram
any_button	glbase.h	/^    static AnyButton    any_button(ButtonSource src, int val){return std::make_pair(src, val);}$/;"	f	class:glh::Input
any_get_button	glbase.h	/^    static int          any_get_button(const AnyButton& b){return b.second;}$/;"	f	class:glh::Input
any_get_source	glbase.h	/^    static ButtonSource any_get_source(const AnyButton& b){return b.first;}$/;"	f	class:glh::Input
any_of	shims_and_types.h	/^bool any_of(const T& val, const T& ref0, const T& ref1){return val == ref0 || val == ref1;}$/;"	f	namespace:glh
any_of	shims_and_types.h	/^bool any_of(const T& val, const T& ref0, const T& ref1, const T& ref2){return val == ref0 || val == ref1 || val == ref2;}$/;"	f	namespace:glh
any_of	shims_and_types.h	/^bool any_of(const T& val, const T& ref0, const T& ref1, const T& ref2, const T& ref3){return val == ref0 || val == ref1 || val == ref2 || val == ref3;}$/;"	f	namespace:glh
any_of	shims_and_types.h	/^bool any_of(const T& val, const V& ref0, const V& ref1){ return val == ref0 || val == ref1; }$/;"	f	namespace:glh
app_	glh_app_services.h	/^    App*            app_;$/;"	m	class:glh::AppServices
app_	glh_dynamic_graph.h	/^    App* app_;$/;"	m	class:glh::SystemInput
app_	glh_scene_extensions.h	/^    App*             app_;$/;"	m	class:glh::SceneAssets
app_	glh_scenemanagement.h	/^    App& app_;$/;"	m	class:glh::RenderPicker
app_	glh_uicontext.h	/^    App&             app_;$/;"	m	class:glh::UiContext
app_config_default	glbase.cpp	/^AppConfig app_config_default(AppInit init, AppUpdate update, AppRender render, AppResize resize)$/;"	f	namespace:glh
app_orthographic_pixel_projection	glbase.cpp	/^mat4 app_orthographic_pixel_projection(const App* app){$/;"	f	namespace:glh
append	glhack.h	/^    void append(const RenderEnvironment& r){$/;"	f	class:glh::RenderEnvironment
append	shims_and_types.h	/^    T& append()$/;"	f	class:glh::AlignedArray
append	shims_and_types.h	/^T append(const T& first_container, const T& second_container)$/;"	f	namespace:glh
append_material	glh_scenemanagement.cpp	/^void append_material(SceneTree::Node& node, RenderEnvironment& material){$/;"	f	namespace:glh
append_to_value_stl_list	masp.cpp	/^void append_to_value_stl_list(std::list<Value>& ext_value_list, const Value& v)$/;"	f	namespace:masp
apply	glhack.cpp	/^void apply(const RenderPassSettings& pass)$/;"	f	namespace:glh
apply	glhack.h	/^        void apply() const {$/;"	f	struct:glh::RenderPassSettings::BlendSettings
apply	glhack.h	/^        void apply() const {glColorMask(r_,g_,b_,a_);}$/;"	f	struct:glh::RenderPassSettings::ColorMask
apply	glhack.h	/^        void apply() const {glDepthMask(flag_);}$/;"	f	struct:glh::RenderPassSettings::DepthMask
apply	masp.cpp	/^Value apply(const Value& v, VRefIterator args_begin, VRefIterator args_end, Map& env, Masp& masp)$/;"	f	namespace:masp::__anon15
apply_partial_tail	shims_and_types.h	/^void apply_partial_tail(T& container, size_t index, F fun){$/;"	f	namespace:glh
apply_to_render_env	glh_scenemanagement.h	/^    void apply_to_render_env(){$/;"	f	class:glh::SceneTree
are_near	math_tools.h	/^inline bool are_near(const float first, const float second, const float epsilon = 0.001f){$/;"	f	namespace:glh
array4	math_tools.h	/^typedef ArrayN<float, 4> array4;$/;"	t	namespace:glh
as_value	annotated_result.h	/^    T* as_value(){return reinterpret_cast<T*>(value_);}$/;"	f	class:glh::AnnotatedResult
asset_path	asset_manager.cpp	/^    std::string asset_path;$/;"	m	class:glh::DefaultAssetManager	file:
assets	glh_app_services.h	/^    SceneAssets&  assets(){ return *assets_; }$/;"	f	class:glh::AppServices
assets_	glh_app_services.h	/^    std::shared_ptr<SceneAssets>    assets_;$/;"	m	class:glh::AppServices
assign	glbuffers.h	/^    void assign(const std::string& name, VertexChunk& chunk){$/;"	f	class:glh::BufferSet
assign	glhack.cpp	/^void assign(const GLuint program, const char* name, const mat4& mat){$/;"	f	namespace:glh::__anon6
assign	glhack.cpp	/^void assign(const GLuint program, const char* name, const vec3& vec){$/;"	f	namespace:glh::__anon6
assign	glhack.cpp	/^void assign(const GLuint program, const char* name, const vec4& vec){$/;"	f	namespace:glh::__anon6
assign	shims_and_types.h	/^    void assign(T* start_ptr, T* end_ptr)$/;"	f	class:glh::AlignedArray
assign_by_guessing_names	glhack.cpp	/^void assign_by_guessing_names(BufferSet& bufs, DefaultMesh& mesh)$/;"	f	namespace:glh
assign_sampler_uniform	glhack.cpp	/^void assign_sampler_uniform(const GLuint program, const char* name, int texture_unit){$/;"	f	namespace:glh::__anon6
assign_uniform_locations	glhack.cpp	/^    void assign_uniform_locations()$/;"	f	class:glh::ShaderProgram
assignment_value	masp.cpp	/^const Value* assignment_value(const Value& v){return value_list_third(v);}$/;"	f	namespace:masp::__anon15
assignment_var	masp.cpp	/^const Value* assignment_var(const Value& v){return value_list_second(v);}$/;"	f	namespace:masp::__anon15
at	glh_font.h	/^    row_coords_t& at(int i){ return coords_.at(i); }$/;"	f	struct:glh::GlyphCoords
at	glh_image.h	/^    float* at(int x, int y){return data_ + y * stride_ + x * channels_;}$/;"	f	class:glh::Image32
at	glh_image.h	/^    uint8_t*       at(int x, int y){return data_ + y * stride_ + x * channels_;}$/;"	f	class:glh::Image8
at	glh_scene_extensions.h	/^    TextLine& at(int i){$/;"	f	class:glh::TextField
at	persistent_containers.h	/^    T* at(size_t index) $/;"	f	struct:glh::Chunk
at	shims_and_types.h	/^    T& at(size_t level){return ((T*) stack_)[level];}$/;"	f	class:glh::FixedStack
at_end	masp.cpp	/^    bool at_end(){return c_ >= end_;}$/;"	f	class:masp::ValueParser
at_eof	stb_image.c	/^stbi_inline static int at_eof(stbi *s)$/;"	f	file:
attach	glh_scene_extensions.h	/^    void attach(SceneTree* scene, SceneTree::Node* parent){$/;"	f	class:glh::GlyphPane
attach_image	gltexture.cpp	/^void Texture::attach_image(const Image8& image){$/;"	f	class:glh::Texture
attach_render_pass	glh_scenemanagement.h	/^    void attach_render_pass(RenderPass* pass){$/;"	f	class:glh::RenderPicker
average	math_tools.h	/^template<class T> inline T average(const T& fst, const T& snd){$/;"	f	namespace:glh
b	math_tools.h	/^    float b;$/;"	m	struct:glh::Color
b_	geometry.h	/^    double a_,b_,c_,d_; \/\/> ax + by + cz + d = 0$/;"	m	struct:glh::Plane
b_	glhack.h	/^        GLboolean r_;GLboolean g_; GLboolean b_; GLboolean a_;$/;"	m	struct:glh::RenderPassSettings::ColorMask
background_mesh_	glh_scene_extensions.h	/^    DefaultMesh*     background_mesh_;$/;"	m	class:glh::GlyphPane
background_mesh_node_	glh_scene_extensions.h	/^    SceneTree::Node* background_mesh_node_; \/\/> The background for highlights.$/;"	m	class:glh::GlyphPane
background_renderable_	glh_scene_extensions.h	/^    FullRenderable*  background_renderable_;$/;"	m	class:glh::GlyphPane
begin	glh_dynamic_graph.h	/^    iterator begin() const {return iterator(head_);}$/;"	f	struct:glh::List
begin	glh_font.h	/^    iterator begin(){ return iterator(*this); }$/;"	f	struct:glh::textured_quad2d_t
begin	glh_scenemanagement.h	/^        ChildContainer::iterator begin(){return children_.begin();}$/;"	f	class:glh::SceneTree::Node
begin	glh_scenemanagement.h	/^        node_ptr_container_t::iterator begin(){return picker_.picked_.begin();}$/;"	f	struct:glh::RenderPicker::PickedContext
begin	glh_scenemanagement.h	/^    iterator begin() {return tree_iterator(root_);}$/;"	f	class:glh::SceneTree
begin	glh_scenemanagement.h	/^    node_ptr_sequence_t::iterator begin(){$/;"	f	class:glh::RenderQueue
begin	math_tools.h	/^    iterator begin() const {return iterator(range_start_, increment_);}$/;"	f	class:glh::Range
begin	persistent_containers.h	/^        Ref* begin(){return child_array;}$/;"	f	struct:glh::PMapPool::Node
begin	persistent_containers.h	/^        iterator begin() const {return iterator(head_);}$/;"	f	class:glh::PListPool::List
begin	persistent_containers.h	/^        iterator begin() const {return iterator(root_);}$/;"	f	class:glh::PMapPool::Map
begin	persistent_containers.h	/^    T* begin(){return buffer;}$/;"	f	struct:glh::Chunk
begin	persistent_containers.h	/^    iterator begin(){return chunks_.begin();}$/;"	f	class:glh::ChunkBox
begin	shims_and_types.h	/^    const char* begin() const {return string.c_str();}$/;"	f	struct:glh::TextLine
begin	shims_and_types.h	/^    const_iterator begin() const { return data_;}$/;"	f	class:glh::AlignedArray
begin	shims_and_types.h	/^    const_iterator begin() const {return const_iterator(head_);}$/;"	f	class:glh::PooledList
begin	shims_and_types.h	/^    const_iterator begin() const {return data_.begin();}$/;"	f	struct:glh::SortedArray
begin	shims_and_types.h	/^    const_iterator begin() const {return keys_to_values_.begin();}$/;"	f	class:glh::BiMap
begin	shims_and_types.h	/^    iterator begin() { return data_;}$/;"	f	class:glh::AlignedArray
begin	shims_and_types.h	/^    iterator begin(){return data_.begin();}$/;"	f	class:glh::Pool
begin	shims_and_types.h	/^    iterator begin(){return data_.begin();}$/;"	f	struct:glh::SortedArray
begin	shims_and_types.h	/^    iterator begin(){return iterator(&queue_[0]);}$/;"	f	class:glh::ArenaQueue
begin	shims_and_types.h	/^    iterator begin(){return iterator(head_);}$/;"	f	class:glh::PooledList
begin	shims_and_types.h	/^    iterator begin(){return keys_to_values_.begin();}$/;"	f	class:glh::BiMap
begin_actions	masp.cpp	/^Value begin_actions(const Value& v)$/;"	f	namespace:masp::__anon15
begin_iter	glh_scenemanagement.cpp	/^SceneTree::iterator begin_iter(SceneTree::Node* node){return SceneTree::tree_iterator(node);}$/;"	f	namespace:glh
bgindex	stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
bind	glbuffers.h	/^    void bind(GLenum target){glBindBuffer(target, handle_);}$/;"	f	class:glh::BufferHandle
bind	gltexture.cpp	/^void Texture::bind(){$/;"	f	class:glh::Texture
bind	masp_classwrap.h	/^    void bind(T& value_seq) const {$/;"	f	class:masp::ArgWrap
bind_program	glhack.h	/^    void bind_program(ProgramHandle& program){$/;"	f	class:glh::FullRenderable
bind_program_input_locations	glhack.cpp	/^    void bind_program_input_locations(ShaderProgram& program)$/;"	f	namespace:glh::__anon7
bind_uniform	glhack.cpp	/^void ActiveProgram::bind_uniform(const std::string& name, Texture& tex){$/;"	f	class:glh::ActiveProgram
bind_uniform	glhack.cpp	/^void ActiveProgram::bind_uniform(const std::string& name, const mat4& mat){$/;"	f	class:glh::ActiveProgram
bind_uniform	glhack.cpp	/^void ActiveProgram::bind_uniform(const std::string& name, const vec3& vec){$/;"	f	class:glh::ActiveProgram
bind_uniform	glhack.cpp	/^void ActiveProgram::bind_uniform(const std::string& name, const vec4& vec){$/;"	f	class:glh::ActiveProgram
bind_vertex_input	glhack.cpp	/^    void bind_vertex_input(NamedBufferHandles& buffers)$/;"	f	class:glh::ShaderProgram
bind_vertex_input	glhack.cpp	/^void ActiveProgram::bind_vertex_input(NamedBufferHandles& buffers){$/;"	f	class:glh::ActiveProgram
bit_is_on	math_tools.h	/^inline bool bit_is_on(const uint32_t field, const uint32_t bit)$/;"	f	namespace:glh
bit_reverse	stb_image.c	/^stbi_inline static int bit_reverse(int v, int bits)$/;"	f	file:
bitcount	stb_image.c	/^static int bitcount(unsigned int a)$/;"	f	file:
bitmaps_	glh_font.h	/^    std::map<BakedFontHandle, Image8>        bitmaps_;$/;"	m	class:glh::FontContext
bitreverse16	stb_image.c	/^stbi_inline static int bitreverse16(int n)$/;"	f	file:
blend	glhack.h	/^    BlendSettings blend;  bool blend_set;$/;"	m	class:glh::RenderPassSettings
blend_active_	glhack.h	/^        bool blend_active_;$/;"	m	struct:glh::RenderPassSettings::BlendSettings
blend_set	glhack.h	/^    BlendSettings blend;  bool blend_set;$/;"	m	class:glh::RenderPassSettings
bmask	stb_image.c	/^static uint32 bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};$/;"	v	file:
bmp_load	stb_image.c	/^static stbi_uc *bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
bmp_test	stb_image.c	/^static int bmp_test(stbi *s)$/;"	f	file:
boolean	masp.h	/^        bool         boolean;$/;"	m	union:masp::Value::__anon18
bound_image	gltexture.h	/^struct TextureUnitData{const uint8_t* bound_image; Texture* bound_texture; size_t stored_size;};$/;"	m	struct:glh::TextureUnitData
bound_texture	gltexture.h	/^struct TextureUnitData{const uint8_t* bound_image; Texture* bound_texture; size_t stored_size;};$/;"	m	struct:glh::TextureUnitData
bound_texture_object_	gltexture.h	/^    GLuint bound_texture_object_;$/;"	m	class:glh::Texture
break_line	glh_scene_extensions.h	/^    TextLine& break_line(const int char_pos, const int row){$/;"	f	class:glh::TextField
brk	glh_uicontext.h	/^    static int brk()$/;"	f	class:glh::UiContext
buffer	persistent_containers.h	/^    typename std::aligned_storage <sizeof(T), std::alignment_of<T>::value>::type buffer[CHUNK_BUFFER_SIZE];$/;"	m	struct:glh::Chunk
buffer_start	stb_image.c	/^   uint8 buffer_start[128];$/;"	m	struct:__anon23	file:
bufferhandles_	glhack.cpp	/^    std::list<BufferHandlePtr>              bufferhandles_;$/;"	m	class:glh::GraphicsManagerInt	file:
buffers_	glbuffers.h	/^    NamedBufferHandles buffers_;$/;"	m	class:glh::BufferSet
buffertype_to_gltype	glhack.cpp	/^GLenum buffertype_to_gltype(TypeId::t t){$/;"	f	namespace:glh
buflen	stb_image.c	/^   int buflen;$/;"	m	struct:__anon23	file:
build_evaluation_queue	glh_dynamic_graph.h	/^    void build_evaluation_queue(){$/;"	f	class:glh::DynamicGraph
build_huffman	stb_image.c	/^static int build_huffman(huffman *h, int *count)$/;"	f	file:
button_	glh_uicontext.h	/^        Input::AnyButton button_;$/;"	m	struct:glh::UiContext::Event
buttons_	glh_uicontext.h	/^    std::map<Input::AnyButton, Input::ButtonState> buttons_;$/;"	m	class:glh::UiContext
c_	geometry.h	/^    double a_,b_,c_,d_; \/\/> ax + by + cz + d = 0$/;"	m	struct:glh::Plane
c_	masp.cpp	/^    charptr c_;$/;"	m	class:masp::ValueParser	file:
cached	win32_dirent.h	/^    int cached;                                 \/* True if data is valid *\/$/;"	m	struct:_WDIR
calleach	shims_and_types.h	/^void calleach(Container& c, const Parameter& p)$/;"	f	namespace:glh
calleach	shims_and_types.h	/^void calleach(Container& c, const Parameter1& p1, const Parameter2& p2)$/;"	f	namespace:glh
camera_	glh_scenemanagement.h	/^    Camera* camera_;$/;"	m	class:glh::RenderPass
camera_parameters_to_env	glh_scenemanagement.h	/^    void camera_parameters_to_env(){$/;"	f	class:glh::RenderPass
camera_to_screen	glh_scenemanagement.h	/^    const mat4& camera_to_screen(){ return world_to_screen_; }$/;"	f	class:glh::Camera
cameras_	glh_scene_extensions.h	/^    std::list<Camera> cameras_;$/;"	m	class:glh::SceneAssets
capacity	shims_and_types.h	/^    size_t capacity() const { return capacity_;}$/;"	f	class:glh::AlignedArray
capacity_	shims_and_types.h	/^    size_t capacity_;$/;"	m	class:glh::AlignedArray
cat	glh_image.h	/^    const float* cat(int x, int y) const {return data_ + y * stride_ + x * channels_;}$/;"	f	class:glh::Image32
cat	glh_image.h	/^    const uint8_t* cat(int x, int y) const {return data_ + y * stride_ + x * channels_;}$/;"	f	class:glh::Image8
cdata	glh_font.cpp	/^    stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	m	struct:glh::FontCharData	file:
cdata	stb_truetype.h	/^stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	v
change_dim	math_tools.h	/^    Eigen::Matrix<T, M, 1> change_dim() const {$/;"	f	struct:glh::ArrayN
channel	stb_image.c	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon34	file:
channels	gltexture.h	/^    Channels       channels;$/;"	m	class:glh::TextureType
channels_	glh_image.h	/^    int      channels_;$/;"	m	class:glh::Image32
channels_	glh_image.h	/^    int      channels_;$/;"	m	class:glh::Image8
char_on_line	masp.cpp	/^    int char_on_line;$/;"	m	struct:masp::ScopeError	file:
chardata_	glh_font.h	/^    std::map<BakedFontHandle, FontCharData*> chardata_;$/;"	m	class:glh::FontContext
charptr	masp.cpp	/^    typedef const char* charptr;$/;"	t	class:masp::ValueParser	file:
check_gl_error	glsystem.cpp	/^bool check_gl_error(const char* msg)$/;"	f
check_gl_error	glsystem.cpp	/^bool check_gl_error(void)$/;"	f
check_png_header	stb_image.c	/^static int check_png_header(stbi *s)$/;"	f	file:
check_scope	masp.cpp	/^static ScopeError check_scope(const char* begin, const char* end, const char* comment, const char* scope_start, const char* scope_end)$/;"	f	namespace:masp
child_array	persistent_containers.h	/^        Ref*     child_array; \/\/> Pointer to an allocated child sequence$/;"	m	struct:glh::PMapPool::Node
children_	glh_scenemanagement.h	/^        ChildContainer children_;$/;"	m	class:glh::SceneTree::Node
chrono	tinythread.h	/^namespace chrono {$/;"	n	namespace:tthread
chunk	stb_image.c	/^} chunk;$/;"	t	typeref:struct:__anon31	file:
chunk_container	persistent_containers.h	/^    typedef std::list<chunk_type>           chunk_container;$/;"	t	class:glh::ChunkBox
chunk_type	persistent_containers.h	/^    typedef Chunk<T>                        chunk_type;$/;"	t	class:glh::ChunkBox
chunks	persistent_containers.h	/^    chunk_container& chunks(){return chunks_;}$/;"	f	class:glh::ChunkBox
chunks_	glh_mesh.h	/^    ChunkMap chunks_;$/;"	m	class:glh::DefaultMesh
chunks_	persistent_containers.h	/^    chunk_container chunks_;$/;"	m	class:glh::ChunkBox
chunks_	persistent_containers.h	/^    node_chunk_box        chunks_;$/;"	m	class:glh::PListPool
clamp	stb_image.c	/^stbi_inline static uint8 clamp(int x)$/;"	f	file:
cleanup_jpeg	stb_image.c	/^static void cleanup_jpeg(jpeg *j)$/;"	f	file:
clear	glh_font.h	/^    void clear(){ coords_.clear(); }$/;"	f	struct:glh::GlyphCoords
clear	glh_scenemanagement.h	/^    void clear(){renderables_.clear();}$/;"	f	class:glh::RenderQueue
clear	shims_and_types.h	/^    void clear() { size_  = 0;}$/;"	f	class:glh::AlignedArray
clear	shims_and_types.h	/^    void clear()$/;"	f	class:glh::Pool
clear	shims_and_types.h	/^    void clear(){data_.clear();}$/;"	f	struct:glh::SortedArray
clear	shims_and_types.h	/^    void clear(){size_ = 0;}$/;"	f	class:glh::ArenaQueue
clear_color	glhack.h	/^    Color clear_color; bool clear_color_set;$/;"	m	class:glh::RenderPassSettings
clear_color_set	glhack.h	/^    Color clear_color; bool clear_color_set;$/;"	m	class:glh::RenderPassSettings
clear_depth	glhack.h	/^    GLclampd clear_depth; bool clear_depth_set;$/;"	m	class:glh::RenderPassSettings
clear_depth_set	glhack.h	/^    GLclampd clear_depth; bool clear_depth_set;$/;"	m	class:glh::RenderPassSettings
clear_ids	glh_scenemanagement.h	/^    void clear_ids(){$/;"	f	class:glh::RenderPicker
clear_mask	glhack.h	/^    GLuint   clear_mask;$/;"	m	class:glh::RenderPassSettings
clear_root_refcounts	persistent_containers.h	/^    void clear_root_refcounts()$/;"	f	class:glh::PListPool
clear_root_refcounts	persistent_containers.h	/^    void clear_root_refcounts()$/;"	f	class:glh::PMapPool
close	iotools.cpp	/^void InputFile::close(){file_.close();}$/;"	f	class:InputFile
close	iotools.cpp	/^void OutputFile::close(){file_.close();}$/;"	f	class:OutputFile
closedir	win32_dirent.h	/^closedir($/;"	f
cmatch_t	glh_regex.h	/^typedef boost::cmatch cmatch_t;$/;"	t
cmatch_t	glh_regex.h	/^typedef std::cmatch cmatch_t;$/;"	t
cmp_	shims_and_types.h	/^    Compare cmp_;$/;"	m	struct:glh::SortedArray
code	stb_image.c	/^   uint16 code[256];$/;"	m	struct:__anon25	file:
code_bits	stb_image.c	/^   int            code_bits;   \/\/ number of valid bits$/;"	m	struct:__anon26	file:
code_buffer	stb_image.c	/^   uint32         code_buffer; \/\/ jpeg entropy-coded buffer$/;"	m	struct:__anon26	file:
code_buffer	stb_image.c	/^   uint32 code_buffer;$/;"	m	struct:__anon30	file:
codes	stb_image.c	/^   stbi_gif_lzw codes[4096];$/;"	m	struct:stbi_gif_struct	file:
collect_chunks	persistent_containers.h	/^    void collect_chunks()$/;"	f	class:glh::ChunkBox
collect_map_and_list_pools_with_roots	masp.cpp	/^void collect_map_and_list_pools_with_roots(MapPool& map_pool, ListPool& list_pool, Map& map)$/;"	f	namespace:masp::__anon14
collect_marked	persistent_containers.h	/^    void collect_marked()$/;"	f	struct:glh::Chunk
collided_list_pool_	persistent_containers.h	/^    KeyValueListPool   collided_list_pool_;$/;"	m	class:glh::PMapPool
collision_list	persistent_containers.h	/^            KeyValueList* collision_list; $/;"	m	union:glh::PMapPool::Node::__anon20
color_interpolation	glh_uicontext.cpp	/^void UiContext::Technique::color_interpolation(App& app, DynamicGraph& graph, StringNumerator& string_numerator, SceneTree::Node* node){$/;"	f	class:glh::UiContext::Technique
color_mask	glhack.h	/^    ColorMask color_mask; bool color_mask_set;$/;"	m	class:glh::RenderPassSettings
color_mask_set	glhack.h	/^    ColorMask color_mask; bool color_mask_set;$/;"	m	class:glh::RenderPassSettings
color_of_id	glh_typedefs.cpp	/^vec4 ObjectRoster::color_of_id(int id){$/;"	f	class:glh::ObjectRoster
color_table	stb_image.c	/^   uint8 *color_table;$/;"	m	struct:stbi_gif_struct	file:
compare	masp.cpp	/^bool ValuesAreEqual::compare(const Value& k1, const Value& k2){return k1 == k2;} $/;"	f	class:masp::ValuesAreEqual
compare	persistent_containers.h	/^    static bool compare(const K& k1, const K& k2){return k1 == k2;} $/;"	f	class:glh::AreEqual
compile_program	glhack.cpp	/^    bool compile_program(ShaderProgram& program)$/;"	f	namespace:glh::__anon7
compile_shaders	glhack.cpp	/^    bool compile_shaders(ShaderProgram& program)$/;"	f	namespace:glh::__anon7
complement_t	math_tools.h	/^    typedef Eigen::Matrix<T, N, 1> complement_t;$/;"	t	struct:glh::ArrayN
component_count	glbuffers.h	/^    int32_t component_count() const {return mapped_sig_.component_count();}$/;"	f	class:glh::BufferHandle
component_count	glbuffers.h	/^    int32_t component_count() const {return size_bytes_ \/ (components_ * TypeId::size(type_));}$/;"	f	struct:glh::BufferSignature
component_count_	glhack.cpp	/^    int32_t        component_count_;$/;"	m	class:glh::ActiveProgram	file:
component_wise_product	math_tools.h	/^Eigen::Matrix<T, N, M> component_wise_product(const Eigen::Matrix<T, N, M>& first, const Eigen::Matrix<T, N, M>& second)$/;"	f	namespace:glh
components	glbuffers.h	/^    int32_t components()const{return mapped_sig_.components_;}$/;"	f	class:glh::BufferHandle
components_	glbuffers.h	/^    int32_t   components_; \/\/> Number of components.I.e 2 for vec2, 3 for vec3 etc.$/;"	m	struct:glh::BufferSignature
compose_full_path	asset_manager.cpp	/^    std::string compose_full_path(const char* path){$/;"	f	class:glh::DefaultAssetManager
compute_huffman_codes	stb_image.c	/^static int compute_huffman_codes(zbuf *a)$/;"	f	file:
compute_transparency	stb_image.c	/^static int compute_transparency(png *z, uint8 tc[3], int out_n)$/;"	f	file:
compute_y	stb_image.c	/^static uint8 compute_y(int r, int g, int b)$/;"	f	file:
condition_variable	tinythread.cpp	/^condition_variable::condition_variable() : mWaitersCount(0)$/;"	f	class:tthread::condition_variable
condition_variable	tinythread.h	/^class condition_variable {$/;"	c	namespace:tthread
config	glbase.h	/^    const AppConfig& config() const {return config_;}$/;"	f	class:glh::App
config_	glbase.h	/^    AppConfig                        config_;$/;"	m	class:glh::App
config_file_path	asset_manager.cpp	/^    std::string config_file_path;$/;"	m	class:glh::DefaultAssetManager	file:
config_node	glh_dynamic_graph.h	/^    void config_node(){$/;"	f	class:glh::LimitedIncrementalValue
const_iterator	shims_and_types.h	/^        const_iterator():n(nullptr){}$/;"	f	struct:glh::PooledList::const_iterator
const_iterator	shims_and_types.h	/^        const_iterator(Node* node):n(node){}$/;"	f	struct:glh::PooledList::const_iterator
const_iterator	shims_and_types.h	/^    struct const_iterator$/;"	s	class:glh::PooledList
const_iterator	shims_and_types.h	/^    typedef const T* const_iterator;$/;"	t	class:glh::AlignedArray
const_iterator	shims_and_types.h	/^    typedef typename Container::const_iterator  const_iterator;$/;"	t	struct:glh::SortedArray
const_iterator	shims_and_types.h	/^    typedef typename Map::const_iterator const_iterator;$/;"	t	class:glh::BiMap
const_reference	shims_and_types.h	/^    typedef const T&  const_reference;$/;"	t	class:glh::Pool
const_reference	shims_and_types.h	/^    typedef const T&  const_reference;$/;"	t	class:glh::PooledList
const_reference	shims_and_types.h	/^    typedef typename Container::const_reference const_reference;$/;"	t	struct:glh::SortedArray
constrain	math_tools.h	/^template<class T> inline T constrain(const T value, const T begin, const T end){$/;"	f	namespace:glh
constvalue_t	glh_dynamic_graph.h	/^    typedef const Value   constvalue_t;$/;"	t	class:glh::DynamicGraph
constvalue_t_ptr	glh_dynamic_graph.h	/^    typedef constvalue_t* constvalue_t_ptr;$/;"	t	class:glh::DynamicGraph
contains	persistent_containers.h	/^    bool contains(const T* ptr)$/;"	f	struct:glh::Chunk
contains	shims_and_types.h	/^    bool contains(const T& t) const {$/;"	f	struct:glh::SortedArray
contains	shims_and_types.h	/^bool contains(const std::string& str, const T& t){$/;"	f	namespace:glh
content	math_tools.h	/^    T content() const {$/;"	f	struct:glh::Box
contents_to_bytes	iotools.cpp	/^std::tuple<std::vector<uint8_t>, bool> InputFile::contents_to_bytes()$/;"	f	class:InputFile
contents_to_string	iotools.cpp	/^std::tuple<std::string, bool> InputFile::contents_to_string()$/;"	f	class:InputFile
context_	glh_dynamic_graph.h	/^    FocusContext&    context_;$/;"	m	class:glh::NodeFocusState
context_	glh_scene_extensions.h	/^    FontContext context_;$/;"	m	class:glh::FontManager
conversion_h	conversion.h	28;"	d
convert	glh_image.cpp	/^Image8 convert(const Image32& img)$/;"	f	namespace:glh
convert_cond_to_if	masp.cpp	/^Value convert_cond_to_if(const Value& v, Masp& masp)$/;"	f	namespace:masp::__anon15
convert_format	stb_image.c	/^static unsigned char *convert_format(unsigned char *data, int img_n, int req_comp, uint x, uint y)$/;"	f	file:
convert_from_linear	conversion.c	/^void convert_from_linear(float* buf, const unsigned char* from, int W, int delta)$/;"	f
convert_from_sRGB	conversion.c	/^void convert_from_sRGB(float* buf, const unsigned char* from, int W, int delta)$/;"	f
convert_to_float	masp.cpp	/^void convert_to_float(NumberArray& arr)$/;"	f	namespace:masp
convert_to_int	masp.cpp	/^void convert_to_int(NumberArray& arr)$/;"	f	namespace:masp
convert_to_linear	conversion.c	/^void convert_to_linear(unsigned char* buf, const float* from, int W, int delta)$/;"	f
convert_to_sRGB	conversion.c	/^void convert_to_sRGB(unsigned char* buf, const float* from, int W, int delta)$/;"	f
coord_t	math_tools.h	/^    enum coord_t{X = 0, Y = 1, Z = 2};$/;"	g	struct:Dim
coords_	glh_font.h	/^    row_coords_container_t coords_;$/;"	m	struct:glh::GlyphCoords
copy	masp.cpp	/^void Value::copy(const Value& v)$/;"	f	class:masp::Value
copy	persistent_containers.h	/^    Node* copy(Node* n)$/;"	f	class:glh::PListPool
copy_new	masp.cpp	/^V* copy_new(const V* v)$/;"	f	namespace:masp
copyif	shims_and_types.h	/^Cont copyif(Cont& c, PredFun pred)$/;"	f	namespace:glh
count	tinythread.h	/^      rep count() const$/;"	f	class:tthread::chrono::duration
count_bits	math_tools.h	/^inline const uint32_t count_bits(uint32_t field)$/;"	f	namespace:glh
count_in_bytes	shims_and_types.h	/^    size_t count_in_bytes(size_t count){return count * value_size();}$/;"	f	class:glh::AlignedArray
cover	math_tools.h	/^Box<T,N> cover(const Box<T,N>& a, const Box<T,N>& b)$/;"	f	namespace:glh
cover_spans	math_tools.h	/^typename Math<T>::span_t cover_spans(const typename Math<T>::span_t& a, const typename Math<T>::span_t& b)$/;"	f	namespace:glh
create	glh_scene_extensions.h	/^    static std::shared_ptr<SceneAssets> create(App* app, GraphicsManager* gm, FontManager* font_manager){$/;"	f	class:glh::SceneAssets
create_camera	glh_scene_extensions.h	/^    Camera* create_camera(Camera::Projection projection_type){$/;"	f	class:glh::SceneAssets
create_glyph_pane	glh_scene_extensions.h	/^    GlyphPane* create_glyph_pane(const std::string& program_name, const std::string& background_program_name){$/;"	f	class:glh::SceneAssets
create_handle	glbuffers.h	/^    void create_handle(const char* name, const BufferSignature& sig){$/;"	f	class:glh::BufferSet
create_handle	glbuffers.h	/^    void create_handle(const std::string& name, const BufferSignature& sig){$/;"	f	class:glh::BufferSet
create_mesh	geometry.cpp	/^UnstructuredMesh* create_mesh()$/;"	f	namespace:glh
create_png_image	stb_image.c	/^static int create_png_image(png *a, uint8 *raw, uint32 raw_len, int out_n, int interlaced)$/;"	f	file:
create_png_image_raw	stb_image.c	/^static int create_png_image_raw(png *a, uint8 *raw, uint32 raw_len, int out_n, uint32 x, uint32 y)$/;"	f	file:
create_render_pass	glh_scene_extensions.h	/^    RenderPass* create_render_pass(){$/;"	f	class:glh::SceneAssets
create_render_pass	glh_scene_extensions.h	/^    RenderPass* create_render_pass(const std::string& name){$/;"	f	class:glh::SceneAssets
create_shader_program	glhack.cpp	/^ShaderProgram* create_shader_program(GraphicsManagerInt* manager, cstring& name, cstring& geometry_shader, cstring& vertex_shader, cstring& fragment_shader)$/;"	f	namespace:glh
creator_	glh_dynamic_graph.h	/^    NodeCreator* creator_;$/;"	m	struct:glh::List
cstring	shims_and_types.h	/^typedef const std::string cstring;$/;"	t	namespace:glh
ctrl_	glh_scene_extensions.h	/^    bool ctrl_;$/;"	m	struct:glh::Modifiers
ctx_	glh_scenemanagement.h	/^        FocusContext& ctx_;$/;"	m	struct:glh::FocusContext::Focus
cur_	shims_and_types.h	/^        value_type* cur_;$/;"	m	struct:glh::ArenaQueue::iterator
cur_x	stb_image.c	/^   int cur_x, cur_y;$/;"	m	struct:stbi_gif_struct	file:
cur_y	stb_image.c	/^   int cur_x, cur_y;$/;"	m	struct:stbi_gif_struct	file:
current	persistent_containers.h	/^        Node* current(){return iter->node;}$/;"	f	struct:glh::PMapPool::NodeChildIterator
current	persistent_containers.h	/^        const KeyValue* current() const {return keyvalue;}$/;"	f	struct:glh::PMapPool::NodeValueIterator
current	persistent_containers.h	/^        const KeyValue* current;$/;"	m	class:glh::PMapPool::node_iterator
current_	glh_dynamic_graph.h	/^        ListNode* current_;$/;"	m	struct:glh::List::iterator
current_	glh_scenemanagement.h	/^        Node*               current_;$/;"	m	class:glh::SceneTree::tree_iterator
current_	math_tools.h	/^        T current_;$/;"	m	struct:glh::Range::iterator
current_program_	glhack.cpp	/^    ShaderProgram* current_program_;$/;"	m	class:glh::GraphicsManagerInt	file:
currently_focused_	glh_scenemanagement.h	/^    entity_container_t currently_focused_;$/;"	m	class:glh::FocusContext
cursor_mesh_	glh_scene_extensions.h	/^    DefaultMesh*     cursor_mesh_;$/;"	m	class:glh::GlyphPane
cursor_node_	glh_scene_extensions.h	/^    SceneTree::Node* cursor_node_;          \/\/> The cursor node$/;"	m	class:glh::GlyphPane
cursor_pos_	glh_scene_extensions.h	/^    vec3             cursor_pos_;$/;"	m	class:glh::GlyphPane
cursor_pos_index_	glh_scene_extensions.h	/^    vec2i            cursor_pos_index_;$/;"	m	class:glh::GlyphPane
cursor_renderable_	glh_scene_extensions.h	/^    FullRenderable*  cursor_renderable_;$/;"	m	class:glh::GlyphPane
cx	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon38
cy	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon38
d_	geometry.h	/^    double a_,b_,c_,d_; \/\/> ax + by + cz + d = 0$/;"	m	struct:glh::Plane
d_ino	win32_dirent.h	/^    long d_ino;                                 \/* Always zero *\/$/;"	m	struct:_wdirent
d_ino	win32_dirent.h	/^    long d_ino;                                 \/* Always zero *\/$/;"	m	struct:dirent
d_name	win32_dirent.h	/^    char d_name[PATH_MAX + 1];                  \/* File name *\/$/;"	m	struct:dirent
d_name	win32_dirent.h	/^    wchar_t d_name[PATH_MAX + 1];               \/* File name *\/$/;"	m	struct:_wdirent
d_namlen	win32_dirent.h	/^    size_t d_namlen;                            \/* Length of name without \\0 *\/$/;"	m	struct:_wdirent
d_namlen	win32_dirent.h	/^    size_t d_namlen;                            \/* Length of name without \\0 *\/$/;"	m	struct:dirent
d_reclen	win32_dirent.h	/^    unsigned short d_reclen;                    \/* Structure size *\/$/;"	m	struct:_wdirent
d_reclen	win32_dirent.h	/^    unsigned short d_reclen;                    \/* Structure size *\/$/;"	m	struct:dirent
d_type	win32_dirent.h	/^    int d_type;                                 \/* File type *\/$/;"	m	struct:_wdirent
d_type	win32_dirent.h	/^    int d_type;                                 \/* File type *\/$/;"	m	struct:dirent
data	glbuffers.h	/^    template<class T> T*  data() {return reinterpret_cast<T>(&data_[0]);}$/;"	f	class:glh::VertexChunk
data	glbuffers.h	/^    uint8_t*              data() {return &data_[0];}$/;"	f	class:glh::VertexChunk
data	glh_image.h	/^    const uint8_t* data() const {return data_;}$/;"	f	class:glh::Image8
data	glh_image.h	/^    uint8_t*       data(){return data_;}$/;"	f	class:glh::Image8
data	math_tools.h	/^        T data[2];$/;"	m	class:glh::Math::span_t
data	persistent_containers.h	/^        T     data;$/;"	m	struct:glh::PListPool::Node
data	shims_and_types.h	/^        T data;$/;"	m	struct:glh::PooledList::Node
data	shims_and_types.h	/^    T* data(){return &data_[0];}$/;"	f	class:glh::Array
data	shims_and_types.h	/^    T* data(){return data_;}$/;"	f	class:glh::AlignedArray
data	stb_image.c	/^      uint8 *data;$/;"	m	struct:__anon26::__anon27	file:
data	stb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo
data	win32_dirent.h	/^    WIN32_FIND_DATAW data;                      \/* Private file data *\/$/;"	m	struct:_WDIR
data_	glbuffers.h	/^    AlignedArray<uint8_t> data_;$/;"	m	class:glh::VertexChunk
data_	glh_dynamic_graph.h	/^        T data_;$/;"	m	struct:glh::List::ListNode
data_	glh_dynamic_graph.h	/^        std::deque<ListNode> data_;$/;"	m	struct:glh::List::NodeCreator
data_	glh_image.h	/^    float*   data_;$/;"	m	class:glh::Image32
data_	glh_image.h	/^    uint8_t* data_;$/;"	m	class:glh::Image8
data_	math_tools.h	/^    T data_[N];$/;"	m	struct:glh::ArrayN
data_	shims_and_types.h	/^    DataContainer data_;$/;"	m	class:glh::Pool
data_	shims_and_types.h	/^    T* data_;$/;"	m	class:glh::AlignedArray
data_	shims_and_types.h	/^    std::vector<T> data_;$/;"	m	class:glh::Array
data_	shims_and_types.h	/^    std::vector<T> data_;$/;"	m	struct:glh::SortedArray
data_ptr	persistent_containers.h	/^            T* data_ptr() {return &node->data;}$/;"	f	struct:glh::PListPool::List::iterator
data_ptr	persistent_containers.h	/^        const KeyValue* data_ptr(){return current;}$/;"	f	class:glh::PMapPool::node_iterator
datalink_t	glh_dynamic_graph.h	/^    typedef std::tuple<node_id_t, var_id_t, constvalue_t_ptr> datalink_t;$/;"	t	class:glh::DynamicGraph
dc_pred	stb_image.c	/^      int dc_pred;$/;"	m	struct:__anon26::__anon27	file:
dealloc	masp.cpp	/^void Value::dealloc()$/;"	f	class:masp::Value
dealloc_	glh_image.h	/^    Deallocator dealloc_;$/;"	m	class:glh::Image32
dealloc_	glh_image.h	/^    Deallocator dealloc_;$/;"	m	class:glh::Image8
decode	stb_image.c	/^stbi_inline static int decode(jpeg *j, huffman *h)$/;"	f	file:
decode_block	stb_image.c	/^static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)$/;"	f	file:
decode_jpeg_header	stb_image.c	/^static int decode_jpeg_header(jpeg *z, int scan)$/;"	f	file:
decode_jpeg_image	stb_image.c	/^static int decode_jpeg_image(jpeg *j)$/;"	f	file:
decrease_dim	math_tools.h	/^Eigen::Matrix<T, N-1, 1> decrease_dim(const Eigen::Matrix<T, N, 1>& v){$/;"	f	namespace:glh
default_camera	glh_app_services.h	/^    Camera*         default_camera;$/;"	m	class:glh::AppServices
default_distance	stb_image.c	/^static uint8 default_length[288], default_distance[32];$/;"	v	file:
default_length	stb_image.c	/^static uint8 default_length[288], default_distance[32];$/;"	v	file:
default_main	glbase.cpp	/^void default_main(App& app)$/;"	f	namespace:glh
default_origin_	glh_scene_extensions.h	/^    vec2             default_origin_; \/\/ TODO do we need this when layout finished$/;"	m	class:glh::GlyphPane
delta	stb_image.c	/^   int    delta[17];   \/\/ old 'firstsymbol' - old 'firstcode'$/;"	m	struct:__anon25	file:
depth	shims_and_types.h	/^    size_t depth(){return level_;}$/;"	f	class:glh::FixedStack
depth_mask	glhack.h	/^    DepthMask depth_mask; bool depth_mask_set;$/;"	m	class:glh::RenderPassSettings
depth_mask_set	glhack.h	/^    DepthMask depth_mask; bool depth_mask_set;$/;"	m	class:glh::RenderPassSettings
dequant	stb_image.c	/^   uint8 dequant[4][64];$/;"	m	struct:__anon26	file:
dequant2	stb_image.c	/^   unsigned short dequant2[4][64];$/;"	m	struct:__anon26	file:
dest_factor_	glhack.h	/^        GLenum  dest_factor_;$/;"	m	struct:glh::RenderPassSettings::BlendSettings
detach	tinythread.cpp	/^void thread::detach()$/;"	f	class:tthread::thread
detach_node	glh_scenemanagement.h	/^    void detach_node(SceneTree::Node* node){$/;"	f	class:glh::RenderPicker
device_buffers_	glhack.h	/^    BufferSet         device_buffers_;$/;"	m	class:glh::FullRenderable
dezigzag	stb_image.c	/^static uint8 dezigzag[64+15] =$/;"	v	file:
dfs	glh_dynamic_graph.h	/^    void dfs(const id_t vertex){$/;"	f	class:glh::DfsForestSort
dim1	glbase.h	/^    int dim1;                      \/\/> MouseMove:x; MouseWheelMove: position$/;"	m	class:glh::InputEvent
dim2	glbase.h	/^    int dim2;                      \/\/> MouseMove:y;$/;"	m	class:glh::InputEvent
directory_exists	iotools.cpp	/^bool directory_exists(std::string dirpath){$/;"	f
dirent	win32_dirent.h	/^struct dirent {$/;"	s
dirent	win32_dirent.h	/^typedef struct dirent dirent;$/;"	t	typeref:struct:dirent
dirent_first	win32_dirent.h	/^dirent_first($/;"	f
dirent_mbstowcs_s	win32_dirent.h	/^dirent_mbstowcs_s($/;"	f
dirent_next	win32_dirent.h	/^dirent_next($/;"	f
dirent_set_errno	win32_dirent.h	/^dirent_set_errno($/;"	f
dirent_wcstombs_s	win32_dirent.h	/^dirent_wcstombs_s($/;"	f
dirty_	glh_scene_extensions.h	/^    bool             dirty_;$/;"	m	class:glh::GlyphPane
dirty_	gltexture.h	/^    bool   dirty_;$/;"	m	class:glh::Texture
dist_base	stb_image.c	/^static int dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,$/;"	v	file:
dist_extra	stb_image.c	/^static int dist_extra[32] =$/;"	v	file:
div16	stb_image.c	1706;"	d	file:
div4	stb_image.c	1657;"	d	file:
do_picking	glh_scenemanagement.h	/^    int do_picking(Box<int,2>& read_bounds){$/;"	f	class:glh::RenderPicker
do_png	stb_image.c	/^static unsigned char *do_png(png *p, int *x, int *y, int *n, int req_comp)$/;"	f	file:
do_zlib	stb_image.c	/^static int do_zlib(zbuf *a, char *obuf, int olen, int exp, int parse_header)$/;"	f	file:
dot	glh_generators.cpp	/^    static double dot(const Grad& g, const double x, const double y){$/;"	f	struct:glh::SimplexNoise
dot	glh_generators.cpp	/^    static double dot(const Grad& g, const double x, const double y, const double z){$/;"	f	struct:glh::SimplexNoise
dot	glh_generators.cpp	/^    static double dot(const Grad& g, const double x, const double y, const double z, const double w){$/;"	f	struct:glh::SimplexNoise
dragged	glh_uicontext.h	/^    std::vector<SceneTree::Node*> dragged;$/;"	m	class:glh::UiContext
draw	glhack.cpp	/^void ActiveProgram::draw(){$/;"	f	class:glh::ActiveProgram
duration	tinythread.h	/^        explicit duration(const _Rep2& r) : rep_(r) {};$/;"	f	class:tthread::chrono::duration
duration	tinythread.h	/^  template <class _Rep, class _Period = ratio<1> > class duration {$/;"	c	namespace:tthread::chrono
dx	stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
dynamic_node_ptr_t	glh_dynamic_graph.h	/^    typedef std::shared_ptr<DynamicNode>            dynamic_node_ptr_t;$/;"	t	class:glh::DynamicGraph
e	stb_image.c	/^static int e(const char *str)$/;"	f	file:
e	stb_image.c	514;"	d	file:
e	stb_image.c	516;"	d	file:
e	stb_image.c	518;"	d	file:
each_elem_to_os	shims_and_types.h	/^std::ostream& each_elem_to_os(std::ostream& os, Iter begin, Iter end)$/;"	f	namespace:glh
easing	glh_timebased_signals.h	/^    static float easing(Easing::t e, float v){$/;"	f	class:glh::Animation
easing_	glh_dynamic_graph.h	/^    Animation::Easing::t easing_;$/;"	m	class:glh::ScalarRamp
eflags	stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
elements_are_ordered	shims_and_types.cpp	/^bool elements_are_ordered(const std::string& first, const std::string& second){$/;"	f	namespace:glh
empty	glh_font.h	/^    bool empty(){ return coords_.empty() || (coords_.size() == 1 && coords_[0].empty()); }$/;"	f	struct:glh::GlyphCoords
empty	glh_image.h	/^    bool empty() const {return data_ == 0;}$/;"	f	class:glh::Image32
empty	glh_image.h	/^    bool empty() const {return data_ == 0;}$/;"	f	class:glh::Image8
empty	glh_scene_extensions.h	/^    bool empty(){ return text_fields_.size() == 0 || text_fields_.size() == 1 && text_fields_[0]->size() == 0; }$/;"	f	class:glh::TextField
empty	glh_scenemanagement.h	/^        bool empty(){return children_.empty();}$/;"	f	class:glh::SceneTree::Node
empty	glhack.cpp	/^RenderPassSettings RenderPassSettings::empty()$/;"	f	class:glh::RenderPassSettings
empty	persistent_containers.h	/^        bool empty() const {return head_ == 0;}$/;"	f	class:glh::PListPool::List
end	glbase.cpp	/^bool App::end()$/;"	f	class:glh::App
end	glh_dynamic_graph.h	/^    iterator end() const {return iterator(0);}$/;"	f	struct:glh::List
end	glh_font.h	/^    iterator end(){ return iterator(*this, iterator::end_index); }$/;"	f	struct:glh::textured_quad2d_t
end	glh_scenemanagement.h	/^        ChildContainer::iterator end(){return children_.end();}$/;"	f	class:glh::SceneTree::Node
end	glh_scenemanagement.h	/^        node_ptr_container_t::iterator end(){return picker_.picked_.end();}$/;"	f	struct:glh::RenderPicker::PickedContext
end	glh_scenemanagement.h	/^    iterator end() {return tree_iterator(0);}$/;"	f	class:glh::SceneTree
end	glh_scenemanagement.h	/^    node_ptr_sequence_t::iterator end(){$/;"	f	class:glh::RenderQueue
end	math_tools.h	/^    float end; \/\/> Inclusive range end.$/;"	m	struct:glh::RandomRange
end	math_tools.h	/^    int32_t end; \/\/> Inclusive range end.$/;"	m	struct:glh::RandomRange
end	math_tools.h	/^    iterator end() const {return iterator(range_end_, increment_);}$/;"	f	class:glh::Range
end	persistent_containers.h	/^        Ref* end(){return child_array + size();}$/;"	f	struct:glh::PMapPool::Node
end	persistent_containers.h	/^        iterator end() const {return iterator(0);}$/;"	f	class:glh::PListPool::List
end	persistent_containers.h	/^        iterator end() const {return iterator(0);}$/;"	f	class:glh::PMapPool::Map
end	persistent_containers.h	/^        typename KeyValueList::iterator end;$/;"	m	struct:glh::PMapPool::NodeValueIterator
end	persistent_containers.h	/^        typename Node::Ref* end;  $/;"	m	struct:glh::PMapPool::NodeChildIterator
end	persistent_containers.h	/^    T* end(){return buffer + CHUNK_BUFFER_SIZE;}$/;"	f	struct:glh::Chunk
end	persistent_containers.h	/^    iterator end(){return chunks_.end();}$/;"	f	class:glh::ChunkBox
end	shims_and_types.h	/^    const char* end() const {return string.c_str() + string.size();}$/;"	f	struct:glh::TextLine
end	shims_and_types.h	/^    const_iterator end() const { return data_ + size_;}$/;"	f	class:glh::AlignedArray
end	shims_and_types.h	/^    const_iterator end() const {return const_iterator(nullptr);}$/;"	f	class:glh::PooledList
end	shims_and_types.h	/^    const_iterator end() const {return data_.end();}$/;"	f	struct:glh::SortedArray
end	shims_and_types.h	/^    const_iterator end() const {return keys_to_values_.end();}$/;"	f	class:glh::BiMap
end	shims_and_types.h	/^    iterator end() { return data_ + size_;}$/;"	f	class:glh::AlignedArray
end	shims_and_types.h	/^    iterator end(){return begin() + live_count_;}$/;"	f	class:glh::Pool
end	shims_and_types.h	/^    iterator end(){return data_.end();}$/;"	f	struct:glh::SortedArray
end	shims_and_types.h	/^    iterator end(){return iterator(&queue_[size_]);}$/;"	f	class:glh::ArenaQueue
end	shims_and_types.h	/^    iterator end(){return iterator(nullptr);}$/;"	f	class:glh::PooledList
end	shims_and_types.h	/^    iterator end(){return keys_to_values_.end();}$/;"	f	class:glh::BiMap
end_	glh_scenemanagement.h	/^            Node::ChildContainer::iterator end_;$/;"	m	struct:glh::SceneTree::tree_iterator::Iterator
end_	masp.cpp	/^    charptr end_;$/;"	m	class:masp::ValueParser	file:
end_	masp_classwrap.h	/^    VecIterator i_; VecIterator end_;$/;"	m	class:masp::ArgWrap
end_index	glh_font.h	/^        static const int end_index = 6;$/;"	m	struct:glh::textured_quad2d_t::iterator
end_iter	glh_scenemanagement.cpp	/^SceneTree::iterator end_iter(SceneTree::Node* node){return SceneTree::tree_iterator(0);}$/;"	f	namespace:glh
ent	win32_dirent.h	/^    struct _wdirent ent;                        \/* Current directory entry *\/$/;"	m	struct:_WDIR	typeref:struct:_WDIR::_wdirent
ent	win32_dirent.h	/^    struct dirent ent;$/;"	m	struct:DIR	typeref:struct:DIR::dirent
entity_container_t	glh_scenemanagement.h	/^    typedef SortedArray<SceneTree::Node*> entity_container_t;$/;"	t	class:glh::FocusContext
env	masp.cpp	/^Masp::Env* Masp::env(){return env_;}$/;"	f	class:masp::Masp
env_	glh_scenemanagement.h	/^    RenderEnvironment               env_;$/;"	m	class:glh::RenderPass
env_	glhack.h	/^        RenderEnvironment& env_;$/;"	m	struct:glh::RenderEnvironment::ParamMap
env_	masp.cpp	/^    std::unique_ptr<Map> env_;$/;"	m	class:masp::Masp::Env	file:
env_	masp.h	/^    Env* env_;$/;"	m	class:masp::Masp
env_map	masp.cpp	/^Map& Masp::env_map(){$/;"	f	class:masp::Masp
eof	stb_image.c	/^   int      (*eof)   (void *user);                       \/\/ returns nonzero if we are at end of file\/data$/;"	m	struct:__anon22	file:
epf	stb_image.c	521;"	d	file:
epuc	stb_image.c	522;"	d	file:
equal	masp.cpp	/^static bool equal(const char* str_1, const char* str_2)$/;"	f	namespace:masp
erase	glh_scene_extensions.h	/^    void erase(TextLine& t){$/;"	f	class:glh::TextField
erase	shims_and_types.h	/^    void erase(const T& t)$/;"	f	struct:glh::SortedArray
erase	shims_and_types.h	/^void erase(T& container, typename const T::value_type& v)$/;"	f	namespace:glh
erase_from_back	shims_and_types.h	/^    void erase_from_back(){ string.erase(string.size() - 1, 1);}$/;"	f	struct:glh::TextLine
erase_line	glh_scene_extensions.h	/^    void erase_line(const int row){$/;"	f	class:glh::TextField
euler_t	math_tools.h	/^    enum euler_t{RX = 0, RY = 1, RZ = 2};$/;"	g	struct:Dim
eval	masp.cpp	/^Value eval(const Value& v, Map& env, Masp& masp)$/;"	f	namespace:masp::__anon15
eval	masp.cpp	/^masp_result eval(Masp& m, const Value* v)$/;"	f	namespace:masp
eval_compound_procedure	masp.cpp	/^Value eval_compound_procedure(const Value& v, Vector& params, Masp& masp)$/;"	f	namespace:masp::__anon15
eval_list_to_vector	masp.cpp	/^Vector eval_list_to_vector(VRefIterator args_begin, VRefIterator args_end, Map& env, Masp& masp)$/;"	f	namespace:masp::__anon15
eval_sequence	masp.cpp	/^Value eval_sequence(const List& expressions, Map& env, Masp& masp)$/;"	f	namespace:masp::__anon15
evaluation_queue_	glh_dynamic_graph.h	/^    std::vector<DynamicNode*> evaluation_queue_;$/;"	m	class:glh::DynamicGraph
event_	glh_timebased_signals.h	/^        event_t event_;$/;"	m	class:glh::DynamicSystem::Event
event_	glh_uicontext.h	/^        t event_;$/;"	m	struct:glh::UiContext::Event
event_container_t	glh_timebased_signals.h	/^    typedef std::map<obj_id, Event> event_container_t;$/;"	t	class:glh::DynamicSystem
event_handling_done_	glh_scenemanagement.h	/^    bool event_handling_done_ ;$/;"	m	class:glh::FocusContext
event_t	glh_timebased_signals.h	/^        typedef std::function<bool (float)> event_t;$/;"	t	class:glh::DynamicSystem::Event
events	glbase.h	/^    EventContainer events;$/;"	m	class:glh::UserInput
events_	glh_timebased_signals.h	/^    event_container_t events_;$/;"	m	class:glh::DynamicSystem
events_	glh_uicontext.h	/^    std::stack<Event>             events_;$/;"	m	class:glh::UiContext
execute	glh_dynamic_graph.h	/^    void execute(){$/;"	f	class:glh::DynamicGraph
expand	stb_image.c	/^static int expand(zbuf *z, int n)  \/\/ need to make room for n bytes$/;"	f	file:
expand_clauses	masp.cpp	/^Value expand_clauses(const List& clauses, Masp& masp)$/;"	f	namespace:masp::__anon15
expand_palette	stb_image.c	/^static int expand_palette(png *a, uint8 *palette, int len, int pal_img_n)$/;"	f	file:
expanded	stb_image.c	/^   uint8 *idata, *expanded, *out;$/;"	m	struct:__anon32	file:
extend_receive	stb_image.c	/^stbi_inline static int extend_receive(jpeg *j, int n)$/;"	f	file:
ey	stb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge
f2f	stb_image.c	1204;"	d	file:
factory	glh_dynamic_graph.h	/^    static std::function<DynamicNodeRef(DynamicGraph::DynamicNode* node)> factory(glh::DynamicGraph& graph){$/;"	f	struct:glh::DynamicNodeRef
factory_enumerate_names	glh_dynamic_graph.h	/^    static std::function<DynamicNodeRef(DynamicGraph::DynamicNode* node)> factory_enumerate_names(glh::DynamicGraph& graph, glh::StringNumerator& string_numerator){$/;"	f	struct:glh::DynamicNodeRef
failure_reason	stb_image.c	/^static const char *failure_reason;$/;"	v	file:
fast	stb_image.c	/^   uint16 fast[1 << ZFAST_BITS];$/;"	m	struct:__anon29	file:
fast	stb_image.c	/^   uint8  fast[1 << FAST_BITS];$/;"	m	struct:__anon25	file:
fast_mutex	fast_mutex.h	/^    fast_mutex() : mLock(0) {}$/;"	f	class:tthread::fast_mutex
fast_mutex	fast_mutex.h	/^class fast_mutex {$/;"	c	namespace:tthread
file	iotools.cpp	/^std::ifstream& InputFile::file(){return file_;}$/;"	f	class:InputFile
file	iotools.cpp	/^std::ofstream& OutputFile::file(){return file_;}$/;"	f	class:OutputFile
file_	iotools.h	/^    std::ifstream file_;$/;"	m	class:InputFile
file_	iotools.h	/^    std::ofstream file_;$/;"	m	class:OutputFile
file_to_bytes	iotools.cpp	/^std::tuple<std::vector<uint8_t>, bool> file_to_bytes(const char* path)$/;"	f
file_to_string	iotools.cpp	/^std::tuple<std::string, bool> file_to_string(const char* path)$/;"	f
fill	math_tools.h	/^    void fill(const T& val){$/;"	f	struct:glh::ArrayN
fill_bits	stb_image.c	/^static void fill_bits(zbuf *z)$/;"	f	file:
filter	shims_and_types.h	/^Collection filter(const Collection& collection, const Fun fun)$/;"	f	namespace:glh
finalize	glh_app_services.h	/^    void finalize(){$/;"	f	class:glh::AppServices
finalize	glh_scenemanagement.h	/^    void finalize(Node* node){$/;"	f	class:glh::SceneTree
find	persistent_containers.h	/^        iterator find(const List* list, std::function<bool(const T&)>& pred) const$/;"	f	class:glh::PListPool::List
find	shims_and_types.h	/^    const_iterator find(const T& t) const$/;"	f	struct:glh::SortedArray
find_if	shims_and_types.h	/^typename T::iterator find_if(T& container, F predicate){$/;"	f	namespace:glh
first	persistent_containers.h	/^        const T* first() const$/;"	f	class:glh::PListPool::List
first	persistent_containers.h	/^    struct KeyValue{uint32_t hash; K first; V second;};$/;"	m	struct:glh::PMapPool::KeyValue
first	stb_image.c	/^   uint8 first;$/;"	m	struct:stbi_gif_lzw_struct	file:
first_row_filter	stb_image.c	/^static uint8 first_row_filter[5] =$/;"	v	file:
firstcode	stb_image.c	/^   uint16 firstcode[16];$/;"	m	struct:__anon29	file:
firstsymbol	stb_image.c	/^   uint16 firstsymbol[16];$/;"	m	struct:__anon29	file:
fix_path_to_posix_path	iotools.cpp	/^std::string fix_path_to_posix_path(const std::string& path)$/;"	f	namespace:__anon8
fix_path_to_win32_path	iotools.cpp	/^std::string fix_path_to_win32_path(const std::string& path)$/;"	f	namespace:__anon8
flag_	glhack.h	/^        GLboolean flag_;$/;"	m	struct:glh::RenderPassSettings::DepthMask
flags	stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
flip_vertical	glh_image.cpp	/^void   flip_vertical(Image8& img)$/;"	f	namespace:glh
float2fixed	stb_image.c	1743;"	d	file:
float2int	stb_image.c	896;"	d	file:
float_to_ubyte	glh_image.h	/^inline uint8_t float_to_ubyte(float in){$/;"	f	namespace:glh
float_to_ubyte_err	glh_image.h	/^inline std::tuple<uint8_t, float> float_to_ubyte_err(float in){$/;"	f	namespace:glh
floatvalue	masp.h	/^        double floatvalue;$/;"	m	union:masp::Number::__anon17
flush_events	glbase.cpp	/^void UserInput::flush_events()$/;"	f	class:glh::UserInput
focus_context_	glh_uicontext.h	/^    FocusContext     focus_context_;$/;"	m	struct:glh::SelectionWorld
focus_gained_	glh_scenemanagement.h	/^    entity_container_t focus_gained_;$/;"	m	class:glh::FocusContext
focus_lost_	glh_scenemanagement.h	/^    entity_container_t focus_lost_;$/;"	m	class:glh::FocusContext
fold_left	shims_and_types.h	/^RES fold_left(RES res, std::function<RES(const RES& r, const typename CONT::value_type& v)> fun, const CONT& c)$/;"	f	namespace:glh
font_directory_	glh_font.h	/^    const std::string font_directory_;$/;"	m	class:glh::FontContext
font_handle_	glh_scene_extensions.h	/^    BakedFontHandle  font_handle_;$/;"	m	class:glh::GlyphPane
font_manager_	glh_scene_extensions.h	/^    FontManager*     font_manager_;$/;"	m	class:glh::SceneAssets
font_textures_	glh_scene_extensions.h	/^    std::map<std::string, Texture*> font_textures_;$/;"	m	class:glh::FontManager
fontmanager	glh_app_services.h	/^    FontManager* fontmanager(){ return fontmanager_.get(); }$/;"	f	class:glh::AppServices
fontmanager_	glh_app_services.h	/^    FontManagerPtr  fontmanager_;$/;"	m	class:glh::AppServices
fontmanager_	glh_scene_extensions.h	/^    FontManager*     fontmanager_;$/;"	m	class:glh::GlyphPane
fontmesh_	glh_scene_extensions.h	/^    DefaultMesh*     fontmesh_;$/;"	m	class:glh::GlyphPane
fontstart	stb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo
fonttexture_	glh_scene_extensions.h	/^    Texture*         fonttexture_;$/;"	m	class:glh::GlyphPane
for_Mapping	glprogramvars.h	/^    static void for_Mapping(FUN f)$/;"	f	class:glh::ShaderVar
for_pixels	glh_image.h	/^template<class IMG> void for_pixels(IMG& img, std::function<void(typename IMG::pixel_t*, int x, int y)> fun)$/;"	f	namespace:glh
foreach	shims_and_types.h	/^void foreach(Container& c, Function& f)$/;"	f	namespace:glh
foreach_value	shims_and_types.h	/^void foreach_value(Container& c, Function& f)$/;"	f	namespace:glh
foreach_value	shims_and_types.h	/^void foreach_value(MapClass& map, std::function<void(typename MapClass::mapped_type& t)> f)$/;"	f	namespace:glh
format	gltexture.h	/^    InternalFormat format;$/;"	m	class:glh::TextureType
format_string	masp.cpp	/^    std::string format_string(const char* begin, const char* end)$/;"	f	class:masp::ValueParser
fragment_handle	glhack.cpp	/^    GLuint fragment_handle;$/;"	m	class:glh::ShaderProgram	file:
fragment_shader	glhack.cpp	/^    std::string fragment_shader;$/;"	m	class:glh::ShaderProgram	file:
free_chunks	persistent_containers.h	/^    chunk_type* free_chunks(){return free_chunks_;}$/;"	f	class:glh::ChunkBox
free_chunks_	persistent_containers.h	/^    chunk_type*     free_chunks_;$/;"	m	class:glh::ChunkBox
free_floatarray	glh_image.cpp	/^    void      free_floatarray(float* ptr){if(ptr) delete [] ptr;}$/;"	f	namespace:glh::__anon5
free_texture_object	glhack.cpp	/^    void free_texture_object(GLuint handle){$/;"	f	class:glh::GraphicsManagerInt
free_uint8tarray	glh_image.cpp	/^    void      free_uint8tarray(uint8_t* ptr){if(ptr) delete [] ptr;}$/;"	f	namespace:glh::__anon4
free_value	masp.cpp	/^void free_value(Value* v)$/;"	f	namespace:masp
from_byte	conversion.c	/^static inline float from_byte(float v) {$/;"	f	file:
from_byte_table	conversion.c	/^static float from_byte_table[256];$/;"	v	file:
fsh	stb_image.c	1205;"	d	file:
ftex	stb_truetype.h	/^GLstbtt_uint ftex;$/;"	v
fullpath_	iotools.h	/^    std::string fullpath_;$/;"	m	struct:FilesystemReference
fullscreen	glbase.h	/^    bool fullscreen;$/;"	m	struct:glh::AppConfig
fun	masp.cpp	/^struct Function{PrimitiveFunction fun;};$/;"	m	struct:masp::Function	file:
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::FunWrap0_0
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::FunWrap0_1
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::FunWrap1_0
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::FunWrap1_1
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::FunWrap1_2
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::MemFunWrap0_0
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::MemFunWrap0_1
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::MemFunWrap1_0
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::MemFunWrap1_1
fun_	masp_classwrap.h	/^    funt fun_;$/;"	m	class:masp::MemFunWrap1_2
funcompare	shims_and_types.h	/^    funcompare(){}$/;"	f	struct:glh::funcompare
funcompare	shims_and_types.h	/^struct funcompare$/;"	s	namespace:glh
function	masp.h	/^        Function*    function;$/;"	m	union:masp::Value::__anon18
funt	masp_classwrap.h	/^    typedef R (CLS::*funt)(P0);$/;"	t	class:masp::MemFunWrap1_1
funt	masp_classwrap.h	/^    typedef R (CLS::*funt)(P0, P1);$/;"	t	class:masp::MemFunWrap1_2
funt	masp_classwrap.h	/^    typedef R (CLS::*funt)(void);$/;"	t	class:masp::MemFunWrap1_0
funt	masp_classwrap.h	/^    typedef std::function<R(P0)> funt;$/;"	t	class:masp::FunWrap1_1
funt	masp_classwrap.h	/^    typedef std::function<R(P0, P1)> funt;$/;"	t	class:masp::FunWrap1_2
funt	masp_classwrap.h	/^    typedef std::function<R(void)> funt;$/;"	t	class:masp::FunWrap1_0
funt	masp_classwrap.h	/^    typedef std::function<void(P0)> funt;$/;"	t	class:masp::FunWrap0_1
funt	masp_classwrap.h	/^    typedef std::function<void(void)> funt;$/;"	t	class:masp::FunWrap0_0
funt	masp_classwrap.h	/^    typedef void (CLS::*funt)(P0);$/;"	t	class:masp::MemFunWrap0_1
funt	masp_classwrap.h	/^    typedef void (CLS::*funt)(void);$/;"	t	class:masp::MemFunWrap0_0
g	math_tools.h	/^    float g;$/;"	m	struct:glh::Color
g_	glhack.h	/^        GLboolean r_;GLboolean g_; GLboolean b_; GLboolean a_;$/;"	m	struct:glh::RenderPassSettings::ColorMask
g_alignment	allocators.cpp	/^    const size_t g_alignment = 16;$/;"	m	namespace:__anon1	file:
g_app	glbase.cpp	/^glh::App*      g_app = 0;$/;"	v
g_asset_path_name	asset_manager.cpp	/^const char* g_asset_path_name = "asset_path";$/;"	m	namespace:glh	file:
g_component_max_count	glhack.cpp	/^const int g_component_max_count = INT32_MAX;$/;"	m	namespace:glh	file:
g_delimiters	masp.cpp	/^const char* g_delimiters = "(){}[];'";$/;"	m	namespace:masp	file:
g_shader_mappings	glhack.cpp	/^const ShaderMappingTokens g_shader_mappings = shader_mapping_tokens();$/;"	m	namespace:glh	file:
g_shader_types	glhack.cpp	/^const ShaderTypeTokens g_shader_types = shader_type_tokens();$/;"	m	namespace:glh	file:
gc	masp.cpp	/^    void gc()$/;"	f	class:masp::Masp::Env
gc	masp.cpp	/^void Masp::gc(){env_->gc();}$/;"	f	class:masp::Masp
gc	persistent_containers.h	/^        void gc(){pool_.gc();}$/;"	f	class:glh::PMapPool::Map
gc	persistent_containers.h	/^    void gc()$/;"	f	class:glh::PListPool
gc	persistent_containers.h	/^    void gc()$/;"	f	class:glh::PMapPool
gen_texture_object	glhack.cpp	/^    GLuint gen_texture_object(){$/;"	f	class:glh::GraphicsManagerInt
generate_transform	math_tools.h	/^Eigen::Transform<T,3, Eigen::Affine> generate_transform(Eigen::Matrix<T, 3, 1>& loc, Eigen::Quaternion<T>& rot, Eigen::Matrix<T, 3, 1>& scale)$/;"	f	namespace:glh
geometry_handle	glhack.cpp	/^    GLuint geometry_handle;$/;"	m	class:glh::ShaderProgram	file:
geometry_shader	glhack.cpp	/^    std::string geometry_shader;$/;"	m	class:glh::ShaderProgram	file:
get	glh_dynamic_graph.h	/^        void get(float& res) const {res = value_[0];}$/;"	f	struct:glh::DynamicGraph::Value
get	glh_dynamic_graph.h	/^        void get(quaternion& res) const {res = quaternion(value_.data_);}$/;"	f	struct:glh::DynamicGraph::Value
get	glh_dynamic_graph.h	/^        void get(vec2& res) const {res = value_.change_dim<2>();}$/;"	f	struct:glh::DynamicGraph::Value
get	glh_dynamic_graph.h	/^        void get(vec3& res) const {res = value_.change_dim<3>();}$/;"	f	struct:glh::DynamicGraph::Value
get	glh_dynamic_graph.h	/^        void get(vec4& res) const {res = value_.to_vec();}$/;"	f	struct:glh::DynamicGraph::Value
get	glh_mesh.cpp	/^VertexChunk& DefaultMesh::get(const ChannelType::s& s){return chunks_[s];}$/;"	f	class:glh::DefaultMesh
get	glh_scenemanagement.h	/^    Node* get(const PathArray path){$/;"	f	class:glh::SceneTree
get	glh_scenemanagement.h	/^    Node* get(int id){$/;"	f	class:glh::SceneTree
get	math_tools.h	/^    Value get(double key){$/;"	f	class:glh::Sampler1D
get	math_tools.h	/^    Value get(float key){$/;"	f	class:glh::Sampler1D
get	persistent_containers.h	/^        Ref* get(uint32_t key, uint32_t level)$/;"	f	struct:glh::PMapPool::Node
get	shims_and_types.h	/^    const T* get(){return ptr;}$/;"	f	class:glh::ConstOption
get	shims_and_types.h	/^    std::string get(const std::string& string){$/;"	f	class:glh::StringNumerator
get16	stb_image.c	/^static int get16(stbi *s)$/;"	f	file:
get16bits	math_tools.cpp	10;"	d	file:
get16bits	math_tools.cpp	13;"	d	file:
get16bits	math_tools.cpp	17;"	d	file:
get16le	stb_image.c	/^static int get16le(stbi *s)$/;"	f	file:
get32	stb_image.c	/^static uint32 get32(stbi *s)$/;"	f	file:
get32le	stb_image.c	/^static uint32 get32le(stbi *s)$/;"	f	file:
get8	stb_image.c	/^stbi_inline static int get8(stbi *s)$/;"	f	file:
get8u	stb_image.c	/^stbi_inline static uint8 get8u(stbi *s)$/;"	f	file:
get_child	glh_scenemanagement.h	/^        Node* get_child(const PathArray path){$/;"	f	class:glh::SceneTree::Node
get_child	glh_scenemanagement.h	/^        Node* get_child(const std::string& name){$/;"	f	class:glh::SceneTree::Node
get_child_by_fieldindex	persistent_containers.h	/^        Node* get_child_by_fieldindex(uint32_t parsed_index)$/;"	f	struct:glh::PMapPool::Node
get_child_by_hash_and_depth	persistent_containers.h	/^        Node* get_child_by_hash_and_depth(const uint32_t hash, const uint32_t depth)$/;"	f	struct:glh::PMapPool::Node
get_chunk_header	stb_image.c	/^static chunk get_chunk_header(stbi *s)$/;"	f	file:
get_default_mapper	glh_uicontext.h	/^    static MovementMapper get_default_mapper(App* app, const mat4& mat, SceneTree* scene, SceneTree::Node* node)$/;"	f	class:glh::UiContext
get_env	masp.cpp	/^    Map& get_env(){return *env_;}$/;"	f	class:masp::Masp::Env
get_font_char_data	glh_font.cpp	/^FontCharData* FontContext::get_font_char_data(const BakedFontHandle& handle) {$/;"	f	class:glh::FontContext
get_font_config	glh_font.h	/^inline FontConfig get_font_config(std::string name, double glyph_size){$/;"	f	namespace:glh
get_font_map	glh_font.cpp	/^Image8* FontContext::get_font_map(const BakedFontHandle& handle) {$/;"	f	class:glh::FontContext
get_font_texture	glh_scene_extensions.h	/^    Texture* get_font_texture(const BakedFontHandle& handle){$/;"	f	class:glh::FontManager
get_hash	masp.cpp	/^uint32_t Value::get_hash() const$/;"	f	class:masp::Value
get_hash32	shims_and_types.cpp	/^uint32_t get_hash32(cstring& string)$/;"	f	namespace:glh
get_hash32	shims_and_types.h	/^uint32_t get_hash32(const T& elem)$/;"	f	namespace:glh
get_id	tinythread.cpp	/^thread::id this_thread::get_id()$/;"	f	class:tthread::this_thread
get_id	tinythread.cpp	/^thread::id thread::get_id() const$/;"	f	class:tthread::thread
get_inputs	glh_dynamic_graph.h	/^        const inputs_map_t& get_inputs() const {return inputs_;}$/;"	f	struct:glh::DynamicGraph::DynamicNode
get_inputs	glh_dynamic_graph.h	/^        inputs_map_t& get_inputs(){return inputs_;}$/;"	f	struct:glh::DynamicGraph::DynamicNode
get_marker	stb_image.c	/^static uint8 get_marker(jpeg *j)$/;"	f	file:
get_mat4	glhack.cpp	/^mat4&    RenderEnvironment::get_mat4(cstring name){return mat4_[name];}$/;"	f	class:glh::RenderEnvironment
get_message	glsystem.h	/^    std::string get_message(){return msg_;}$/;"	f	class:glh::GraphicsException
get_message	masp.h	/^    std::string get_message() const {return msg_;}$/;"	f	class:masp::EvaluationException
get_message	shims_and_types.h	/^    std::string get_message(){ return msg_; }$/;"	f	class:glh::OutOfRangeException
get_new	persistent_containers.h	/^    T* get_new()$/;"	f	struct:glh::Chunk
get_new_array	persistent_containers.h	/^    T* get_new_array(const size_t count)$/;"	f	struct:glh::Chunk
get_next_index	shims_and_types.h	/^    int get_next_index(const std::string& string){$/;"	f	class:glh::StringNumerator
get_output	masp.cpp	/^std::ostream& Masp::get_output()$/;"	f	class:masp::Masp
get_params_from_image	gltexture.cpp	/^void Texture::get_params_from_image(const Image8& image)$/;"	f	class:glh::Texture
get_pixel_space_movement_mapper	glh_app_services.cpp	/^static MovementMapper get_pixel_space_movement_mapper(App* app, const mat4& view_to_world_p, SceneTree* scene, SceneTree::Node* node)$/;"	f	namespace:glh
get_scalar	glhack.cpp	/^float&   RenderEnvironment::get_scalar(cstring name){return scalar_[name];}$/;"	f	class:glh::RenderEnvironment
get_shader_variable_regex	glhack.cpp	/^std::regex get_shader_variable_regex(const ShaderMappingTokens& mappings,$/;"	f	namespace:glh
get_texture2d	glhack.cpp	/^Texture& RenderEnvironment::get_texture2d(cstring name){$/;"	f	class:glh::RenderEnvironment
get_uniform	glhack.cpp	/^    ShaderVar* get_uniform(const std::string& name, const ShaderVar::Type t){$/;"	f	class:glh::ShaderProgram
get_value	masp.cpp	/^    Value get_value()$/;"	f	class:masp::ValueParser
get_value	masp.cpp	/^const Value* get_value(Masp& m, const char* pathstr)$/;"	f	namespace:masp
get_value_number	masp.cpp	/^Number get_value_number(const Value* v)$/;"	f	namespace:masp
get_value_string	masp.cpp	/^std::string  get_value_string(const Value* v)$/;"	f	namespace:masp
get_vec4	glhack.cpp	/^vec4&    RenderEnvironment::get_vec4(cstring name){return vec4_[name];}$/;"	f	class:glh::RenderEnvironment
get_wrapped	masp_classwrap.h	/^T* get_wrapped(IObject* iobj){$/;"	f	namespace:masp
getn	stb_image.c	/^static int getn(stbi *s, stbi_uc *buffer, int n)$/;"	f	file:
gif_test	stb_image.c	/^static int gif_test(stbi *s)$/;"	f	file:
gl_format	gltexture.cpp	/^GLenum TextureType::gl_format() const {$/;"	f	class:glh::TextureType
gl_internal_format	gltexture.cpp	/^GLint TextureType::gl_internal_format() const {$/;"	f	class:glh::TextureType
gl_pixeltype	gltexture.cpp	/^GLenum TextureType::gl_pixeltype() const {$/;"	f	class:glh::TextureType
gl_target	gltexture.cpp	/^GLenum TextureType::gl_target() const {$/;"	f	class:glh::TextureType
glfw_mouse_to_glh	glbase.cpp	/^    glh::Input::MouseButton glfw_mouse_to_glh(int button)$/;"	f	namespace:__anon2
glh	annotated_result.h	/^namespace glh$/;"	n
glh	asset_manager.cpp	/^namespace glh{$/;"	n	file:
glh	asset_manager.h	/^namespace glh{$/;"	n
glh	geometry.cpp	/^namespace glh$/;"	n	file:
glh	geometry.h	/^namespace glh {$/;"	n
glh	glbase.cpp	/^namespace glh{$/;"	n	file:
glh	glbase.h	/^namespace glh {$/;"	n
glh	glbuffers.h	/^namespace glh{$/;"	n
glh	glh_app_services.cpp	/^namespace glh{$/;"	n	file:
glh	glh_app_services.h	/^namespace glh{$/;"	n
glh	glh_default_assets.cpp	/^namespace glh{$/;"	n	file:
glh	glh_default_assets.h	/^namespace glh{$/;"	n
glh	glh_dynamic_graph.cpp	/^namespace glh{$/;"	n	file:
glh	glh_dynamic_graph.h	/^namespace glh{$/;"	n
glh	glh_font.cpp	/^namespace glh{$/;"	n	file:
glh	glh_font.h	/^namespace glh{$/;"	n
glh	glh_generators.cpp	/^namespace glh {$/;"	n	file:
glh	glh_generators.h	/^namespace glh{$/;"	n
glh	glh_image.cpp	/^namespace glh{$/;"	n	file:
glh	glh_image.h	/^namespace glh{$/;"	n
glh	glh_index.cpp	/^namespace glh{$/;"	n	file:
glh	glh_index.h	/^namespace glh{$/;"	n
glh	glh_layout_tools.cpp	/^namespace glh{$/;"	n	file:
glh	glh_layout_tools.h	/^namespace glh{$/;"	n
glh	glh_mesh.cpp	/^namespace glh{$/;"	n	file:
glh	glh_mesh.h	/^namespace glh{$/;"	n
glh	glh_names.cpp	/^namespace glh{$/;"	n	file:
glh	glh_names.h	/^namespace glh{$/;"	n
glh	glh_scene_extensions.cpp	/^namespace glh{$/;"	n	file:
glh	glh_scene_extensions.h	/^namespace glh{$/;"	n
glh	glh_scene_util.cpp	/^namespace glh{$/;"	n	file:
glh	glh_scene_util.h	/^namespace glh{$/;"	n
glh	glh_scenemanagement.cpp	/^namespace glh {$/;"	n	file:
glh	glh_scenemanagement.h	/^namespace glh{$/;"	n
glh	glh_timebased_signals.cpp	/^namespace glh{$/;"	n	file:
glh	glh_timebased_signals.h	/^namespace glh{$/;"	n
glh	glh_typedefs.cpp	/^namespace glh {$/;"	n	file:
glh	glh_typedefs.h	/^namespace glh{$/;"	n
glh	glh_uicontext.cpp	/^namespace glh{$/;"	n	file:
glh	glh_uicontext.h	/^namespace glh{$/;"	n
glh	glhack.cpp	/^namespace glh$/;"	n	file:
glh	glhack.h	/^namespace glh {$/;"	n
glh	glprogramvars.cpp	/^namespace glh {$/;"	n	file:
glh	glprogramvars.h	/^namespace glh {$/;"	n
glh	glsystem.h	/^namespace glh$/;"	n
glh	gltexture.cpp	/^namespace glh{$/;"	n	file:
glh	gltexture.h	/^namespace glh{$/;"	n
glh	math_tools.h	/^namespace glh{$/;"	n
glh	persistent_containers.h	/^namespace glh{$/;"	n
glh	shims_and_types.cpp	/^namespace glh {$/;"	n	file:
glh	shims_and_types.h	/^namespace glh {$/;"	n
glh_get_log_ptr	glsystem.cpp	/^std::ostream* glh_get_log_ptr(){return &std::cout;}$/;"	f
glh_logging_active	glsystem.cpp	/^bool          glh_logging_active(){return true;}$/;"	f
glh_regex_search	glh_regex.h	11;"	d
glh_regex_search	glh_regex.h	19;"	d
glyf	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
glyph_coords_	glh_scene_extensions.h	/^    GlyphCoords glyph_coords_;$/;"	m	class:glh::TextField
glyph_node_	glh_scene_extensions.h	/^    SceneTree::Node* glyph_node_;$/;"	m	class:glh::GlyphPane
glyph_panes_	glh_scene_extensions.h	/^    std::list<GlyphPane>                                glyph_panes_;$/;"	m	class:glh::SceneAssets
glyph_size_	glh_font.h	/^    double      glyph_size_; \/\/> Size in pixels.$/;"	m	struct:glh::FontConfig
gm_	glh_scene_extensions.h	/^    GraphicsManager* gm_;$/;"	m	class:glh::FontManager
gm_	glh_scene_extensions.h	/^    GraphicsManager* gm_;$/;"	m	class:glh::GlyphPane
gm_	glh_scene_extensions.h	/^    GraphicsManager* gm_;$/;"	m	class:glh::SceneAssets
gpu_status	gltexture.h	/^    std::tuple<bool, GLuint> gpu_status() const {return std::make_tuple(on_gpu_, bound_texture_object_);}$/;"	f	class:glh::Texture
gpu_status	gltexture.h	/^    void gpu_status(bool ongpu, GLuint texture_object){on_gpu_ = ongpu; bound_texture_object_ = texture_object;}$/;"	f	class:glh::Texture
grad3	glh_generators.cpp	/^        gradient_array_t grad3;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
grad4	glh_generators.cpp	/^        gradient_array_t grad4;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
gradient_array_t	glh_generators.cpp	/^    typedef std::vector<Grad>    gradient_array_t;$/;"	t	struct:glh::SimplexNoise	file:
graph	glh_app_services.h	/^    DynamicGraph& graph(){ return graph_; }$/;"	f	class:glh::AppServices
graph_	glh_app_services.h	/^    DynamicGraph graph_; \/\/ TODO figure out if this belongs here, to assets or do we need another abstraction layer above both yet.$/;"	m	class:glh::AppServices
graph_	glh_dynamic_graph.h	/^    const graph_t&       graph_;$/;"	m	class:glh::DfsForestSort
graph_	glh_uicontext.h	/^    DynamicGraph&    graph_;$/;"	m	class:glh::UiContext
graph_list_t	glh_dynamic_graph.h	/^    typename typedef graph_t::vertex_list_t graph_list_t;$/;"	t	class:glh::DfsForestSort
graph_t	glh_dynamic_graph.h	/^    typedef AdjacencyListGraph<T>           graph_t;$/;"	t	class:glh::DfsForestSort
graphics_manager	glbase.cpp	/^GraphicsManager* App::graphics_manager(){return manager_.get();}$/;"	f	class:glh::App
graphics_manager_use_texture	glhack.cpp	/^void graphics_manager_use_texture(GraphicsManagerInt& manager, int texture_unit, Texture& t)$/;"	f	namespace:glh
grow_buffer_unsafe	stb_image.c	/^static void grow_buffer_unsafe(jpeg *j)$/;"	f	file:
h	stb_image.c	/^      int h,v;$/;"	m	struct:__anon26::__anon27	file:
h	stb_image.c	/^   int w,h;$/;"	m	struct:stbi_gif_struct	file:
h	stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon39
h2	stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon26::__anon27	file:
h2l_gamma_i	stb_image.c	/^static float h2l_gamma_i=1.0f\/2.2f, h2l_scale_i=1.0f;$/;"	v	file:
h2l_scale_i	stb_image.c	/^static float h2l_gamma_i=1.0f\/2.2f, h2l_scale_i=1.0f;$/;"	v	file:
ha	stb_image.c	/^      int hd,ha;$/;"	m	struct:__anon26::__anon27	file:
handle	win32_dirent.h	/^    HANDLE handle;                              \/* Win32 search handle *\/$/;"	m	struct:_WDIR
handle_	glbuffers.h	/^    uint32_t   handle_;$/;"	m	class:glh::BufferHandle
handle_	glhack.cpp	/^    ProgramHandle* handle_;$/;"	m	class:glh::ActiveProgram	file:
handle_	gltexture.h	/^    GLuint handle_;$/;"	m	class:glh::Texture
handle_valid	glh_font.h	/^inline bool handle_valid(BakedFontHandle& h){return h.first != "" && h.second > 0.;}$/;"	f	namespace:glh
hardware_concurrency	tinythread.cpp	/^unsigned thread::hardware_concurrency()$/;"	f	class:tthread::thread
has	glhack.h	/^    bool has(cstring& name, ShaderVar::Type type){$/;"	f	class:glh::RenderEnvironment
has	glhack.h	/^    std::pair<ShaderVar::Type, bool> has(cstring& name){$/;"	f	class:glh::RenderEnvironment
has_key	shims_and_types.h	/^bool has_key(M& map, KEY key)$/;"	f	namespace:glh
has_key	shims_and_types.h	/^bool has_key(const std::map<KEY, VAL>& map, KEY key){$/;"	f	namespace:glh
has_pair	shims_and_types.h	/^bool has_pair(const std::map<KEY, VAL>& map, const KEY& key, const VAL& expected){$/;"	f	namespace:glh
has_renderable	glh_scenemanagement.h	/^        bool has_renderable(){return renderable_ != 0;}$/;"	f	class:glh::SceneTree::Node
has_rest	persistent_containers.h	/^        bool has_rest() const {return head_ ? head_->next != 0 : false;}$/;"	f	class:glh::PListPool::List
has_uniform	glhack.cpp	/^    bool has_uniform(const std::string& name, const ShaderVar::Type t){$/;"	f	class:glh::ShaderProgram
has_vertex	glh_dynamic_graph.h	/^    vertex_id has_vertex(const V& v){$/;"	f	class:glh::AdjacencyListGraph
hash	masp.cpp	/^uint32_t ValueHash::hash(const Value& h){return h.get_hash();}$/;"	f	class:masp::ValueHash
hash	persistent_containers.h	/^    static uint32_t hash(const H& h){return get_hash32(h);}$/;"	f	class:glh::MapHash
hash	persistent_containers.h	/^    struct KeyValue{uint32_t hash; K first; V second;};$/;"	m	struct:glh::PMapPool::KeyValue
hash32	math_tools.cpp	/^uint32_t hash32(const char* data, int len)$/;"	f
hash32	math_tools.cpp	/^uint32_t hash32(const std::string& string)$/;"	f
hash32	math_tools.h	/^uint32_t hash32(const T& hashable)$/;"	f
hash_of_number	masp.cpp	/^uint32_t hash_of_number(const Number& n){return *((uint32_t*) &n);}$/;"	f	namespace:masp
hash_value	persistent_containers.h	/^        const uint32_t* hash_value()$/;"	f	struct:glh::PMapPool::Node
hd	stb_image.c	/^      int hd,ha;$/;"	m	struct:__anon26::__anon27	file:
hdr_convert	stb_image.c	/^static void hdr_convert(float *output, stbi_uc *input, int req_comp)$/;"	f	file:
hdr_gettoken	stb_image.c	/^static char *hdr_gettoken(stbi *z, char *buffer)$/;"	f	file:
hdr_load	stb_image.c	/^static float *hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
hdr_test	stb_image.c	/^static int hdr_test(stbi *s)$/;"	f	file:
hdr_to_ldr	stb_image.c	/^static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp)$/;"	f	file:
head	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
head_	glh_dynamic_graph.h	/^    ListNode*    head_;$/;"	m	struct:glh::List
head_	persistent_containers.h	/^        Node*      head_; $/;"	m	class:glh::PListPool::List
head_	shims_and_types.h	/^    Node* head_;$/;"	m	class:glh::PooledList
head_to	shims_and_types.h	/^T head_to(const T& container, const size_t index){$/;"	f	namespace:glh
heads_	glh_dynamic_graph.h	/^    list_map_t                          heads_;$/;"	m	class:glh::AdjacencyListGraph
height	glbase.h	/^    int height;$/;"	m	struct:glh::AppConfig
height	gltexture.h	/^    GLsizei height;$/;"	m	class:glh::Texture
height_	glh_image.h	/^    int      height_;$/;"	m	class:glh::Image32
height_	glh_image.h	/^    int      height_;$/;"	m	class:glh::Image8
height_of_nth_row	glh_scene_extensions.h	/^    float height_of_nth_row(int i){ return (float) (line_height_ * font_handle_.second * (i)); }$/;"	f	class:glh::GlyphPane
hhea	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
high_bit	stb_image.c	/^static int high_bit(unsigned int z)$/;"	f	file:
higher_	glh_dynamic_graph.h	/^    float higher_;$/;"	m	class:glh::ScalarRamp
hmtx	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
hours	tinythread.h	/^  typedef duration<__intmax_t, ratio<3600> > hours;                \/\/\/< Duration with the unit hours.$/;"	t	namespace:tthread::chrono
hs	stb_image.c	/^   int hs,vs;   \/\/ expansion factor in each axis$/;"	m	struct:__anon28	file:
huff_ac	stb_image.c	/^   huffman huff_ac[4];$/;"	m	struct:__anon26	file:
huff_dc	stb_image.c	/^   huffman huff_dc[4];$/;"	m	struct:__anon26	file:
huffman	stb_image.c	/^} huffman;$/;"	t	typeref:struct:__anon25	file:
i2add	shims_and_types.h	/^    Inserter2 i2add(Container& map, const typename Container::key_type& k, const typename Container::mapped_type& v)$/;"	f	struct:glh::Inserter2
i_	glh_scenemanagement.h	/^            Node::ChildContainer::iterator i_;$/;"	m	struct:glh::SceneTree::tree_iterator::Iterator
i_	masp_classwrap.h	/^    VecIterator i_; VecIterator end_;$/;"	m	class:masp::ArgWrap
iadd	shims_and_types.h	/^    Inserter1 iadd(Container& c, const V& v)$/;"	f	struct:glh::Inserter1
id	glbase.h	/^    int id;                        \/\/> Button identifier$/;"	m	class:glh::InputEvent
id	stb_image.c	/^      int id;$/;"	m	struct:__anon26::__anon27	file:
id	tinythread.h	/^    id() : mId(0) {};$/;"	f	class:tthread::thread::id
id	tinythread.h	/^    id(const id& aId) : mId(aId.mId) {};$/;"	f	class:tthread::thread::id
id	tinythread.h	/^    id(unsigned long int aId) : mId(aId) {};$/;"	f	class:tthread::thread::id
id	tinythread.h	/^class thread::id {$/;"	c	class:tthread::thread
id_	glh_scenemanagement.h	/^        int         id_;$/;"	m	class:glh::SceneTree::Node
id_generator_	glh_scenemanagement.h	/^    ObjectRoster::IdGenerator id_generator_;$/;"	m	class:glh::SceneTree
id_of_color	glh_typedefs.cpp	/^int ObjectRoster::id_of_color(const vec4& color){$/;"	f	class:glh::ObjectRoster
id_of_color	glh_typedefs.cpp	/^int ObjectRoster::id_of_color(uint8_t r, uint8_t g, uint8_t b){$/;"	f	class:glh::ObjectRoster
id_t	glh_dynamic_graph.h	/^    typename typedef graph_t::vertex_id     id_t;$/;"	t	class:glh::DfsForestSort
id_to_entity_	glh_scenemanagement.h	/^    std::map<int, SceneTree::Node*> id_to_entity_;$/;"	m	class:glh::RenderPicker
id_to_node_	glh_scenemanagement.h	/^    std::map<int, Node*> id_to_node_;$/;"	m	class:glh::SceneTree
idata	stb_image.c	/^   uint8 *idata, *expanded, *out;$/;"	m	struct:__anon32	file:
idct_block	stb_image.c	/^static void idct_block(uint8 *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)$/;"	f	file:
idgen_	glh_scenemanagement.h	/^    ObjectRoster::IdGenerator idgen_;$/;"	m	class:glh::RenderPicker
image_	gltexture.h	/^    const Image8* image_;$/;"	m	class:glh::Texture
img_buffer	stb_image.c	/^   uint8 *img_buffer, *img_buffer_end;$/;"	m	struct:__anon23	file:
img_buffer_end	stb_image.c	/^   uint8 *img_buffer, *img_buffer_end;$/;"	m	struct:__anon23	file:
img_buffer_original	stb_image.c	/^   uint8 *img_buffer_original;$/;"	m	struct:__anon23	file:
img_comp	stb_image.c	/^   } img_comp[4];$/;"	m	struct:__anon26	typeref:struct:__anon26::__anon27	file:
img_h_max	stb_image.c	/^   int img_h_max, img_v_max;$/;"	m	struct:__anon26	file:
img_mcu_h	stb_image.c	/^   int img_mcu_w, img_mcu_h;$/;"	m	struct:__anon26	file:
img_mcu_w	stb_image.c	/^   int img_mcu_w, img_mcu_h;$/;"	m	struct:__anon26	file:
img_mcu_x	stb_image.c	/^   int img_mcu_x, img_mcu_y;$/;"	m	struct:__anon26	file:
img_mcu_y	stb_image.c	/^   int img_mcu_x, img_mcu_y;$/;"	m	struct:__anon26	file:
img_n	stb_image.c	/^   int img_n, img_out_n;$/;"	m	struct:__anon23	file:
img_out_n	stb_image.c	/^   int img_n, img_out_n;$/;"	m	struct:__anon23	file:
img_v_max	stb_image.c	/^   int img_h_max, img_v_max;$/;"	m	struct:__anon26	file:
img_x	stb_image.c	/^   uint32 img_x, img_y;$/;"	m	struct:__anon23	file:
img_y	stb_image.c	/^   uint32 img_x, img_y;$/;"	m	struct:__anon23	file:
impl	glh_generators.cpp	/^    static Impl_s impl;$/;"	m	struct:glh::SimplexNoise	file:
impl	glh_generators.cpp	/^SimplexNoise::Impl_s SimplexNoise::impl;$/;"	m	class:glh::SimplexNoise	file:
in_range	math_tools.h	/^inline bool in_range(const T& a, const T& b, const T& s)$/;"	f	namespace:glh
in_range_inclusive	math_tools.h	/^template<class T> inline bool in_range_inclusive(const T value, const T begin, const T end){$/;"	f	namespace:glh
increase_dim	math_tools.h	/^Eigen::Matrix<T, N+1, 1> increase_dim(const Eigen::Matrix<T, N, 1>& v){$/;"	f	namespace:glh
increasing_	math_tools.h	/^        bool increasing_;$/;"	m	struct:glh::Range::iterator
increment_	math_tools.h	/^        T increment_;$/;"	m	struct:glh::Range::iterator
increment_	math_tools.h	/^    T increment_;$/;"	m	class:glh::Range
increment_ref	persistent_containers.h	/^        void increment_ref()$/;"	f	class:glh::PListPool::List
increment_ref	persistent_containers.h	/^        void increment_ref()$/;"	f	class:glh::PMapPool::Map
index	persistent_containers.h	/^        uint32_t index(uint32_t bitfield){return count_bits(used & (bitfield - 1));}$/;"	f	struct:glh::PMapPool::Node
indexToLocFormat	stb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo
index_	glh_font.h	/^        int index_;$/;"	m	struct:glh::textured_quad2d_t::iterator
index_array_t	glh_generators.cpp	/^    typedef std::vector<index_t> index_array_t;$/;"	t	struct:glh::SimplexNoise	file:
index_in_use	persistent_containers.h	/^        bool index_in_use(uint32_t index){return bit_is_on(used, index);}$/;"	f	struct:glh::PMapPool::Node
index_map	stb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo
index_t	glh_generators.cpp	/^    typedef int16_t              index_t;$/;"	t	struct:glh::SimplexNoise	file:
index_to_float	conversion.c	/^static float index_to_float(const unsigned short i)$/;"	f	file:
ini_func1	tinymt32.c	/^static uint32_t ini_func1(uint32_t x) {$/;"	f	file:
ini_func1	tinymt64.c	/^static uint64_t ini_func1(uint64_t x) {$/;"	f	file:
ini_func2	tinymt32.c	/^static uint32_t ini_func2(uint32_t x) {$/;"	f	file:
ini_func2	tinymt64.c	/^static uint64_t ini_func2(uint64_t x) {$/;"	f	file:
init	glbase.h	/^    AppInit   init;$/;"	m	struct:glh::AppConfig
init	glh_app_services.cpp	/^void AppServices::init(App* app, const char* config_file)$/;"	f	class:glh::AppServices
init	glh_scene_extensions.h	/^    void init(App* app, GraphicsManager* gm, FontManager* font_manager){$/;"	f	class:glh::SceneAssets
init	masp.cpp	/^    void init(const char* start, const char* end){c_ = start; end_ = end;}$/;"	f	class:masp::ValueParser
init	math_tools.h	/^    void init()$/;"	f	struct:glh::RandomRange
init	math_tools.h	/^    void init(){offset = end - start;}$/;"	f	struct:glh::RandomRange
init	math_tools.h	/^    void init(int seed)$/;"	f	struct:glh::Random
init_assets	glh_uicontext.cpp	/^void UiContext::init_assets(){$/;"	f	class:glh::UiContext
init_bufferset_from_program	glhack.cpp	/^void init_bufferset_from_program(BufferSet& bufs, ProgramHandle* h)$/;"	f	namespace:glh
init_cursor	glh_scene_extensions.h	/^    void init_cursor()$/;"	f	class:glh::GlyphPane
init_defaults	stb_image.c	/^static void init_defaults(void)$/;"	f	file:
init_font_manager	glh_app_services.cpp	/^void AppServices::init_font_manager()$/;"	f	class:glh::AppServices
init_var_lists	glhack.cpp	/^    void init_var_lists(ShaderProgram& program)$/;"	f	namespace:glh::__anon7
initialize	conversion.c	/^static void initialize(void)$/;"	f	file:
initialize	math_tools.h	/^    void initialize(){$/;"	f	struct:glh::ExplicitTransform
inputs_	glh_dynamic_graph.h	/^        inputs_map_t                 inputs_;  \/\/> sinkname, link to value to read$/;"	m	struct:glh::DynamicGraph::DynamicNode
inputs_map_t	glh_dynamic_graph.h	/^        typedef std::map<std::string, datalink_t> inputs_map_t;$/;"	t	struct:glh::DynamicGraph::DynamicNode
insert	glh_dynamic_graph.h	/^    void insert(const T& value){$/;"	f	struct:glh::List
insert	math_tools.h	/^    void insert(const Key& key, const Value& value){$/;"	f	class:glh::InterpolatingMap
insert	shims_and_types.h	/^    iterator insert(ITER ii, const T& t)$/;"	f	struct:glh::SortedArray
insert	shims_and_types.h	/^    iterator insert(const T& t)$/;"	f	struct:glh::SortedArray
insert_after	shims_and_types.h	/^void insert_after(T& container, size_t pos, const typename T::value_type& v){$/;"	f	namespace:glh
insert_before	shims_and_types.h	/^void insert_before(T& container, size_t pos, const typename T::value_type& v){$/;"	f	namespace:glh
insert_char_after	glh_scene_extensions.h	/^    void insert_char_after(const int char_pos, const int row, const char c){$/;"	f	class:glh::TextField
insert_new	shims_and_types.h	/^void insert_new(Container&c , const value_type& v){$/;"	f	namespace:glh
instantiate_tree_path	persistent_containers.h	/^    Node* instantiate_tree_path(const Node* old_root, const KeyValue* kv)$/;"	f	class:glh::PMapPool
instantiate_vertex	glh_dynamic_graph.h	/^    vertex_id instantiate_vertex(const V& v){$/;"	f	class:glh::AdjacencyListGraph
int16	stb_image.c	/^typedef   signed short  int16;$/;"	t	file:
int32	stb_image.c	/^typedef   signed int    int32;$/;"	t	file:
interaction_lock_	glh_scenemanagement.h	/^        bool        interaction_lock_; \/\/ Lock for when dragged and so on. TODO: Preferably, remove from here (UI stuff)$/;"	m	class:glh::SceneTree::Node
interpolate	math_tools.h	/^    Value interpolate(const Key& key) const {$/;"	f	class:glh::InterpolatingMap
interpolate	math_tools.h	/^    static G interpolate(const I x, const G& a, const G& b){$/;"	f	class:glh::Lerp
interpolate	math_tools.h	/^    static G interpolate(const I x, const G& a, const G& b){$/;"	f	class:glh::Smoothstep
interpolation_technique_	math_tools.h	/^    InterpolationType::t interpolation_technique_;$/;"	m	class:glh::Sampler1D
intersect	math_tools.h	/^std::tuple<Box<T,N>, bool> intersect(const Box<T,N>& a, const Box<T,N>& b)$/;"	f	namespace:glh
intersect_spans	math_tools.h	/^typename Math<T>::span_t intersect_spans(const typename Math<T>::span_t& a, const typename Math<T>::span_t& b)$/;"	f	namespace:glh
interval_range	math_tools.h	/^template<class T> inline T interval_range(const T value, const T begin, const T end){return (value - begin)\/(end - begin);}$/;"	f	namespace:glh
intvalue	masp.h	/^        int    intvalue;$/;"	m	union:masp::Number::__anon17
invalid_font_handle	glh_font.h	/^inline BakedFontHandle invalid_font_handle(){return std::make_pair(std::string(""), 0.0);}$/;"	f	namespace:glh
inverse_map	shims_and_types.h	/^    const InverseMap& inverse_map() const {return values_to_keys_;}$/;"	f	class:glh::BiMap
invert	stb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge
io	stb_image.c	/^   stbi_io_callbacks io;$/;"	m	struct:__anon23	file:
io_user_data	stb_image.c	/^   void *io_user_data;$/;"	m	struct:__anon23	file:
is	glh_uicontext.h	/^        bool is(const Event& event)const { return event_ == event.event_ && button_ == event.button_; }$/;"	f	struct:glh::UiContext::Event
is	glh_uicontext.h	/^        bool is(const t& event) const { return event_ == event; }$/;"	f	struct:glh::UiContext::Event
is	masp.cpp	/^    bool is(char ch){return *c_ == ch;}$/;"	f	class:masp::ValueParser
is	masp.h	/^    bool is(const Type t) const{return type == t;}$/;"	f	class:masp::Value
is_alloced_	annotated_result.h	/^    bool is_alloced_;$/;"	m	class:glh::AnnotatedResult
is_application	masp.cpp	/^bool is_application(const Value& v){return v.is(LIST);}$/;"	f	namespace:masp::__anon15
is_assignment	masp.cpp	/^bool is_assignment(const Value& v){ return is_tagged_list(v,"def");}$/;"	f	namespace:masp::__anon15
is_begin	masp.cpp	/^bool is_begin(const Value& v){return is_tagged_list(v, "begin");} $/;"	f	namespace:masp::__anon15
is_compound_procedure	masp.cpp	/^bool is_compound_procedure(const Value& v){return is_tagged_list(v, "procedure");}$/;"	f	namespace:masp::__anon15
is_cond	masp.cpp	/^bool is_cond(const Value& v){return is_tagged_list(v, "cond");} $/;"	f	namespace:masp::__anon15
is_delimiter	masp.cpp	/^static bool is_delimiter(const char c)$/;"	f	namespace:masp
is_digit	masp.cpp	/^static inline bool is_digit(char c){return isdigit(c) != 0;}$/;"	f	namespace:masp
is_done_	glh_timebased_signals.h	/^        bool is_done_;$/;"	m	class:glh::DynamicSystem::Event
is_else	masp.cpp	/^bool is_else(const Value& v){return is_tagged_list(v, "else");}$/;"	f	namespace:masp::__anon15
is_focused	glh_dynamic_graph.h	/^    bool is_focused(){$/;"	f	class:glh::NodeFocusState
is_full	persistent_containers.h	/^    bool is_full(){return (used_elements == 0xffffffff);}$/;"	f	struct:glh::Chunk
is_function_assignment	masp.cpp	/^bool is_function_assignment(const Value& v){ return is_tagged_list(v,"defn");}$/;"	f	namespace:masp::__anon15
is_if	masp.cpp	/^bool is_if(const Value& v){return is_tagged_list(v, "if");} $/;"	f	namespace:masp::__anon15
is_in_string	masp.cpp	/^static bool is_in_string(const char c, const char* str)$/;"	f	namespace:masp
is_lambda	masp.cpp	/^bool is_lambda(const Value& v){return is_tagged_list(v, "fn");} $/;"	f	namespace:masp::__anon15
is_left_mouse_button_activated	glh_uicontext.h	/^    bool is_left_mouse_button_activated(const Event& e){ return e.is(Event(Event::ButtonActivated, Input::any_button(Input::Mouse, Input::MouseButton::LeftButton))); }$/;"	f	class:glh::UiContext
is_left_mouse_button_deactivated	glh_uicontext.h	/^    bool is_left_mouse_button_deactivated(const Event& e){ return e.is(Event(Event::ButtonDeactivated, Input::any_button(Input::Mouse, Input::MouseButton::LeftButton))); }$/;"	f	class:glh::UiContext
is_left_mouse_button_down	glh_uicontext.h	/^    bool is_left_mouse_button_down(){$/;"	f	class:glh::UiContext
is_nil	masp.cpp	/^bool Value::is_nil() const {return type == NIL;}$/;"	f	class:masp::Value
is_not	shims_and_types.h	/^bool is_not(const T& val, const T& ref0){return val != ref0;}$/;"	f	namespace:glh
is_open	iotools.cpp	/^bool InputFile::is_open(){if(file_) return true; else return false;}$/;"	f	class:InputFile
is_open	iotools.cpp	/^bool OutputFile::is_open(){if(file_) return true; else return false;}$/;"	f	class:OutputFile
is_primitive_procedure	masp.cpp	/^bool is_primitive_procedure(const Value& v){return v.type == FUNCTION;}$/;"	f	namespace:masp::__anon15
is_quoted	masp.cpp	/^bool is_quoted(const Value& v){ return is_tagged_list(v,"quote");}$/;"	f	namespace:masp::__anon15
is_reassignment	masp.cpp	/^bool is_reassignment(const Value& v){ return is_tagged_list(v,"set");}$/;"	f	namespace:masp::__anon15
is_self_evaluating	masp.cpp	/^bool is_self_evaluating(const Value& v)$/;"	f	namespace:masp::__anon15
is_space	masp.cpp	/^static inline bool is_space(char c){return (isspace(c) != 0) || (c == ',');}$/;"	f	namespace:masp
is_str	masp.cpp	/^bool Value::is_str(const char* str){return glh::any_of(type, STRING, SYMBOL) && strcmp(value.string->c_str(), str) == 0;}$/;"	f	class:masp::Value
is_tagged_list	masp.cpp	/^bool is_tagged_list(const Value& v, const char* symname)$/;"	f	namespace:masp::__anon15
is_true	masp.cpp	/^bool is_true(const Value& v)$/;"	f	namespace:masp::__anon15
is_truthy	glh_dynamic_graph.h	/^        static bool is_truthy(float f){return f > 0.9999f;}$/;"	f	struct:glh::DynamicGraph::Value
is_valid	shims_and_types.h	/^    bool is_valid() const {return ptr != 0;}$/;"	f	class:glh::ConstOption
items	glh_uicontext.h	/^    RenderPass& items(){ return render_pass_; }$/;"	f	struct:glh::SelectionWorld
iter	persistent_containers.h	/^        typename KeyValueList::iterator iter;$/;"	m	struct:glh::PMapPool::NodeValueIterator
iter	persistent_containers.h	/^        typename Node::Ref* iter;  $/;"	m	struct:glh::PMapPool::NodeChildIterator
iter_stack	persistent_containers.h	/^        FixedStack<NodeChildIterator, 8> iter_stack; \/\/Max tree depth is 7 plus root.$/;"	m	class:glh::PMapPool::node_iterator
iterating	persistent_containers.h	/^        bool iterating;$/;"	m	struct:glh::PMapPool::NodeChildIterator
iteration_ongoing	persistent_containers.h	/^        bool      iteration_ongoing;$/;"	m	struct:glh::PMapPool::NodeValueIterator
iterator	glh_dynamic_graph.h	/^        iterator(ListNode* current):current_(current){}$/;"	f	struct:glh::List::iterator
iterator	glh_dynamic_graph.h	/^    struct iterator{$/;"	s	struct:glh::List
iterator	glh_font.h	/^        iterator(textured_quad2d_t& q):iterator(q, 0){}$/;"	f	struct:glh::textured_quad2d_t::iterator
iterator	glh_font.h	/^        iterator(textured_quad2d_t& q, int index):quad_(q), index_(index){}$/;"	f	struct:glh::textured_quad2d_t::iterator
iterator	glh_font.h	/^    struct iterator{$/;"	s	struct:glh::textured_quad2d_t
iterator	glh_scenemanagement.h	/^    typedef tree_iterator iterator;$/;"	t	class:glh::SceneTree
iterator	math_tools.h	/^        iterator(T val, T increment):current_(val), increment_(increment){$/;"	f	struct:glh::Range::iterator
iterator	math_tools.h	/^    struct iterator {$/;"	s	class:glh::Range
iterator	persistent_containers.h	/^            iterator():node(0){}$/;"	f	struct:glh::PListPool::List::iterator
iterator	persistent_containers.h	/^            iterator(Node* n):node(n){}$/;"	f	struct:glh::PListPool::List::iterator
iterator	persistent_containers.h	/^        struct iterator$/;"	s	class:glh::PListPool::List
iterator	persistent_containers.h	/^        typedef node_iterator iterator;$/;"	t	class:glh::PMapPool::Map
iterator	persistent_containers.h	/^    typedef typename std::list<chunk_type>::iterator iterator;$/;"	t	class:glh::ChunkBox
iterator	shims_and_types.h	/^        iterator():n(nullptr){}$/;"	f	struct:glh::PooledList::iterator
iterator	shims_and_types.h	/^        iterator(Node* node):n(node){}$/;"	f	struct:glh::PooledList::iterator
iterator	shims_and_types.h	/^        iterator(value_type* v):cur_(v){}$/;"	f	struct:glh::ArenaQueue::iterator
iterator	shims_and_types.h	/^    struct iterator$/;"	s	class:glh::PooledList
iterator	shims_and_types.h	/^    struct iterator{$/;"	s	class:glh::ArenaQueue
iterator	shims_and_types.h	/^    typedef T* iterator;$/;"	t	class:glh::AlignedArray
iterator	shims_and_types.h	/^    typedef typename Container::iterator        iterator;$/;"	t	struct:glh::SortedArray
iterator	shims_and_types.h	/^    typedef typename DataContainer::iterator iterator;$/;"	t	class:glh::Pool
iterator	shims_and_types.h	/^    typedef typename Map::iterator iterator;$/;"	t	class:glh::BiMap
iterator_range_length	shims_and_types.h	/^    size_t iterator_range_length(I i, I end)$/;"	f	namespace:glh
join	shims_and_types.h	/^Cont join(const Cont& c0, const Cont& c1){return append(c0, c1);}$/;"	f	namespace:glh
join	shims_and_types.h	/^Cont join(const Cont& c0, const Cont& c1, const Cont& c2){return append(append(c0, c1), c2);}$/;"	f	namespace:glh
join	shims_and_types.h	/^Cont join(const Cont& c0, const Cont& c1, const Cont& c2, const Cont& c3){return append(append(append(c0, c1), c2),c3);}$/;"	f	namespace:glh
join	tinythread.cpp	/^void thread::join()$/;"	f	class:tthread::thread
joinable	tinythread.cpp	/^bool thread::joinable() const$/;"	f	class:tthread::thread
jpeg	stb_image.c	/^} jpeg;$/;"	t	typeref:struct:__anon26	file:
k_	shims_and_types.h	/^        const Key& k_;$/;"	m	struct:glh::BiMap::ValueInserter
kahan_average	math_tools.h	/^template<class T, int N> inline T kahan_average(const std::array<T,N>& numbers){$/;"	f	namespace:glh
kahan_sum	math_tools.h	/^template<class T> inline T kahan_sum(const T& numbers){$/;"	f	namespace:glh
kern	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
key	glbase.h	/^    static InputEvent key(const int id, const Input::ButtonState s){return InputEvent(Key, s,id);}$/;"	f	class:glh::InputEvent
key_callbacks	glbase.h	/^    SortedArray<KeyCallback, funcompare<KeyCallback>>               key_callbacks;$/;"	m	class:glh::UserInput
key_t	math_tools.h	/^    typedef Key                 key_t;$/;"	t	class:glh::InterpolatingMap
key_to_char	glh_scene_extensions.cpp	/^char key_to_char(int key, Modifiers modifiers){$/;"	f	namespace:glh
key_to_movement	glh_scene_extensions.cpp	/^Movement key_to_movement(int key){$/;"	f	namespace:glh
key_type	persistent_containers.h	/^        typedef K key_type;$/;"	t	class:glh::PMapPool::Map
key_type	shims_and_types.h	/^    typedef Key key_type;$/;"	t	class:glh::BiMap
key_type	shims_and_types.h	/^    typedef T key_type;$/;"	t	class:glh::Pool
key_type	shims_and_types.h	/^    typedef T key_type;$/;"	t	struct:glh::SortedArray
keyboard_callback	glh_uicontext.h	/^    void keyboard_callback(int key, const Input::ButtonState& s)$/;"	f	class:glh::UiContext
keys_to_values_	shims_and_types.h	/^    Map        keys_to_values_;$/;"	m	class:glh::BiMap
keyvalue	persistent_containers.h	/^            const KeyValue*     keyvalue;$/;"	m	union:glh::PMapPool::Node::__anon20
keyvalue	persistent_containers.h	/^        const KeyValue* keyvalue;$/;"	m	struct:glh::PMapPool::NodeValueIterator
keyvalue_chunk	persistent_containers.h	/^    typedef Chunk<KeyValue>  keyvalue_chunk;$/;"	t	class:glh::PMapPool
keyvalue_chunk_box	persistent_containers.h	/^    typedef ChunkBox<KeyValue>  keyvalue_chunk_box;$/;"	t	class:glh::PMapPool
keyvalue_chunks_	persistent_containers.h	/^    keyvalue_chunk_box keyvalue_chunks_;$/;"	m	class:glh::PMapPool
keyvalue_match_get	persistent_containers.h	/^    static const V* keyvalue_match_get(const KeyValue& kv, const K& key, const uint32_t hash) $/;"	f	class:glh::PMapPool
kill	persistent_containers.h	/^    void kill()$/;"	f	class:glh::PListPool
kill	persistent_containers.h	/^    void kill()$/;"	f	class:glh::PMapPool
l2h_gamma	stb_image.c	/^static float l2h_gamma=2.2f, l2h_scale=1.0f;$/;"	v	file:
l2h_scale	stb_image.c	/^static float l2h_gamma=2.2f, l2h_scale=1.0f;$/;"	v	file:
last	glh_font.h	/^    row_coords_t& last(){ return coords_.back(); }$/;"	f	struct:glh::GlyphCoords
last	glh_scene_extensions.h	/^    TextLine& last(){$/;"	f	class:glh::TextField
last_is	shims_and_types.h	/^bool last_is(const Container& c, const value_type& v){$/;"	f	namespace:glh
last_quad	glh_font.h	/^    textured_quad2d_t& last_quad(){$/;"	f	struct:glh::GlyphCoords
last_quote_of_string	masp.cpp	/^static const char* last_quote_of_string(const char* begin, const char* end)$/;"	f	namespace:masp
ldr_to_hdr	stb_image.c	/^static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp)$/;"	f	file:
length	shims_and_types.h	/^    int length(){return string.size();}$/;"	f	struct:glh::TextLine
length	stb_image.c	/^   uint32 length;$/;"	m	struct:__anon31	file:
length_base	stb_image.c	/^static int length_base[31] = {$/;"	v	file:
length_extra	stb_image.c	/^static int length_extra[31]= $/;"	v	file:
lerp	math_tools.h	/^template<class I, class G> inline G lerp(const I x, const G& a, const G& b){return a + x * (b - a);}$/;"	f	namespace:glh
level_	shims_and_types.h	/^    size_t level_;$/;"	m	class:glh::FixedStack
lflags	stb_image.c	/^   int lflags;$/;"	m	struct:stbi_gif_struct	file:
limit_to_valid_visual_row_indices	glh_scene_extensions.h	/^    vec2i limit_to_valid_visual_row_indices(const vec2i& ind){$/;"	f	class:glh::GlyphPane
line	masp.cpp	/^    int line;$/;"	m	struct:masp::ScopeError	file:
line0	stb_image.c	/^   uint8 *line0,*line1;$/;"	m	struct:__anon28	file:
line1	stb_image.c	/^   uint8 *line0,*line1;$/;"	m	struct:__anon28	file:
line_height_	glh_scene_extensions.h	/^    double           line_height_; \/\/ Multiple of font height$/;"	m	class:glh::GlyphPane
line_height_	glh_scene_extensions.h	/^    float line_height_; \/* Multiples of font size. *\/$/;"	m	class:glh::TextField
line_number	shims_and_types.h	/^    int         line_number;$/;"	m	struct:glh::TextLine
line_size	stb_image.c	/^   int line_size;$/;"	m	struct:stbi_gif_struct	file:
linebuf	stb_image.c	/^      uint8 *linebuf;$/;"	m	struct:__anon26::__anon27	file:
link_node_id	glh_dynamic_graph.h	/^    static const node_id_t& link_node_id(datalink_t& link){return std::get<0>(link);}$/;"	f	class:glh::DynamicGraph
link_var_id	glh_dynamic_graph.h	/^    static const var_id_t&  link_var_id(datalink_t& link){return std::get<1>(link);}$/;"	f	class:glh::DynamicGraph
link_varptr	glh_dynamic_graph.h	/^    static constvalue_t_ptr&  link_varptr(datalink_t& link){return std::get<2>(link);}$/;"	f	class:glh::DynamicGraph
linker	glh_dynamic_graph.h	/^    static std::function<void(DynamicNodeRef, const DynamicGraph::var_id_t&, DynamicNodeRef, const DynamicGraph::var_id_t&)> linker(glh::DynamicGraph& graph){$/;"	f	struct:glh::DynamicNodeRef
list	masp.h	/^        List*        list;$/;"	m	union:masp::Value::__anon18
list	shims_and_types.h	/^std::list<T> list(const T& p0)$/;"	f	namespace:glh
list	shims_and_types.h	/^std::list<T> list(const T& p0, const T& p1)$/;"	f	namespace:glh
list	shims_and_types.h	/^std::list<T> list(const T& p0, const T& p1,  const T& p2)$/;"	f	namespace:glh
list	shims_and_types.h	/^std::list<T> list(const T& p0, const T& p1, const T& p2, const T& p3)$/;"	f	namespace:glh
list_decompose	masp.cpp	/^void list_decompose(const List& l, const Value** first, const Value** second, const Value** third, const Value** fourth)$/;"	f	namespace:masp::__anon15
list_dir	iotools.cpp	/^std::vector<FilesystemReference> list_dir(const char* path)$/;"	f
list_fonts	glh_font.cpp	/^std::list<std::string> FontContext::list_fonts() const{$/;"	f	class:glh::FontContext
list_increment_references	masp.cpp	/^void list_increment_references(List& list)$/;"	f	namespace:masp::__anon14
list_map_t	glh_dynamic_graph.h	/^    typedef std::map<vertex_id, vertex_list_t> list_map_t;$/;"	t	class:glh::AdjacencyListGraph
list_pool_	masp.cpp	/^    ListPool             list_pool_;$/;"	m	class:masp::Masp::Env	file:
live_count_	shims_and_types.h	/^    size_t live_count_;$/;"	m	class:glh::Pool
live_size_bytes	masp.cpp	/^    size_t live_size_bytes()$/;"	f	class:masp::Masp::Env
live_size_bytes	masp.cpp	/^size_t Masp::live_size_bytes(){return env_->live_size_bytes();}$/;"	f	class:masp::Masp
live_size_bytes	persistent_containers.h	/^    size_t live_size_bytes() const {return sizeof(T) * count_bits(used_elements);}$/;"	f	struct:glh::Chunk
live_size_bytes	persistent_containers.h	/^    size_t live_size_bytes() const$/;"	f	class:glh::ChunkBox
live_size_bytes	persistent_containers.h	/^    size_t live_size_bytes()$/;"	f	class:glh::PListPool
live_size_bytes	persistent_containers.h	/^    size_t live_size_bytes()$/;"	f	class:glh::PMapPool
load_default_programs_glsl150	glh_default_assets.cpp	/^void load_default_programs_glsl150(GraphicsManager* gm){$/;"	f	namespace:glh
load_defaults	glh_mesh.cpp	/^void DefaultMesh::load_defaults(DefaultMesh& d)$/;"	f	class:glh::DefaultMesh
load_image	glh_image.cpp	/^Image8 load_image(const char* path)$/;"	f	namespace:glh
load_jpeg_image	stb_image.c	/^static uint8 *load_jpeg_image(jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)$/;"	f	file:
load_masp_unsafe_extensions	masp_extensions.cpp	/^void load_masp_unsafe_extensions(masp::Masp& m)$/;"	f	namespace:masp
load_screenquad	glh_scene_util.cpp	/^void load_screenquad(vec2 size, glh::DefaultMesh& mesh)$/;"	f	namespace:glh
loca	stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
local_assert	masp.cpp	/^void local_assert(const char* msg)$/;"	f	namespace:__anon13
local_bounds_AAB_	glh_scenemanagement.h	/^        Box3f local_bounds_AAB_;$/;"	m	class:glh::SceneTree::Node
local_key_callback	glbase.cpp	/^    extern "C" void GLFWCALL local_key_callback(int keyid, int action)$/;"	f	namespace:__anon2
local_mouse_pos	glbase.cpp	/^    void local_mouse_pos(int x, int y){g_app->user_input().mouse[0] = x; g_app->user_input().mouse[1] = y;}$/;"	f	namespace:__anon2
local_mouse_wheel	glbase.cpp	/^    void local_mouse_wheel(int pos){g_app->user_input().mouse_wheel = pos;}$/;"	f	namespace:__anon2
local_mousebutton_callback	glbase.cpp	/^    extern "C" void GLFWCALL local_mousebutton_callback(int glfw_button, int action)$/;"	f	namespace:__anon2
local_mouseposition_callback	glbase.cpp	/^    extern "C" void GLFWCALL local_mouseposition_callback(int x, int y)$/;"	f	namespace:__anon2
local_mousewheel_callback	glbase.cpp	/^    extern "C" void GLFWCALL local_mousewheel_callback(int pos)$/;"	f	namespace:__anon2
local_push_event	glbase.cpp	/^    void local_push_event(const glh::InputEvent& e){g_app->user_input().push_event(e);}$/;"	f	namespace:__anon2
local_to_world_	glh_scenemanagement.h	/^        mat4  local_to_world_;$/;"	m	class:glh::SceneTree::Node
local_windows_resize_callback	glbase.cpp	/^    extern "C" void GLFWCALL local_windows_resize_callback(int width, int height)$/;"	f	namespace:__anon2
lock	fast_mutex.h	/^    inline void lock()$/;"	f	class:tthread::fast_mutex
lock	tinythread.h	/^    inline void lock()$/;"	f	class:tthread::mutex
lock	tinythread.h	/^    inline void lock()$/;"	f	class:tthread::recursive_mutex
lock_guard	tinythread.h	/^    explicit lock_guard(mutex_type &aMutex)$/;"	f	class:tthread::lock_guard
lock_guard	tinythread.h	/^    lock_guard() : mMutex(0) {}$/;"	f	class:tthread::lock_guard
lock_guard	tinythread.h	/^class lock_guard {$/;"	c	namespace:tthread
log_program_error	glhack.cpp	/^    void log_program_error(cstring& name, GLuint handle){log_shader_program_error(name, handle, Program);}$/;"	f	namespace:glh::__anon7
log_shader_error	glhack.cpp	/^    void log_shader_error(cstring& name, GLuint handle){log_shader_program_error(name, handle, Shader);}$/;"	f	namespace:glh::__anon7
log_shader_program_error	glhack.cpp	/^    void log_shader_program_error(cstring& name, GLuint handle, Compilable comp)$/;"	f	namespace:glh::__anon7
lower_	glh_dynamic_graph.h	/^    float lower_;$/;"	m	class:glh::ScalarRamp
lowest_unset_bit	math_tools.h	/^inline const uint32_t lowest_unset_bit(uint32_t field)$/;"	f	namespace:glh
lpal	stb_image.c	/^   uint8 lpal[256][4];$/;"	m	struct:stbi_gif_struct	file:
mAlreadyLocked	tinythread.h	/^    bool mAlreadyLocked;$/;"	m	class:tthread::mutex
mArg	tinythread.cpp	/^  void * mArg;               \/\/\/< Function argument for the thread function.$/;"	m	struct:tthread::_thread_start_info	file:
mDataMutex	tinythread.h	/^    mutable mutex mDataMutex;     \/\/\/< Serializer for access to the thread private data.$/;"	m	class:tthread::thread
mEvents	tinythread.h	/^    HANDLE mEvents[2];                  \/\/\/< Signal and broadcast event HANDLEs.$/;"	m	class:tthread::condition_variable
mFunction	tinythread.cpp	/^  void (*mFunction)(void *); \/\/\/< Pointer to the function to be executed.$/;"	m	struct:tthread::_thread_start_info	file:
mHandle	fast_mutex.h	/^    CRITICAL_SECTION mHandle;$/;"	m	class:tthread::fast_mutex
mHandle	fast_mutex.h	/^    pthread_mutex_t mHandle;$/;"	m	class:tthread::fast_mutex
mHandle	tinythread.h	/^    CRITICAL_SECTION mHandle;$/;"	m	class:tthread::mutex
mHandle	tinythread.h	/^    CRITICAL_SECTION mHandle;$/;"	m	class:tthread::recursive_mutex
mHandle	tinythread.h	/^    native_handle_type mHandle;   \/\/\/< Thread handle.$/;"	m	class:tthread::thread
mId	tinythread.h	/^    unsigned long int mId;$/;"	m	class:tthread::thread::id
mLock	fast_mutex.h	/^    int mLock;$/;"	m	class:tthread::fast_mutex
mMutex	tinythread.h	/^    mutex_type * mMutex;$/;"	m	class:tthread::lock_guard
mNotAThread	tinythread.h	/^    bool mNotAThread;             \/\/\/< True if this object is not a thread of execution.$/;"	m	class:tthread::thread
mThread	tinythread.cpp	/^  thread * mThread;          \/\/\/< Pointer to the thread object.$/;"	m	struct:tthread::_thread_start_info	file:
mWaitersCount	tinythread.h	/^    unsigned int mWaitersCount;         \/\/\/< Count of the number of waiters.$/;"	m	class:tthread::condition_variable
mWaitersCountLock	tinythread.h	/^    CRITICAL_SECTION mWaitersCountLock; \/\/\/< Serialize access to mWaitersCount.$/;"	m	class:tthread::condition_variable
mWin32ThreadID	tinythread.h	/^    unsigned int mWin32ThreadID;  \/\/\/< Unique thread ID (filled out by _beginthreadex).$/;"	m	class:tthread::thread
m_next	glh_typedefs.h	/^        int             m_next;$/;"	m	class:glh::ObjectRoster::IdGenerator
m_unused	glh_typedefs.h	/^        std::stack<int> m_unused;$/;"	m	class:glh::ObjectRoster::IdGenerator
main	stb_truetype.h	/^int main(int argc, char **argv)$/;"	f
make	masp.h	/^    static Number make(double f){Number n; n.set(f); return n;}$/;"	f	struct:masp::Number
make	masp.h	/^    static Number make(int i){Number n; n.set(i); return n;}$/;"	f	struct:masp::Number
make_InputFile	masp_extensions.cpp	/^masp::Value make_InputFile(Masp& m, Vector& args, Map& env){$/;"	f	namespace:masp
make_OutputFile	masp_extensions.cpp	/^masp::Value make_OutputFile(masp::Masp& m, masp::Vector& args, masp::Map& env){$/;"	f	namespace:masp
make_OutputFileApp	masp_extensions.cpp	/^masp::Value make_OutputFileApp(masp::Masp& m, masp::Vector& args, masp::Map& env){$/;"	f	namespace:masp
make_active	glhack.cpp	/^    ActiveProgram GraphicsManagerInt::make_active(ProgramHandle* handle){$/;"	f	class:glh::GraphicsManagerInt::GraphicsManagerInt
make_asset_manager	asset_manager.cpp	/^std::shared_ptr<AssetManager> make_asset_manager(const char* config_file)$/;"	f	namespace:glh
make_box2	math_tools.h	/^Box<T, 2> make_box2(T xlow, T ylow, T xhigh, T yhigh){return Box<T, 2>(Box<T, 2>::vec_t(xlow, ylow), Box<T, 2>::vec_t(xhigh, yhigh));}$/;"	f	namespace:glh
make_graphics_manager	glhack.cpp	/^GraphicsManager* make_graphics_manager()$/;"	f	namespace:glh
make_obj_id	glh_typedefs.h	/^inline obj_id make_obj_id(EntityType::t type, obj_key k){$/;"	f	namespace:glh
make_range	math_tools.h	/^Range<T> make_range(T begin, T end){return Range<T>(begin, end);}$/;"	f	namespace:glh
make_text_line	shims_and_types.cpp	/^TextLine make_text_line(const char* buffer, int begin, int end, int line)$/;"	f	namespace:glh
make_value_boolean	masp.cpp	/^Value make_value_boolean(bool b)$/;"	f	namespace:masp
make_value_function	masp.cpp	/^Value make_value_function(PrimitiveFunction f)$/;"	f	namespace:masp
make_value_list	masp.cpp	/^Value make_value_list(Masp& m)$/;"	f	namespace:masp
make_value_list	masp.cpp	/^Value make_value_list(const List& oldlist)$/;"	f	namespace:masp
make_value_list_alloc	masp.cpp	/^Value* make_value_list_alloc(Masp& m)$/;"	f	namespace:masp
make_value_map	masp.cpp	/^Value make_value_map(Masp& m)$/;"	f	namespace:masp
make_value_map	masp.cpp	/^Value make_value_map(const Map& oldmap)$/;"	f	namespace:masp
make_value_number	masp.cpp	/^Value make_value_number(const Number& num)$/;"	f	namespace:masp
make_value_number	masp.cpp	/^Value make_value_number(double d)$/;"	f	namespace:masp
make_value_number	masp.cpp	/^Value make_value_number(int i)$/;"	f	namespace:masp
make_value_number_array	masp.cpp	/^Value make_value_number_array()$/;"	f	namespace:masp
make_value_object	masp.cpp	/^Value make_value_object(IObject* alloced_object)$/;"	f	namespace:masp
make_value_string	masp.cpp	/^Value make_value_string(const char* str)$/;"	f	namespace:masp
make_value_string	masp.cpp	/^Value make_value_string(const char* str, const char* str_end)$/;"	f	namespace:masp
make_value_string	masp.cpp	/^Value make_value_string(const std::string& str)$/;"	f	namespace:masp
make_value_symbol	masp.cpp	/^Value make_value_symbol(const char* str)$/;"	f	namespace:masp
make_value_symbol	masp.cpp	/^Value make_value_symbol(const char* str, const char* str_end)$/;"	f	namespace:masp
make_value_vector	masp.cpp	/^Value make_value_vector()$/;"	f	namespace:masp
make_value_vector	masp.cpp	/^Value make_value_vector(I begin, I end)$/;"	f	namespace:masp
make_value_vector	masp.cpp	/^Value make_value_vector(Value& v, Vector& old)$/;"	f	namespace:masp
make_value_vector	masp.cpp	/^Value make_value_vector(Vector& old, I app_begin, I app_end )$/;"	f	namespace:masp
make_value_vector	masp.cpp	/^Value make_value_vector(Vector& old, Value& v)$/;"	f	namespace:masp
manager_	glbase.h	/^    std::shared_ptr<GraphicsManager> manager_;$/;"	m	class:glh::App
manager_	glh_app_services.h	/^    AssetManagerPtr manager_;$/;"	m	class:glh::AppServices
manager_	glh_uicontext.h	/^    GraphicsManager& manager_;$/;"	m	class:glh::UiContext
manager_	glhack.cpp	/^    GraphicsManagerInt* manager_;$/;"	m	class:glh::ShaderProgram	file:
map	masp.h	/^        Map*         map;$/;"	m	union:masp::Value::__anon18
map	masp_classwrap.h	/^    Value& map(){return mapv_;}$/;"	f	class:masp::FunMap
map	shims_and_types.h	/^    const Map& map() const {return keys_to_values_;}$/;"	f	class:glh::BiMap
map_	math_tools.h	/^    map_t map_;$/;"	m	class:glh::InterpolatingMap
map_increment_references	masp.cpp	/^void map_increment_references(Map& map)$/;"	f	namespace:masp::__anon14
map_pool	masp.cpp	/^inline MapPool& map_pool(Masp& m){return m.env()->map_pool_;}$/;"	f	namespace:masp
map_pool_	masp.cpp	/^    MapPool              map_pool_;$/;"	m	class:masp::Masp::Env	file:
map_t	math_tools.h	/^    typedef std::map<Key,Value> map_t;$/;"	t	class:glh::InterpolatingMap
map_to_gpu	glbuffers.h	/^    void map_to_gpu(VertexChunk& chunk){$/;"	f	class:glh::BufferHandle
mapped_sig_	glbuffers.h	/^    BufferSignature mapped_sig_;$/;"	m	class:glh::BufferHandle
mapped_type	persistent_containers.h	/^        typedef V mapped_type;$/;"	t	class:glh::PMapPool::Map
mapped_type	shims_and_types.h	/^    typedef Value mapped_type;$/;"	t	class:glh::BiMap
mapper_gen_	glh_uicontext.h	/^    MovementMapperGen mapper_gen_;$/;"	m	class:glh::UiContext
mapping	glprogramvars.h	/^    Mapping     mapping;$/;"	m	class:glh::ShaderVar
mapv_	masp_classwrap.h	/^    Value mapv_;$/;"	m	class:masp::FunMap
margin	glh_layout_tools.h	/^    double margin;$/;"	m	struct:glh::Layout
mark_all_empty	persistent_containers.h	/^    void mark_all_empty()$/;"	f	class:glh::ChunkBox
mark_field	persistent_containers.h	/^    uint32_t mark_field; \/\/ use for garbage collection$/;"	m	struct:glh::Chunk
mark_referenced	persistent_containers.h	/^    void mark_referenced(Node* node)$/;"	f	class:glh::PListPool
mark_referenced	persistent_containers.h	/^    void mark_referenced(Node* node)$/;"	f	class:glh::PMapPool
marker	stb_image.c	/^   unsigned char  marker;      \/\/ marker seen while filling entropy buffer$/;"	m	struct:__anon26	file:
masp	masp.cpp	/^namespace masp{$/;"	n	file:
masp	masp.h	/^namespace masp{$/;"	n
masp	masp_classwrap.cpp	/^namespace masp{$/;"	n	file:
masp	masp_classwrap.h	/^namespace masp{$/;"	n
masp	masp_extensions.cpp	/^namespace masp{$/;"	n	file:
masp	masp_extensions.h	/^namespace masp{$/;"	n
masp_	masp.cpp	/^    Masp& masp_;$/;"	m	class:masp::ValueParser	file:
masp_fail	masp.cpp	/^masp_result masp_fail(const char* str){$/;"	f	namespace:masp
masp_fail	masp.cpp	/^masp_result masp_fail(const std::string& str){$/;"	f	namespace:masp
masp_result	masp.h	/^typedef glh::AnnotatedResult<ValuePtr> masp_result;$/;"	t	namespace:masp
mat1	tinymt32.h	/^    uint32_t mat1;$/;"	m	struct:TINYMT32_T
mat1	tinymt64.h	/^    uint32_t mat1;$/;"	m	struct:TINYMT64_T
mat2	tinymt32.h	/^    uint32_t mat2;$/;"	m	struct:TINYMT32_T
mat2	tinymt64.h	/^    uint32_t mat2;$/;"	m	struct:TINYMT64_T
mat4	math_tools.h	/^typedef Eigen::Matrix4f mat4;$/;"	t	namespace:glh
mat4_	glhack.h	/^    std::map<std::string, mat4, std::less<std::string>, Eigen::aligned_allocator<std::pair<std::string, mat4> >> mat4_;$/;"	m	class:glh::RenderEnvironment
match_range	masp.cpp	/^static bool match_range(const char* begin, const char* end, const char*str)$/;"	f	namespace:masp
match_string	masp.cpp	/^static bool match_string(const char* pattern, const size_t pattern_length, const char* begin, const char* end)$/;"	f	namespace:masp
material_	glh_scenemanagement.h	/^        RenderEnvironment material_; \/\/ todo, pointer or head to root env map.Use PesistentMap?$/;"	m	class:glh::SceneTree::Node
matrix	math_tools.h	/^    typename Math<T>::matrix4_t matrix(){return generate_transform<T>(position_, rotation_, scale_).matrix();}$/;"	f	struct:glh::ExplicitTransform
matrix4_t	math_tools.h	/^    typedef Eigen::Matrix<T, 4, 4> matrix4_t;$/;"	t	class:glh::Math
max	glh_font.h	/^inline vec2 max(const quad2d_coord_t& coord){$/;"	f	namespace:glh
max	math_tools.h	/^    static T max(){return std::numeric_limits<T>::max();}$/;"	f	class:glh::Math
max_	math_tools.h	/^    vec_t max_;$/;"	m	struct:glh::Box
max_id	glh_typedefs.h	/^    static const int max_id = 16777215;$/;"	m	class:glh::ObjectRoster
max_size_	shims_and_types.h	/^    size_t                  max_size_;$/;"	m	class:glh::ArenaQueue
max_x	stb_image.c	/^   int max_x, max_y;$/;"	m	struct:stbi_gif_struct	file:
max_y	stb_image.c	/^   int max_x, max_y;$/;"	m	struct:stbi_gif_struct	file:
maxcode	stb_image.c	/^   int maxcode[17];$/;"	m	struct:__anon29	file:
maxcode	stb_image.c	/^   unsigned int maxcode[18];$/;"	m	struct:__anon25	file:
maximum_	glh_dynamic_graph.h	/^    double maximum_;$/;"	m	class:glh::LimitedIncrementalValue
mesh	glhack.h	/^    DefaultMesh* mesh(){return mesh_;}$/;"	f	class:glh::FullRenderable
mesh_	glhack.h	/^    DefaultMesh*      mesh_;$/;"	m	class:glh::FullRenderable
mesh_load_quad_xy	glh_mesh.cpp	/^void mesh_load_quad_xy(vec2 low, vec2 high, glh::DefaultMesh& mesh)$/;"	f	namespace:glh
mesh_load_screenquad	glh_mesh.cpp	/^void mesh_load_screenquad(float w, float h, glh::DefaultMesh& mesh)$/;"	f	namespace:glh
mesh_load_screenquad	glh_mesh.cpp	/^void mesh_load_screenquad(glh::DefaultMesh& mesh)$/;"	f	namespace:glh
meshdata_dirty_	glhack.h	/^    bool meshdata_dirty_;$/;"	m	class:glh::FullRenderable
meshdata_on_gpu_	glhack.h	/^    bool meshdata_on_gpu_;$/;"	m	class:glh::FullRenderable
meshes_	glhack.cpp	/^    std::list<DefaultMeshPtr>               meshes_;$/;"	m	class:glh::GraphicsManagerInt	file:
message	annotated_result.h	/^    const std::string& message(){return message_;}$/;"	f	class:glh::AnnotatedResult
message_	annotated_result.h	/^    std::string message_;$/;"	m	class:glh::AnnotatedResult
microseconds	tinythread.h	/^  typedef duration<__intmax_t, ratio<1, 1000000> > microseconds;   \/\/\/< Duration with the unit microseconds.$/;"	t	namespace:tthread::chrono
milliseconds	tinythread.h	/^  typedef duration<__intmax_t, ratio<1, 1000> > milliseconds;      \/\/\/< Duration with the unit milliseconds.$/;"	t	namespace:tthread::chrono
min	glh_font.h	/^inline vec2 min(const quad2d_coord_t& coord){$/;"	f	namespace:glh
min	math_tools.h	/^    static T min(){return std::numeric_limits<T>::min();}$/;"	f	class:glh::Math
min_	math_tools.h	/^    vec_t min_;$/;"	m	struct:glh::Box
minimal_scene	glbase.cpp	/^void minimal_scene()$/;"	f	namespace:glh
minimum_	glh_dynamic_graph.h	/^    double minimum_;$/;"	m	class:glh::LimitedIncrementalValue
minrand	math_tools.h	/^inline int32_t minrand(int32_t a) {$/;"	f	namespace:glh
minrandu	math_tools.h	/^inline uint32_t minrandu(uint32_t a) {$/;"	f	namespace:glh
minutes	tinythread.h	/^  typedef duration<__intmax_t, ratio<60> > minutes;                \/\/\/< Duration with the unit minutes.$/;"	t	namespace:tthread::chrono
mouse	glbase.h	/^    vec2i          mouse;$/;"	m	class:glh::UserInput
mouse_button	glbase.h	/^    static InputEvent mouse_button(const int id, const Input::ButtonState s){return InputEvent(MouseButton, s, id);}$/;"	f	class:glh::InputEvent
mouse_button_callback	glh_uicontext.h	/^    void mouse_button_callback(int key, const glh::Input::ButtonState& s)$/;"	f	class:glh::UiContext
mouse_button_callbacks	glbase.h	/^    SortedArray<KeyCallback, funcompare<KeyCallback>>               mouse_button_callbacks;$/;"	m	class:glh::UserInput
mouse_current_	glh_uicontext.h	/^    vec2i mouse_current_;$/;"	m	class:glh::UiContext
mouse_move	glbase.h	/^    static InputEvent mouse_move(const int x, const int y){return InputEvent(MouseMove, x, y,0);}$/;"	f	class:glh::InputEvent
mouse_move	glh_uicontext.h	/^    void mouse_move(int x, int y){$/;"	f	class:glh::UiContext
mouse_move_callbacks	glbase.h	/^    SortedArray<MouseMoveCallback, funcompare<MouseMoveCallback>>   mouse_move_callbacks;$/;"	m	class:glh::UserInput
mouse_prev_	glh_uicontext.h	/^    vec2i mouse_prev_;$/;"	m	class:glh::UiContext
mouse_wheel	glbase.h	/^    int            mouse_wheel;$/;"	m	class:glh::UserInput
mouse_wheel_callbacks	glbase.h	/^    SortedArray<MouseWheelCallback, funcompare<MouseWheelCallback>> mouse_wheel_callbacks;$/;"	m	class:glh::UserInput
mouse_wheel_move	glbase.h	/^    static InputEvent mouse_wheel_move(const int x){return InputEvent(MouseWheelMove, x, 0,0);}$/;"	f	class:glh::InputEvent
move_cursor	glh_scene_extensions.cpp	/^void GlyphPane::move_cursor(Movement m){$/;"	f	class:glh::GlyphPane
move_forward	masp.cpp	/^    void move_forward(){c_ = c_ + 1;}$/;"	f	class:masp::ValueParser
move_next	persistent_containers.h	/^        bool move_next()$/;"	f	struct:glh::PMapPool::NodeChildIterator
move_next	persistent_containers.h	/^        bool move_next()$/;"	f	struct:glh::PMapPool::NodeValueIterator
movefrom	masp.cpp	/^void Value::movefrom(Value& v)$/;"	f	class:masp::Value
movement_mappers_	glh_uicontext.h	/^    std::map<int, MovementMapper> movement_mappers_; \/\/> object-id : workplane$/;"	m	class:glh::UiContext
msg_	glsystem.h	/^    std::string msg_;$/;"	m	class:glh::GraphicsException
msg_	masp.h	/^    std::string msg_;$/;"	m	class:masp::EvaluationException
msg_	shims_and_types.h	/^    std::string msg_;$/;"	m	class:glh::OutOfRangeException
mutex	tinythread.h	/^    mutex()$/;"	f	class:tthread::mutex
mutex	tinythread.h	/^class mutex {$/;"	c	namespace:tthread
mutex_type	tinythread.h	/^    typedef T mutex_type;$/;"	t	class:tthread::lock_guard
my_stbtt_initfont	stb_truetype.h	/^void my_stbtt_initfont(void)$/;"	f
my_stbtt_print	stb_truetype.h	/^void my_stbtt_print(float x, float y, char *text)$/;"	f
n	masp.cpp	/^        Number n = Number::make(0);$/;"	m	namespace:masp	file:
n	masp.cpp	/^        Number n = Number::make(0);$/;"	m	namespace:masp::__anon16	file:
n	masp.cpp	/^        Number n = Number::make(1);$/;"	v
n	shims_and_types.h	/^        Node* n;$/;"	m	struct:glh::PooledList::const_iterator
n	shims_and_types.h	/^        Node* n;$/;"	m	struct:glh::PooledList::iterator
name	glh_timebased_signals.h	/^    struct Signature{VarType type; ChannelName name;};$/;"	m	struct:glh::Animation::Signature
name	glprogramvars.h	/^    std::string name;$/;"	m	class:glh::ShaderVar
name_	glh_dynamic_graph.h	/^    std::string name_;$/;"	m	struct:glh::DynamicNodeRef
name_	glh_font.h	/^    std::string name_;$/;"	m	struct:glh::FontConfig
name_	glh_scene_extensions.h	/^    std::string      name_;$/;"	m	class:glh::GlyphPane
name_	glh_scenemanagement.h	/^        std::string name_;$/;"	m	class:glh::SceneTree::Node
name_	glh_scenemanagement.h	/^    std::string                     name_;$/;"	m	class:glh::RenderPass
name_	glh_scenemanagement.h	/^    std::string      name_;$/;"	m	class:glh::Camera
name_	glh_uicontext.h	/^    std::string      name_;$/;"	m	struct:glh::SelectionWorld
name_	glhack.cpp	/^    std::string name_;$/;"	m	class:glh::ShaderProgram	file:
name_	glhack.h	/^        const std::string& name_;$/;"	m	struct:glh::RenderEnvironment::ParamMap
name_	iotools.h	/^    std::string name_;$/;"	m	struct:FilesystemReference
nanoseconds	tinythread.h	/^  typedef duration<__intmax_t, ratio<1, 1000000000> > nanoseconds; \/\/\/< Duration with the unit nanoseconds.$/;"	t	namespace:tthread::chrono
native_handle	tinythread.h	/^    inline native_handle_type native_handle()$/;"	f	class:tthread::thread
native_handle_type	tinythread.h	/^    typedef HANDLE native_handle_type;$/;"	t	class:tthread::thread
new_active	stb_truetype.h	/^static stbtt__active_edge *new_active(stbtt__edge *e, int off_x, float start_point, void *userdata)$/;"	f
new_chunk	persistent_containers.h	/^    chunk_type* new_chunk()$/;"	f	class:glh::ChunkBox
new_id	glh_typedefs.cpp	/^int ObjectRoster::IdGenerator::new_id(){$/;"	f	class:glh::ObjectRoster::IdGenerator
new_keyvalue	persistent_containers.h	/^    KeyValue* new_keyvalue(const K& k, const V& v)$/;"	f	class:glh::PMapPool
new_list	masp.cpp	/^inline List new_list(Masp& m){return m.env()->list_pool_.new_list();}$/;"	f	namespace:masp
new_list	masp.cpp	/^inline List new_list(Masp& m, const Cont& container){return m.env()->list_pool_.new_list(container);}$/;"	f	namespace:masp
new_list	persistent_containers.h	/^    List new_list()$/;"	f	class:glh::PListPool
new_list	persistent_containers.h	/^    List new_list(const Cont& container)$/;"	f	class:glh::PListPool
new_list	persistent_containers.h	/^    List new_list(const T& a)$/;"	f	class:glh::PListPool
new_list	persistent_containers.h	/^    List new_list(const T& a, const T& b)$/;"	f	class:glh::PListPool
new_list	persistent_containers.h	/^    List new_list(const T& a, const T& b, const T& c)$/;"	f	class:glh::PListPool
new_list_alloc	masp.cpp	/^inline List* new_list_alloc(Masp& m)$/;"	f	namespace:masp
new_map	masp.cpp	/^inline Map new_map(Masp& m)$/;"	f	namespace:masp
new_map	persistent_containers.h	/^    Map new_map()$/;"	f	class:glh::PMapPool
new_map	persistent_containers.h	/^    Map new_map(const K& key, const V& value)$/;"	f	class:glh::PMapPool
new_map	persistent_containers.h	/^    Map new_map(const M& map_in)$/;"	f	class:glh::PMapPool
new_map_alloc	masp.cpp	/^inline Map* new_map_alloc(Masp& m)$/;"	f	namespace:masp
new_node	glh_dynamic_graph.h	/^        ListNode* new_node(const T& v){$/;"	f	struct:glh::List::NodeCreator
new_node	persistent_containers.h	/^    Node* new_node()$/;"	f	class:glh::PMapPool
new_node	persistent_containers.h	/^    Node* new_node(const T& data)$/;"	f	class:glh::PListPool
new_value	masp.cpp	/^Value* new_value()$/;"	f	namespace:masp
next	glh_scenemanagement.h	/^            void next(){i_++;}$/;"	f	struct:glh::SceneTree::tree_iterator::Iterator
next	masp.cpp	/^    const char* next(){return c_ + 1;}$/;"	f	class:masp::ValueParser
next	persistent_containers.h	/^        Node* next;$/;"	m	struct:glh::PListPool::Node
next	persistent_containers.h	/^    Chunk*   next;$/;"	m	struct:glh::Chunk
next	shims_and_types.h	/^        Node* next;$/;"	m	struct:glh::PooledList::Node
next	stb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge
next_	glh_dynamic_graph.h	/^        ListNode* next_;$/;"	m	struct:glh::List::ListNode
next_from_stack	glh_scenemanagement.h	/^        void next_from_stack(){$/;"	f	class:glh::SceneTree::tree_iterator
next_from_top	glh_scenemanagement.h	/^        bool next_from_top(){$/;"	f	class:glh::SceneTree::tree_iterator
node	persistent_containers.h	/^            Node* node;$/;"	m	struct:glh::PListPool::List::iterator
node	persistent_containers.h	/^            Node* node;$/;"	m	struct:glh::PMapPool::Node::Ref
node	persistent_containers.h	/^        Node* node;$/;"	m	struct:glh::PMapPool::NodeChildIterator
node	persistent_containers.h	/^        Node* node;$/;"	m	struct:glh::PMapPool::NodeValueIterator
node_	glh_dynamic_graph.h	/^    DynamicGraph::dynamic_node_ptr_t node_;$/;"	m	struct:glh::DynamicNodeRef
node_	glh_dynamic_graph.h	/^    SceneTree::Node* node_;$/;"	m	class:glh::NodeFocusState
node_	glh_dynamic_graph.h	/^    SceneTree::Node* node_;$/;"	m	class:glh::NodeReciever
node_	glh_dynamic_graph.h	/^    SceneTree::Node* node_;$/;"	m	class:glh::NodeSource
node_	glh_scenemanagement.h	/^    SceneTree::Node* node_;          \/\/ world_to_camera \/ camera_to_world$/;"	m	class:glh::Camera
node_chunk	persistent_containers.h	/^    typedef Chunk<Node>                    node_chunk;$/;"	t	class:glh::PListPool
node_chunk	persistent_containers.h	/^    typedef Chunk<Node>      node_chunk;$/;"	t	class:glh::PMapPool
node_chunk_box	persistent_containers.h	/^    typedef ChunkBox<Node>                 node_chunk_box;$/;"	t	class:glh::PListPool
node_chunk_box	persistent_containers.h	/^    typedef ChunkBox<Node>      node_chunk_box;$/;"	t	class:glh::PMapPool
node_chunks_	persistent_containers.h	/^    node_chunk_box     node_chunks_;$/;"	m	class:glh::PMapPool
node_creator_	glh_dynamic_graph.h	/^    typename vertex_list_t::NodeCreator node_creator_;$/;"	m	class:glh::AdjacencyListGraph
node_dictionary_	glh_dynamic_graph.h	/^    node_dictionary_t         node_dictionary_;$/;"	m	class:glh::DynamicGraph
node_dictionary_t	glh_dynamic_graph.h	/^    typedef std::map<node_id_t, dynamic_node_ptr_t> node_dictionary_t;$/;"	t	class:glh::DynamicGraph
node_filter_fun_t	glh_scenemanagement.h	/^    typedef std::function<bool(SceneTree::Node*)> node_filter_fun_t;$/;"	t	class:glh::RenderQueue
node_has_children	persistent_containers.h	/^        bool node_has_children;$/;"	m	struct:glh::PMapPool::NodeChildIterator
node_has_children	persistent_containers.h	/^    static bool node_has_children(Node* n) {return n->child_array != 0;}$/;"	f	class:glh::PMapPool
node_has_keyvalues	persistent_containers.h	/^    static bool node_has_keyvalues(Node* n) {return n->type != Node::EmptyNode;}$/;"	f	class:glh::PMapPool
node_id_t	glh_dynamic_graph.h	/^    typedef std::string   node_id_t;$/;"	t	class:glh::DynamicGraph
node_insert_replace_refarray	persistent_containers.h	/^    void node_insert_replace_refarray(Node* parent, Node* newnode, const uint32_t local_index, const uint32_t child_level)$/;"	f	class:glh::PMapPool
node_iterator	persistent_containers.h	/^        node_iterator(Node* node):current(0)$/;"	f	class:glh::PMapPool::node_iterator
node_iterator	persistent_containers.h	/^    class node_iterator$/;"	c	class:glh::PMapPool
node_ptr_container_t	glh_scenemanagement.h	/^    typedef ArenaQueue<SceneTree::Node*> node_ptr_container_t;$/;"	t	class:glh::RenderPicker
node_ptr_sequence_t	glh_scenemanagement.h	/^    typedef ArenaQueue<SceneTree::Node*> node_ptr_sequence_t;$/;"	t	class:glh::RenderQueue
nodes_	glh_scenemanagement.h	/^    std::deque<Node, Eigen::aligned_allocator<Node>> nodes_;$/;"	m	class:glh::SceneTree
noise	glh_generators.cpp	/^        double noise(double x, double y, double z, double w) const {$/;"	f	struct:glh::SimplexNoise::Impl_s
noise	glh_generators.cpp	/^        double noise(double xin, double yin) const {$/;"	f	struct:glh::SimplexNoise::Impl_s
noise	glh_generators.cpp	/^        double noise(double xin, double yin, double zin) const {$/;"	f	struct:glh::SimplexNoise::Impl_s
nomore	stb_image.c	/^   int            nomore;      \/\/ flag if we saw a marker so must stop$/;"	m	struct:__anon26	file:
none_of	shims_and_types.h	/^bool none_of(const T& val, const T& ref0, const T& ref1){return val != ref0 && val != ref1;}$/;"	f	namespace:glh
none_of	shims_and_types.h	/^bool none_of(const T& val, const T& ref0, const T& ref1, const T& ref2){return val != ref0 && val != ref1 && val != ref2;}$/;"	f	namespace:glh
none_of	shims_and_types.h	/^bool none_of(const T& val, const T& ref0, const T& ref1, const T& ref2, const T& ref3){return val != ref0 && val != ref1 && val != ref2 && val != ref3;}$/;"	f	namespace:glh
notify_all	tinythread.cpp	/^void condition_variable::notify_all()$/;"	f	class:tthread::condition_variable
notify_all	tinythread.h	/^    inline void notify_all()$/;"	f	class:tthread::condition_variable
notify_one	tinythread.cpp	/^void condition_variable::notify_one()$/;"	f	class:tthread::condition_variable
notify_one	tinythread.h	/^    inline void notify_one()$/;"	f	class:tthread::condition_variable
npos	glh_dynamic_graph.h	/^    static const vertex_id npos = 4294967295;$/;"	m	class:glh::AdjacencyListGraph
null_id	glh_typedefs.h	/^        static const int null_id = 0;$/;"	m	class:glh::ObjectRoster::IdGenerator
null_span	math_tools.h	/^    static span_t null_span(){return span_t(T(0), T(0));}$/;"	f	class:glh::Math
numGlyphs	stb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo
num_bits	stb_image.c	/^   int num_bits;$/;"	m	struct:__anon30	file:
number	masp.h	/^        Number       number;$/;"	m	union:masp::Value::__anon18
number_array	masp.h	/^        NumberArray* number_array;$/;"	m	union:masp::Value::__anon18
obj_id	glh_typedefs.h	/^typedef uint64_t obj_id;$/;"	t	namespace:glh
obj_id_key	glh_typedefs.h	/^inline obj_key obj_id_key(obj_id oid){$/;"	f	namespace:glh
obj_id_type	glh_typedefs.h	/^inline EntityType::t obj_id_type(obj_id oid){$/;"	f	namespace:glh
obj_key	glh_typedefs.h	/^typedef uint32_t obj_key;$/;"	t	namespace:glh
object	masp.h	/^        IObject*     object;$/;"	m	union:masp::Value::__anon18
object_data_to_list	masp_classwrap.cpp	/^Value object_data_to_list(FunMap&fmap, Value& obj, Masp& m)$/;"	f	namespace:masp
offset	math_tools.h	/^    float offset;$/;"	m	struct:glh::RandomRange
on_focus	glh_scenemanagement.h	/^        void on_focus(SceneTree::Node* e){$/;"	f	struct:glh::FocusContext::Focus
on_gpu_	glbuffers.h	/^    bool       on_gpu_;$/;"	m	class:glh::BufferHandle
on_gpu_	gltexture.h	/^    bool   on_gpu_;$/;"	m	class:glh::Texture
opendir	win32_dirent.h	/^opendir($/;"	f
operator !=	glh_dynamic_graph.h	/^        bool operator!=(const iterator& rhs){return current_ != rhs.current_;}$/;"	f	struct:glh::List::iterator
operator !=	glh_font.h	/^        bool operator!=(const iterator& i){ return index_ != i.index_; }$/;"	f	struct:glh::textured_quad2d_t::iterator
operator !=	glh_scenemanagement.h	/^        bool operator!=(const tree_iterator& other){$/;"	f	class:glh::SceneTree::tree_iterator
operator !=	math_tools.h	/^        bool operator!=(const iterator& i){$/;"	f	struct:glh::Range::iterator
operator !=	persistent_containers.h	/^            bool operator!=(const iterator& i) const {return node != i.node;}$/;"	f	struct:glh::PListPool::List::iterator
operator !=	persistent_containers.h	/^        bool operator!=(const node_iterator& i){return current != i.current;}$/;"	f	class:glh::PMapPool::node_iterator
operator !=	shims_and_types.h	/^        bool operator !=(const const_iterator& i){return n!=i.n;}$/;"	f	struct:glh::PooledList::const_iterator
operator !=	shims_and_types.h	/^        bool operator !=(const iterator& i){return n!=i.n;}$/;"	f	struct:glh::PooledList::iterator
operator !=	shims_and_types.h	/^        bool operator!=(const iterator& a){return cur_ != a.cur_;}$/;"	f	struct:glh::ArenaQueue::iterator
operator !=	tinythread.h	/^    inline friend bool operator!=(const id &aId1, const id &aId2)$/;"	f	class:tthread::thread::id
operator ()	glh_dynamic_graph.h	/^    std::vector<T> operator()(){$/;"	f	class:glh::DfsForestSort
operator ()	masp.h	/^    void operator()(Value* v){free_value(v);}$/;"	f	class:masp::ValueDeleter
operator ()	shims_and_types.h	/^    Inserter1& operator()(const typename Container::value_type& v)$/;"	f	struct:glh::Inserter1
operator ()	shims_and_types.h	/^    Inserter2& operator()(const typename Container::key_type& k, const typename Container::mapped_type& v)$/;"	f	struct:glh::Inserter2
operator ()	shims_and_types.h	/^    bool operator()(const Fun& a, const Fun& b){return &a < &b;}$/;"	f	struct:glh::funcompare
operator ()	shims_and_types.h	/^    std::string operator()(const std::string& string){return get(string);}$/;"	f	class:glh::StringNumerator
operator *	annotated_result.h	/^    T& operator*(){return *(reinterpret_cast<T*>(value_));}$/;"	f	class:glh::AnnotatedResult
operator *	glh_dynamic_graph.h	/^        T& operator*(){return current_->data_;}$/;"	f	struct:glh::List::iterator
operator *	glh_font.h	/^        pos_ref_t operator*(){ return{quad_.pos_[index_], quad_.tex_[index_]}; }$/;"	f	struct:glh::textured_quad2d_t::iterator
operator *	glh_scenemanagement.h	/^        Node* operator*(){return current_;}$/;"	f	class:glh::SceneTree::tree_iterator
operator *	math_tools.h	/^        const T& operator*(){return current_;}$/;"	f	struct:glh::Range::iterator
operator *	persistent_containers.h	/^            Node& operator*(){return *node;}$/;"	f	struct:glh::PMapPool::Node::Ref
operator *	persistent_containers.h	/^            T& operator*() {return node->data;}$/;"	f	struct:glh::PListPool::List::iterator
operator *	persistent_containers.h	/^            const T& operator*() const {return node->data;}$/;"	f	struct:glh::PListPool::List::iterator
operator *	persistent_containers.h	/^        const KeyValue& operator*(){return *current;}$/;"	f	class:glh::PMapPool::node_iterator
operator *	shims_and_types.h	/^        T& operator*(){return n->data;}$/;"	f	struct:glh::PooledList::iterator
operator *	shims_and_types.h	/^        const T& operator*(){return n->data;}$/;"	f	struct:glh::PooledList::const_iterator
operator *	shims_and_types.h	/^        value_type operator*(){return *cur_;}$/;"	f	struct:glh::ArenaQueue::iterator
operator *	shims_and_types.h	/^    const T& operator*() const {return *ptr;}$/;"	f	class:glh::ConstOption
operator *=	masp.h	/^    Number& operator*=(const Number& n)$/;"	f	struct:masp::Number
operator ++	glh_dynamic_graph.h	/^        void operator++(){current_ = current_->next_;}$/;"	f	struct:glh::List::iterator
operator ++	glh_font.h	/^        void operator++(){ index_++;}$/;"	f	struct:glh::textured_quad2d_t::iterator
operator ++	glh_scenemanagement.h	/^        void operator++(){$/;"	f	class:glh::SceneTree::tree_iterator
operator ++	math_tools.h	/^        void operator++(){current_ += increment_;}$/;"	f	struct:glh::Range::iterator
operator ++	persistent_containers.h	/^            void operator++(){if(node) node = node->next;}$/;"	f	struct:glh::PListPool::List::iterator
operator ++	persistent_containers.h	/^        void operator++(){advance();}$/;"	f	class:glh::PMapPool::node_iterator
operator ++	shims_and_types.h	/^        void operator++(){cur_++;}$/;"	f	struct:glh::ArenaQueue::iterator
operator ++	shims_and_types.h	/^        void operator++(){if(n) n = n->next;}$/;"	f	struct:glh::PooledList::const_iterator
operator ++	shims_and_types.h	/^        void operator++(){if(n) n = n->next;}$/;"	f	struct:glh::PooledList::iterator
operator +=	masp.h	/^    Number& operator+=(const Number& n)$/;"	f	struct:masp::Number
operator -=	masp.h	/^    Number& operator-=(const Number& n)$/;"	f	struct:masp::Number
operator ->	annotated_result.h	/^    T& operator->(){return *(reinterpret_cast<T*>(value_));}$/;"	f	class:glh::AnnotatedResult
operator ->	glh_dynamic_graph.h	/^        T& operator->(){return current_->data_;}$/;"	f	struct:glh::List::iterator
operator ->	glh_scenemanagement.h	/^        Node* operator->(){return current_;}$/;"	f	class:glh::SceneTree::tree_iterator
operator ->	persistent_containers.h	/^            Node& operator->(){return *node;}$/;"	f	struct:glh::PMapPool::Node::Ref
operator ->	persistent_containers.h	/^            T* operator->() {return &(node->data);}$/;"	f	struct:glh::PListPool::List::iterator
operator ->	persistent_containers.h	/^            const T* operator->() const {return &(node->data);}$/;"	f	struct:glh::PListPool::List::iterator
operator ->	persistent_containers.h	/^        const KeyValue* operator->(){return current;}$/;"	f	class:glh::PMapPool::node_iterator
operator ->	shims_and_types.h	/^    const T& operator->() const {return *ptr;}$/;"	f	class:glh::ConstOption
operator /=	masp.h	/^    Number& operator\/=(const Number& n)$/;"	f	struct:masp::Number
operator <	masp.h	/^    bool operator<(const Number& n) const$/;"	f	struct:masp::Number
operator <	tinythread.h	/^    inline friend bool operator<(const id &aId1, const id &aId2)$/;"	f	class:tthread::thread::id
operator <<	glhack.cpp	/^std::ostream& operator<<(std::ostream& os, const ShaderVar& v){$/;"	f	namespace:glh
operator <<	masp.cpp	/^std::ostream& operator<<(std::ostream& os, const Value& v){$/;"	f	namespace:masp
operator <<	masp.h	/^    friend std::ostream& operator<<(std::ostream& os, const Number& n){$/;"	f	struct:masp::Number
operator <<	shims_and_types.h	/^std::ostream & operator<< ( std::ostream & os, std::pair < T, U > const & p )$/;"	f
operator <<	shims_and_types.h	/^std::ostream& operator<<(std::ostream& os, const BiMap<T, V>& map)$/;"	f	namespace:glh
operator <<	shims_and_types.h	/^std::ostream& operator<<(std::ostream& os, const PooledList<T>& list)$/;"	f	namespace:glh
operator <<	shims_and_types.h	/^std::ostream& operator<<(std::ostream& os, const SortedArray<T>& list)$/;"	f	namespace:glh
operator <<	shims_and_types.h	/^std::ostream& operator<<(std::ostream& os, const std::list<T>& list)$/;"	f	namespace:glh
operator <<	shims_and_types.h	/^std::ostream& operator<<(std::ostream& os, const std::map<T, V>& map)$/;"	f	namespace:glh
operator <<	shims_and_types.h	/^std::ostream& operator<<(std::ostream& os, const std::pair<Key, Value>& p)$/;"	f	namespace:glh
operator <<	tinythread.h	/^    inline friend std::ostream& operator <<(std::ostream &os, const id &obj)$/;"	f	class:tthread::thread::id
operator <=	masp.h	/^    bool operator<=(const Number& n) const$/;"	f	struct:masp::Number
operator <=	tinythread.h	/^    inline friend bool operator<=(const id &aId1, const id &aId2)$/;"	f	class:tthread::thread::id
operator =	glbuffers.h	/^     VertexChunk& operator=(VertexChunk&& vc){$/;"	f	class:glh::VertexChunk
operator =	glbuffers.h	/^    BufferSignature& operator=(const BufferSignature& sig){$/;"	f	struct:glh::BufferSignature
operator =	glbuffers.h	/^    VertexChunk& operator=(const VertexChunk& vc){$/;"	f	class:glh::VertexChunk
operator =	glh_image.cpp	/^Image32& Image32::operator=(Image32&& rhs){$/;"	f	class:glh::Image32
operator =	glh_image.cpp	/^Image8& Image8::operator=(Image8&& rhs){$/;"	f	class:glh::Image8
operator =	glhack.h	/^        void operator=(Texture* t){ env_.set_texture2d(name_, t); }$/;"	f	struct:glh::RenderEnvironment::ParamMap
operator =	glhack.h	/^        void operator=(const mat4& mat){ env_.set_mat4(name_, mat); }$/;"	f	struct:glh::RenderEnvironment::ParamMap
operator =	glhack.h	/^        void operator=(const vec4& vec){ env_.set_vec4(name_, vec); }$/;"	f	struct:glh::RenderEnvironment::ParamMap
operator =	glhack.h	/^        void operator=(float f){ env_.set_scalar(name_, f); }$/;"	f	struct:glh::RenderEnvironment::ParamMap
operator =	masp.cpp	/^Value& Value::operator=(Value&& v)$/;"	f	class:masp::Value
operator =	masp.cpp	/^Value& Value::operator=(const Value& a)$/;"	f	class:masp::Value
operator =	math_tools.h	/^    ArrayN& operator=(const ArrayN& rhs){$/;"	f	struct:glh::ArrayN
operator =	math_tools.h	/^    ArrayN& operator=(const complement_t& in){$/;"	f	struct:glh::ArrayN
operator =	persistent_containers.h	/^        List& operator=(List&& list)$/;"	f	class:glh::PListPool::List
operator =	persistent_containers.h	/^        List& operator=(const List& list)$/;"	f	class:glh::PListPool::List
operator =	persistent_containers.h	/^        Map& operator=(Map&& map)$/;"	f	class:glh::PMapPool::Map
operator =	persistent_containers.h	/^        Map& operator=(const Map& map)$/;"	f	class:glh::PMapPool::Map
operator =	shims_and_types.h	/^        void operator=(const Key& k)$/;"	f	struct:glh::BiMap::KeyInserter
operator =	shims_and_types.h	/^        void operator=(const Value& v)$/;"	f	struct:glh::BiMap::ValueInserter
operator =	shims_and_types.h	/^    AlignedArray& operator=(AlignedArray&& old)$/;"	f	class:glh::AlignedArray
operator =	shims_and_types.h	/^    AlignedArray& operator=(const AlignedArray& old)$/;"	f	class:glh::AlignedArray
operator =	tinythread.h	/^    inline id & operator=(const id &aId)$/;"	f	class:tthread::thread::id
operator ==	masp.cpp	/^bool Value::operator==(const Value& v) const$/;"	f	class:masp::Value
operator ==	masp.h	/^    bool operator==(const Number& n) const{$/;"	f	struct:masp::Number
operator ==	persistent_containers.h	/^            bool operator==(const iterator& i) const {return node == i.node;}$/;"	f	struct:glh::PListPool::List::iterator
operator ==	persistent_containers.h	/^        bool operator==(const List& l) const$/;"	f	class:glh::PListPool::List
operator ==	persistent_containers.h	/^        bool operator==(const Map& m) const$/;"	f	class:glh::PMapPool::Map
operator ==	persistent_containers.h	/^        bool operator==(const node_iterator& i){return current == i.current;}$/;"	f	class:glh::PMapPool::node_iterator
operator ==	tinythread.h	/^    inline friend bool operator==(const id &aId1, const id &aId2)$/;"	f	class:tthread::thread::id
operator >	masp.h	/^    bool operator>(const Number& n) const$/;"	f	struct:masp::Number
operator >	tinythread.h	/^    inline friend bool operator>(const id &aId1, const id &aId2)$/;"	f	class:tthread::thread::id
operator >=	masp.h	/^    bool operator>=(const Number& n) const$/;"	f	struct:masp::Number
operator >=	tinythread.h	/^    inline friend bool operator>=(const id &aId1, const id &aId2)$/;"	f	class:tthread::thread::id
operator []	glhack.h	/^    ParamMap operator[](const std::string& str){ return ParamMap(*this, str); }$/;"	f	class:glh::RenderEnvironment
operator []	math_tools.h	/^        T& operator[](size_t ind){return data[ind];}$/;"	f	class:glh::Math::span_t
operator []	math_tools.h	/^        const T& operator[](size_t ind) const {return data[ind];}$/;"	f	class:glh::Math::span_t
operator []	math_tools.h	/^    T& operator[](size_t i){return data_[i];}$/;"	f	struct:glh::ArrayN
operator []	math_tools.h	/^    const T& operator[](size_t i) const {return data_[i];}$/;"	f	struct:glh::ArrayN
operator []	shims_and_types.h	/^    KeyInserter operator[](const Value& v)$/;"	f	class:glh::BiMap
operator []	shims_and_types.h	/^    T& operator[](size_t i){return data_[i];}$/;"	f	class:glh::Array
operator []	shims_and_types.h	/^    T& operator[](size_t index){ return data_[index];}$/;"	f	class:glh::AlignedArray
operator []	shims_and_types.h	/^    ValueInserter operator[](const Key& k)$/;"	f	class:glh::BiMap
operator []	shims_and_types.h	/^    const KeyInserter operator[](const Value& v) const$/;"	f	class:glh::BiMap
operator []	shims_and_types.h	/^    const ValueInserter operator[](const Key& k) const$/;"	f	class:glh::BiMap
order	stb_image.c	/^   int scan_n, order[4];$/;"	m	struct:__anon26	file:
out	stb_image.c	/^   stbi_uc *out;                 \/\/ output buffer (always 4 components)$/;"	m	struct:stbi_gif_struct	file:
out	stb_image.c	/^   uint8 *idata, *expanded, *out;$/;"	m	struct:__anon32	file:
out_	masp.cpp	/^    std::ostream*        out_;$/;"	m	class:masp::Masp::Env	file:
outfile	stb_image_write.h	/^static int outfile(char const *filename, int rgb_dir, int vdir, int x, int y, int comp, void *data, int alpha, int pad, const char *fmt, ...)$/;"	f
outputfile_functions	masp_extensions.cpp	/^void outputfile_functions(masp::FunMap& fmap)$/;"	f	namespace:masp
p0	geometry.h	/^    point3 p0, p1, p2;$/;"	m	struct:glh::Triangle
p1	geometry.h	/^    point3 p0, p1, p2;$/;"	m	struct:glh::Triangle
p2	geometry.h	/^    point3 p0, p1, p2;$/;"	m	struct:glh::Triangle
padding	glh_layout_tools.h	/^    double padding;$/;"	m	struct:glh::Layout
padding	stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon38
paeth	stb_image.c	/^static int paeth(int a, int b, int c)$/;"	f	file:
pal	stb_image.c	/^   uint8  pal[256][4];$/;"	m	struct:stbi_gif_struct	file:
pane_root_	glh_scene_extensions.h	/^    SceneTree::Node* pane_root_;$/;"	m	class:glh::GlyphPane
parent	glh_scenemanagement.h	/^        Node* parent(){\/*??? do we need this*\/}$/;"	f	class:glh::SceneTree::tree_iterator
parent_	glh_scene_extensions.h	/^    SceneTree::Node* parent_;$/;"	m	class:glh::GlyphPane
parent_	shims_and_types.h	/^        BiMap& parent_;$/;"	m	struct:glh::BiMap::KeyInserter
parent_	shims_and_types.h	/^        BiMap& parent_;$/;"	m	struct:glh::BiMap::ValueInserter
parent_	shims_and_types.h	/^    Container& parent_;$/;"	m	struct:glh::Inserter1
parent_	shims_and_types.h	/^    Container& parent_;$/;"	m	struct:glh::Inserter2
parent_id_	glh_scenemanagement.h	/^        int         parent_id_;$/;"	m	class:glh::SceneTree::Node
parse	masp.cpp	/^    masp_result parse(const char* str)$/;"	f	class:masp::ValueParser
parse	stb_image.c	/^   int parse, step;$/;"	m	struct:stbi_gif_struct	file:
parse_entropy_coded_data	stb_image.c	/^static int parse_entropy_coded_data(jpeg *z)$/;"	f	file:
parse_huffman_block	stb_image.c	/^static int parse_huffman_block(zbuf *a)$/;"	f	file:
parse_number	masp.cpp	/^    bool parse_number(Number& out)$/;"	f	class:masp::ValueParser
parse_png_file	stb_image.c	/^static int parse_png_file(png *z, int scan, int req_comp)$/;"	f	file:
parse_shader_vars	glhack.cpp	/^std::list<ShaderVar> parse_shader_vars(cstring& shader)$/;"	f	namespace:glh
parse_string	masp.cpp	/^    const char* parse_string()$/;"	f	class:masp::ValueParser
parse_symbol	masp.cpp	/^    bool parse_symbol(const char** begin, const char** end)$/;"	f	class:masp::ValueParser
parse_uncompressed_block	stb_image.c	/^static int parse_uncompressed_block(zbuf *a)$/;"	f	file:
parse_zlib	stb_image.c	/^static int parse_zlib(zbuf *a, int parse_header)$/;"	f	file:
parse_zlib_header	stb_image.c	/^static int parse_zlib_header(zbuf *a)$/;"	f	file:
parsenum	masp.cpp	/^ParseResult parsenum(const char* num, const char* numend, int& intvalue, double& doublevalue)$/;"	f	namespace:masp
pass_all	glh_scenemanagement.cpp	/^bool pass_all(SceneTree::Node* node){ return true; }$/;"	f	namespace:glh
pass_interaction_locked	glh_scenemanagement.cpp	/^bool pass_interaction_locked(SceneTree::Node* node){ return node->interaction_lock_; }$/;"	f	namespace:glh
pass_interaction_unlocked	glh_scenemanagement.cpp	/^bool pass_interaction_unlocked(SceneTree::Node* node){ return !node->interaction_lock_; }$/;"	f	namespace:glh
pass_pickable	glh_scenemanagement.cpp	/^bool pass_pickable(SceneTree::Node* node){ return node->pickable_; }$/;"	f	namespace:glh
pass_pickable_and_unlocked	glh_scenemanagement.cpp	/^bool pass_pickable_and_unlocked(SceneTree::Node* node){ return pass_pickable(node) && pass_interaction_unlocked(node); }$/;"	f	namespace:glh
pass_unpickable	glh_scenemanagement.cpp	/^bool pass_unpickable(SceneTree::Node* node){ return !node->pickable_; }$/;"	f	namespace:glh
path_join	iotools.cpp	/^std::string path_join(const std::string& head, const std::string& tail)$/;"	f
path_split	iotools.cpp	/^std::vector<std::string> path_split(const std::string& path)$/;"	f
path_to_platform_string	iotools.cpp	/^std::string path_to_platform_string(const std::string& path)$/;"	f
patt	win32_dirent.h	/^    wchar_t *patt;                              \/* Initial directory name *\/$/;"	m	struct:_WDIR
period	tinythread.h	/^      typedef _Period period;$/;"	t	class:tthread::chrono::duration
period_certification	tinymt32.c	/^static void period_certification(tinymt32_t * random) {$/;"	f	file:
period_certification	tinymt64.c	/^static void period_certification(tinymt64_t * random) {$/;"	f	file:
perm	glh_generators.cpp	/^        index_array_t    perm;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
perm_mod12	glh_generators.cpp	/^        index_array_t    perm_mod12;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
perm_table_size	glh_generators.cpp	/^        static const int perm_table_size = 512;$/;"	m	struct:glh::SimplexNoise::Impl_s	file:
pic_copyval	stb_image.c	/^static void pic_copyval(int channel,stbi_uc *dest,const stbi_uc *src)$/;"	f	file:
pic_is4	stb_image.c	/^static int pic_is4(stbi *s,const char *str)$/;"	f	file:
pic_load	stb_image.c	/^static stbi_uc *pic_load(stbi *s,int *px,int *py,int *comp,int req_comp)$/;"	f	file:
pic_load2	stb_image.c	/^static stbi_uc *pic_load2(stbi *s,int width,int height,int *comp, stbi_uc *result)$/;"	f	file:
pic_packet_t	stb_image.c	/^} pic_packet_t;$/;"	t	typeref:struct:__anon34	file:
pic_readval	stb_image.c	/^static stbi_uc *pic_readval(stbi *s, int channel, stbi_uc *dest)$/;"	f	file:
pic_test	stb_image.c	/^static int pic_test(stbi *s)$/;"	f	file:
pick_passes	glh_uicontext.h	/^    void pick_passes(){$/;"	f	class:glh::UiContext
pickable_	glh_scenemanagement.h	/^        bool        pickable_; \/\/ TODO: Preferably, remove from here (UI stuff)$/;"	m	class:glh::SceneTree::Node
picked_	glh_scenemanagement.h	/^     node_ptr_container_t picked_;$/;"	m	class:glh::RenderPicker
picker_	glh_scenemanagement.h	/^        RenderPicker& picker_;$/;"	m	struct:glh::RenderPicker::PickedContext
pixel	gltexture.h	/^    Pixel          pixel;$/;"	m	class:glh::TextureType
pixel_t	glh_image.h	/^    typedef float pixel_t;$/;"	t	class:glh::Image32
pixel_t	glh_image.h	/^    typedef uint8_t pixel_t;$/;"	t	class:glh::Image8
pixels	stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon39
platform_separator	iotools.cpp	/^char platform_separator(){$/;"	f
png	stb_image.c	/^} png;$/;"	t	typeref:struct:__anon32	file:
point3	geometry.h	/^typedef Point<float>  point3;$/;"	t	namespace:glh
point3d	geometry.h	/^typedef Point<double> point3d;$/;"	t	namespace:glh
point3i	geometry.h	/^typedef Point<int>    point3i;$/;"	t	namespace:glh
point_of_point	geometry.h	/^Eigen::Matrix<T,4,1,0,4,1> point_of_point(const Point<T>& b)$/;"	f	namespace:glh
points	geometry.h	/^template<class T> struct Polygon{std::list<Point<T>> points;};$/;"	m	struct:glh::Polygon
pool_	persistent_containers.h	/^        PListPool& pool_;$/;"	m	class:glh::PListPool::List
pool_	persistent_containers.h	/^        PMapPool& pool_;$/;"	m	class:glh::PMapPool::Map
pool_	shims_and_types.h	/^    Pool<Node> pool_;$/;"	m	class:glh::PooledList
pop	persistent_containers.h	/^        void pop()$/;"	f	class:glh::PMapPool::node_iterator
pop	shims_and_types.h	/^    bool pop()$/;"	f	class:glh::FixedStack
pos	glh_font.h	/^        struct pos_ref_t{ vec2& pos; vec2& tex; };$/;"	m	struct:glh::textured_quad2d_t::iterator::pos_ref_t
pos	glh_font.h	/^    quad2d_coord_t& pos(int j, int i){$/;"	f	struct:glh::GlyphCoords
pos_	glh_font.h	/^    quad2d_coord_t pos_; $/;"	m	struct:glh::textured_quad2d_t
pos_in_string	masp.cpp	/^static int pos_in_string(const char c, const char* str)$/;"	f	namespace:masp
pos_ref_t	glh_font.h	/^        struct pos_ref_t{ vec2& pos; vec2& tex; };$/;"	s	struct:glh::textured_quad2d_t::iterator
position	math_tools.h	/^    static ExplicitTransform ExplicitTransform::position(typename const Math<T>::vec3_t& pos){$/;"	f	class:glh::ExplicitTransform::ExplicitTransform
position_	math_tools.h	/^    typename Math<T>::vec3_t       position_;$/;"	m	struct:glh::ExplicitTransform
postorder_sort_graph	glh_dynamic_graph.h	/^std::vector<T> postorder_sort_graph(const AdjacencyListGraph<T>& graph){$/;"	f	namespace:glh
prefix	stb_image.c	/^   int16 prefix;$/;"	m	struct:stbi_gif_lzw_struct	file:
previous_time_	glh_dynamic_graph.h	/^    double previous_time_;$/;"	m	class:glh::SystemInput
previously_focused_	glh_scenemanagement.h	/^    entity_container_t previously_focused_;$/;"	m	class:glh::FocusContext
process_frame_header	stb_image.c	/^static int process_frame_header(jpeg *z, int scan)$/;"	f	file:
process_marker	stb_image.c	/^static int process_marker(jpeg *z, int m)$/;"	f	file:
process_scan_header	stb_image.c	/^static int process_scan_header(jpeg *z)$/;"	f	file:
program_	glhack.h	/^    ProgramHandle*    program_;$/;"	m	class:glh::FullRenderable
program_handle	glhack.cpp	/^    GLuint program_handle;$/;"	m	class:glh::ShaderProgram	file:
program_handle	glhack.cpp	/^GLuint program_handle(const ProgramHandle* handle_)$/;"	f	namespace:glh
program_location	glprogramvars.h	/^    GLuint program_location;$/;"	m	class:glh::ShaderVar
program_params_from_env	glhack.cpp	/^void program_params_from_env(ActiveProgram& program, RenderEnvironment& env){$/;"	f	namespace:glh
programs_	glhack.cpp	/^    std::map<std::string, ShaderProgramPtr> programs_;$/;"	m	class:glh::GraphicsManagerInt	file:
progtime	glbase.cpp	/^double progtime(){return glfwGetTime();}$/;"	f	namespace:glh
projection_	glh_scenemanagement.h	/^    Projection projection_;$/;"	m	class:glh::Camera
psd_load	stb_image.c	/^static stbi_uc *psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
psd_test	stb_image.c	/^static int psd_test(stbi *s)$/;"	f	file:
ptr	shims_and_types.h	/^    const T* ptr;$/;"	m	class:glh::ConstOption
push	glh_scenemanagement.h	/^        void push(){stack_.push(Iterator(current_));}$/;"	f	class:glh::SceneTree::tree_iterator
push	shims_and_types.h	/^    T& push()$/;"	f	class:glh::Pool
push	shims_and_types.h	/^    T& push(const T& data)$/;"	f	class:glh::Pool
push	shims_and_types.h	/^    bool push(const T& data)$/;"	f	class:glh::FixedStack
push	shims_and_types.h	/^    void push(value_type v){$/;"	f	class:glh::ArenaQueue
push_back	shims_and_types.h	/^    void push_back(const T& data)$/;"	f	class:glh::Pool
push_back	shims_and_types.h	/^    void push_back(const T& t)$/;"	f	struct:glh::SortedArray
push_back	shims_and_types.h	/^    void push_back(const T& var)$/;"	f	class:glh::PooledList
push_back	shims_and_types.h	/^    void push_back(const char c){string.push_back(c);}$/;"	f	struct:glh::TextLine
push_event	glbase.cpp	/^void UserInput::push_event(const InputEvent& e)$/;"	f	class:glh::UserInput
push_line	glh_scene_extensions.h	/^    TextLine& push_line(const std::string& string){$/;"	f	class:glh::TextField
push_node	persistent_containers.h	/^        void push_node(Node* parent_node)$/;"	f	class:glh::PMapPool::node_iterator
push_row	glh_font.h	/^    row_coords_t* push_row(){$/;"	f	struct:glh::GlyphCoords
quad2d_coord_t	glh_font.h	/^typedef std::array<vec2, 6> quad2d_coord_t;$/;"	t	namespace:glh
quad_	glh_font.h	/^        textured_quad2d_t& quad_;$/;"	m	struct:glh::textured_quad2d_t::iterator
quaternion	math_tools.h	/^typedef Eigen::Quaternion<float>  quaternion;$/;"	t	namespace:glh
quaternion_t	math_tools.h	/^    typedef Eigen::Quaternion<T>   quaternion_t;$/;"	t	class:glh::Math
quaterniond	math_tools.h	/^typedef Eigen::Quaternion<double> quaterniond;$/;"	t	namespace:glh
queue_	glh_scenemanagement.h	/^    RenderQueue                     queue_;$/;"	m	class:glh::RenderPass
queue_	shims_and_types.h	/^    std::vector<value_type> queue_;$/;"	m	class:glh::ArenaQueue
r	math_tools.h	/^    float r;$/;"	m	struct:glh::Color
r_	glhack.h	/^        GLboolean r_;GLboolean g_; GLboolean b_; GLboolean a_;$/;"	m	struct:glh::RenderPassSettings::ColorMask
rand	math_tools.h	/^    float rand()$/;"	f	struct:glh::RandomRange
rand	math_tools.h	/^    float rand(){return tinymt32_generate_float(&state);}$/;"	f	struct:glh::Random
rand	math_tools.h	/^    int32_t rand()$/;"	f	struct:glh::Random
rand	math_tools.h	/^    int32_t rand()$/;"	f	struct:glh::RandomRange
random	math_tools.h	/^    Random<float> random;$/;"	m	struct:glh::RandomRange
range_decompose	masp.cpp	/^bool range_decompose(IT begin, IT end, PPTR a, PPTR b)$/;"	f	namespace:masp::__anon15
range_end_	math_tools.h	/^    T range_end_;$/;"	m	class:glh::Range
range_start_	math_tools.h	/^    T range_start_;$/;"	m	class:glh::Range
range_to_string	shims_and_types.h	/^std::string range_to_string(Iter begin, Iter end)$/;"	f	namespace:glh
ratio	stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
ratio	tinythread.h	/^template <__intmax_t N, __intmax_t D = 1> class ratio {$/;"	c	namespace:tthread
raw_data	stb_image.c	/^      void *raw_data;$/;"	m	struct:__anon26::__anon27	file:
read	stb_image.c	/^   int      (*read)  (void *user,char *data,int size);   \/\/ fill 'data' with 'size' bytes.  return number of bytes actually read $/;"	m	struct:__anon22	file:
read_eval	masp.cpp	/^masp_result read_eval(Masp& m, const char* str){$/;"	f	namespace:masp
read_from_callbacks	stb_image.c	/^   int read_from_callbacks;$/;"	m	struct:__anon23	file:
read_in_val	glh_dynamic_graph.h	/^    void read_in_val( const std::string& name, DynamicGraph::constvalue_t_ptr val){$/;"	f	class:glh::NodeReciever
read_input	glh_dynamic_graph.h	/^        T read_input(const std::string& input_name){$/;"	f	struct:glh::DynamicGraph::DynamicNode
read_input	glh_dynamic_graph.h	/^        constvalue_t read_input(const std::string& input_name){$/;"	f	struct:glh::DynamicGraph::DynamicNode
readdir	win32_dirent.h	/^readdir($/;"	f
reading_string	masp.cpp	/^    bool reading_string;$/;"	m	class:masp::ValueParser	file:
realloc_data	shims_and_types.h	/^    void realloc_data(size_t new_capacity)$/;"	f	class:glh::AlignedArray
recieve_characters	glh_scene_extensions.cpp	/^void GlyphPane::recieve_characters(int key, Modifiers modifiers)$/;"	f	class:glh::GlyphPane
recursive_mark	persistent_containers.h	/^    void recursive_mark(Node* node)$/;"	f	class:glh::PMapPool
recursive_mutex	tinythread.h	/^    recursive_mutex()$/;"	f	class:tthread::recursive_mutex
recursive_mutex	tinythread.h	/^class recursive_mutex {$/;"	c	namespace:tthread
recursive_parse	masp.cpp	/^    void recursive_parse(Value& root)$/;"	f	class:masp::ValueParser
recycled_nodes_	glh_scenemanagement.h	/^    std::list<Node*> recycled_nodes_;$/;"	m	class:glh::SceneTree
ref_chunk	persistent_containers.h	/^    typedef Chunk<typename Node::Ref> ref_chunk;$/;"	t	class:glh::PMapPool
ref_chunk_box	persistent_containers.h	/^    typedef ChunkBox<typename Node::Ref> ref_chunk_box;$/;"	t	class:glh::PMapPool
ref_chunks_	persistent_containers.h	/^    ref_chunk_box      ref_chunks_;$/;"	m	class:glh::PMapPool
ref_count_	persistent_containers.h	/^    ref_count_map         ref_count_;   \/\/> Head node reference counts$/;"	m	class:glh::PListPool
ref_count_	persistent_containers.h	/^    refcount_map       ref_count_; \/\/ Store references to root nodes$/;"	m	class:glh::PMapPool
ref_count_map	persistent_containers.h	/^    typedef std::unordered_map<Node*, int> ref_count_map;$/;"	t	class:glh::PListPool
refcount_map	persistent_containers.h	/^    typedef std::unordered_map<Node*, int> refcount_map;$/;"	t	class:glh::PMapPool
refill_buffer	stb_image.c	/^static void refill_buffer(stbi *s)$/;"	f	file:
refresh_free_chunk_list	persistent_containers.h	/^    void refresh_free_chunk_list()$/;"	f	class:glh::ChunkBox
regex_t	glh_regex.h	/^typedef boost::regex  regex_t;$/;"	t
regex_t	glh_regex.h	/^typedef std::regex  regex_t;$/;"	t
release	glh_typedefs.cpp	/^void ObjectRoster::IdGenerator::release(int id){$/;"	f	class:glh::ObjectRoster::IdGenerator
release	shims_and_types.h	/^    void release(const std::string& string){$/;"	f	class:glh::StringNumerator
release_program	glhack.cpp	/^bool release_program(ShaderProgram& program)$/;"	f	namespace:glh
remove	glh_timebased_signals.h	/^    void remove(T id){$/;"	f	class:glh::DynamicSystem
remove	glh_timebased_signals.h	/^    void remove(obj_id id){events_.erase(id);}$/;"	f	class:glh::DynamicSystem
remove	glhack.h	/^    void remove(cstring name){$/;"	f	class:glh::RenderEnvironment
remove	persistent_containers.h	/^        List remove(const iterator& i) const$/;"	f	class:glh::PListPool::List
remove	persistent_containers.h	/^        Map remove(const K& key)$/;"	f	class:glh::PMapPool::Map
remove_at	shims_and_types.h	/^void remove_at(T& container, size_t pos){$/;"	f	namespace:glh
remove_child	glh_scenemanagement.h	/^        void remove_child(Node* node){$/;"	f	class:glh::SceneTree::Node
remove_ref	persistent_containers.h	/^    void remove_ref(Node* n)$/;"	f	class:glh::PListPool
remove_ref	persistent_containers.h	/^    void remove_ref(Node* n)$/;"	f	class:glh::PMapPool
render	glbase.h	/^    AppRender render;$/;"	m	struct:glh::AppConfig
render	glh_scenemanagement.h	/^    void render(GraphicsManager* gm){$/;"	f	class:glh::RenderPass
render	glh_scenemanagement.h	/^    void render(GraphicsManager* gm, ProgramHandle& program){$/;"	f	class:glh::RenderPass
render	glh_scenemanagement.h	/^    void render(GraphicsManager* manager, ProgramHandle& program, glh::RenderEnvironment& env){$/;"	f	class:glh::RenderQueue
render	glh_scenemanagement.h	/^    void render(GraphicsManager* manager, glh::RenderEnvironment& env){$/;"	f	class:glh::RenderQueue
render_bitmap	glh_font.cpp	/^BakedFontHandle FontContext::render_bitmap($/;"	f	class:glh::FontContext
render_bitmap	glh_font.cpp	/^BakedFontHandle FontContext::render_bitmap(const FontConfig& config)$/;"	f	class:glh::FontContext
render_glyph_coordinates_to_mesh	glh_scene_extensions.cpp	/^void render_glyph_coordinates_to_mesh($/;"	f	namespace:glh
render_glyph_coordinates_to_mesh	glh_scene_extensions.cpp	/^void render_glyph_coordinates_to_mesh(FontContext& context, const std::string& row,$/;"	f	namespace:glh
render_pass_	glh_scenemanagement.h	/^    RenderPass* render_pass_;$/;"	m	class:glh::RenderPicker
render_pass_	glh_uicontext.h	/^    RenderPass       render_pass_;$/;"	m	struct:glh::SelectionWorld
render_passes_	glh_scene_extensions.h	/^    std::list<RenderPass>                               render_passes_;$/;"	m	class:glh::SceneAssets
render_picker_	glh_uicontext.h	/^    RenderPicker                render_picker_;$/;"	m	class:glh::UiContext
render_selectables	glh_scenemanagement.h	/^    PickedContext render_selectables(int pointer_x, int pointer_y){$/;"	f	class:glh::RenderPicker
render_volume_depth_	glh_scenemanagement.h	/^    float render_volume_depth_;$/;"	m	class:glh::Camera
renderable	glh_scenemanagement.h	/^        FullRenderable* renderable(){return renderable_;}$/;"	f	class:glh::SceneTree::Node
renderable_	glh_scene_extensions.h	/^    FullRenderable*  renderable_;$/;"	m	class:glh::GlyphPane
renderable_	glh_scenemanagement.h	/^        FullRenderable* renderable_;$/;"	m	class:glh::SceneTree::Node
renderables_	glh_scenemanagement.h	/^    node_ptr_sequence_t renderables_;$/;"	m	class:glh::RenderQueue
renderables_	glhack.cpp	/^    std::list<FullRenderablePtr>            renderables_;$/;"	m	class:glh::GraphicsManagerInt	file:
rep	tinythread.h	/^      typedef _Rep rep;$/;"	t	class:tthread::chrono::duration
rep_	tinythread.h	/^      _Rep rep_;$/;"	m	class:tthread::chrono::duration
report	masp.cpp	/^    std::string report()$/;"	f	struct:masp::ScopeError
resample	stb_image.c	/^   resample_row_func resample;$/;"	m	struct:__anon28	file:
resample_row_1	stb_image.c	/^static uint8 *resample_row_1(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_func	stb_image.c	/^typedef uint8 *(*resample_row_func)(uint8 *out, uint8 *in0, uint8 *in1,$/;"	t	file:
resample_row_generic	stb_image.c	/^static uint8 *resample_row_generic(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_h_2	stb_image.c	/^static uint8*  resample_row_h_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_hv_2	stb_image.c	/^static uint8 *resample_row_hv_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_v_2	stb_image.c	/^static uint8* resample_row_v_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)$/;"	f	file:
resend_data_on_render	glhack.h	/^    void resend_data_on_render(){$/;"	f	class:glh::FullRenderable
reserve_consecutive_elements	persistent_containers.h	/^    T* reserve_consecutive_elements(const size_t element_count)$/;"	f	class:glh::ChunkBox
reserve_element	persistent_containers.h	/^    T* reserve_element()$/;"	f	class:glh::ChunkBox
reserved_size_bytes	masp.cpp	/^    size_t reserved_size_bytes()$/;"	f	class:masp::Masp::Env
reserved_size_bytes	masp.cpp	/^size_t Masp::reserved_size_bytes(){return env_->reserved_size_bytes();}$/;"	f	class:masp::Masp
reserved_size_bytes	persistent_containers.h	/^    size_t reserved_size_bytes() const {$/;"	f	class:glh::ChunkBox
reserved_size_bytes	persistent_containers.h	/^    size_t reserved_size_bytes() const {return sizeof(*this);}$/;"	f	struct:glh::Chunk
reserved_size_bytes	persistent_containers.h	/^    size_t reserved_size_bytes()$/;"	f	class:glh::PListPool
reserved_size_bytes	persistent_containers.h	/^    size_t reserved_size_bytes()$/;"	f	class:glh::PMapPool
reset	glbuffers.h	/^    void reset()$/;"	f	class:glh::BufferHandle
reset	glbuffers.h	/^    void reset(){$/;"	f	class:glh::BufferSet
reset	stb_image.c	/^static void reset(jpeg *j)$/;"	f	file:
reset_buffers	glhack.h	/^    void reset_buffers(){$/;"	f	class:glh::FullRenderable
reset_context	glh_scenemanagement.h	/^    void reset_context(){$/;"	f	class:glh::RenderPicker
reset_data	glh_scenemanagement.h	/^        void reset_data(){$/;"	f	class:glh::SceneTree::Node
reset_vars	glhack.cpp	/^    void reset_vars(){$/;"	f	class:glh::ShaderProgram
resize	glbase.cpp	/^void App::resize(int width, int height)$/;"	f	class:glh::App
resize	glbase.h	/^    AppResize resize;$/;"	m	struct:glh::AppConfig
resize	shims_and_types.h	/^    void resize(size_t new_size, const T& init_value)$/;"	f	class:glh::AlignedArray
rest	persistent_containers.h	/^        List rest() const$/;"	f	class:glh::PListPool::List
restart_interval	stb_image.c	/^   int restart_interval, todo;$/;"	m	struct:__anon26	file:
result	masp.cpp	/^    Result result;$/;"	m	struct:masp::ScopeError	file:
rewinddir	win32_dirent.h	/^rewinddir($/;"	f
rewrite_defn	masp.cpp	/^    void rewrite_defn(std::list<Value>& build_list, List* list_ptr)$/;"	f	class:masp::ValueParser
rewrite_member_call	masp.cpp	/^    void rewrite_member_call(std::list<Value>& build_list, List* list_ptr)$/;"	f	class:masp::ValueParser
root	glh_scene_extensions.h	/^    SceneTree::Node* root(){ return pane_root_; }$/;"	f	class:glh::GlyphPane
root	glh_scenemanagement.h	/^    Node* root(){return root_;}$/;"	f	class:glh::SceneTree
root_	glh_scenemanagement.h	/^    Node*                     root_;$/;"	m	class:glh::SceneTree
root_	persistent_containers.h	/^        Node* root_;$/;"	m	class:glh::PMapPool::Map
root_path_	glh_scenemanagement.h	/^    std::string                     root_path_;$/;"	m	class:glh::RenderPass
rotation_	math_tools.h	/^    typename Math<T>::quaternion_t rotation_;$/;"	m	struct:glh::ExplicitTransform
row_coords_container_t	glh_font.h	/^    typedef std::vector<row_coords_t>      row_coords_container_t;$/;"	t	struct:glh::GlyphCoords
row_coords_t	glh_font.h	/^    typedef std::vector<textured_quad2d_t> row_coords_t;$/;"	t	struct:glh::GlyphCoords
row_len	glh_font.h	/^    int row_len(int row_index){$/;"	f	struct:glh::GlyphCoords
rrest	persistent_containers.h	/^        List rrest() const$/;"	f	class:glh::PListPool::List
rrrest	persistent_containers.h	/^        List rrrest() const$/;"	f	class:glh::PListPool::List
running_	glbase.h	/^    bool                             running_;$/;"	m	class:glh::App
s	glh_typedefs.h	/^    enum s{ Position = 0,$/;"	g	class:glh::ChannelType
s	stb_image.c	/^   stbi *s;$/;"	m	struct:__anon26	file:
s	stb_image.c	/^   stbi *s;$/;"	m	struct:__anon32	file:
s0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon36
s1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon36
sample_count_	math_tools.h	/^    int                  sample_count_;$/;"	m	class:glh::Sampler1D
sample_interpolating_map	math_tools.h	/^Sampler1D<Value> sample_interpolating_map(const InterpolatingMap<Key, Value, Interp>& map, const int sample_count)$/;"	f	namespace:glh
samples_	math_tools.h	/^    std::vector<Value>   samples_;$/;"	m	class:glh::Sampler1D
scalar_	glhack.h	/^    std::map<std::string, float>    scalar_;$/;"	m	class:glh::RenderEnvironment
scale_	math_tools.h	/^    typename Math<T>::vec3_t       scale_;$/;"	m	struct:glh::ExplicitTransform
scale_t	math_tools.h	/^    enum scale_t{SX = 0, SY = 1, SZ = 2};$/;"	g	struct:Dim
scan_n	stb_image.c	/^   int scan_n, order[4];$/;"	m	struct:__anon26	file:
scene	glh_scene_extensions.h	/^    SceneTree& scene(){ return tree_; }$/;"	f	class:glh::SceneAssets
scene_	glh_scene_extensions.h	/^    SceneTree*       scene_;$/;"	m	class:glh::GlyphPane
scene_	glh_uicontext.h	/^    SceneTree&       scene_;$/;"	m	class:glh::UiContext
scope	masp.cpp	/^    char scope;$/;"	m	struct:masp::ScopeError	file:
second	persistent_containers.h	/^        const T* second() const$/;"	f	class:glh::PListPool::List
second	persistent_containers.h	/^    struct KeyValue{uint32_t hash; K first; V second;};$/;"	m	struct:glh::PMapPool::KeyValue
seconds	tinythread.h	/^  typedef duration<__intmax_t> seconds;                            \/\/\/< Duration with the unit seconds.$/;"	t	namespace:tthread::chrono
seeds_	shims_and_types.h	/^    std::map<std::string, std::tuple<int, std::vector<int>>> seeds_;$/;"	m	class:glh::StringNumerator
selected_id_	glh_scenemanagement.h	/^    int selected_id_;$/;"	m	class:glh::RenderPicker
selected_list_	glh_uicontext.h	/^    selection_list_t selected_list_;$/;"	m	struct:glh::SelectionWorld
selection_list_t	glh_uicontext.h	/^    typedef std::vector<SceneTree::Node*> selection_list_t;$/;"	t	struct:glh::SelectionWorld
selection_pass_2d_default_	glh_app_services.h	/^    RenderPass*     selection_pass_2d_default_;$/;"	m	class:glh::AppServices
selection_pass_3d_default_	glh_app_services.h	/^    RenderPass*     selection_pass_3d_default_;$/;"	m	class:glh::AppServices
selection_program_	glh_scenemanagement.h	/^    ProgramHandle* selection_program_;$/;"	m	class:glh::RenderPicker
selection_world_2d_	glh_app_services.h	/^    SelectionWorld* selection_world_2d_;$/;"	m	class:glh::AppServices
selection_world_3d_	glh_app_services.h	/^    SelectionWorld* selection_world_3d_;$/;"	m	class:glh::AppServices
selection_worlds_	glh_uicontext.h	/^    std::vector<SelectionWorld> selection_worlds_;$/;"	m	class:glh::UiContext
sequence_exp	masp.cpp	/^Value sequence_exp(const List& action)$/;"	f	namespace:masp::__anon15
set	glbuffers.h	/^    void set(T* data, size_t count){$/;"	f	class:glh::VertexChunk
set	glbuffers.h	/^    void set(const T val, size_t count){$/;"	f	class:glh::VertexChunk
set	glh_image.cpp	/^void Image8::set(uint8_t* data, int channels, uint8_t* sample){$/;"	f	class:glh::Image8
set	masp.cpp	/^    void set(const char* chp){c_ = chp;}$/;"	f	class:masp::ValueParser
set	masp.h	/^    Number& set(const Number& n){$/;"	f	struct:masp::Number
set	masp.h	/^    Number& set(const double d){type = FLOAT; value.floatvalue = d; return *this;}$/;"	f	struct:masp::Number
set	masp.h	/^    Number& set(const int i){type = INT; value.intvalue = i; return *this;}$/;"	f	struct:masp::Number
set_args	masp.cpp	/^void Masp::set_args(int argc, char* argv[])$/;"	f	class:masp::Masp
set_at	glh_font.h	/^    void set_at(vec2 pos, vec2 tex, size_t index){$/;"	f	struct:glh::textured_quad2d_t
set_bit_off	math_tools.h	/^inline uint32_t set_bit_off(uint32_t field, uint32_t index)$/;"	f	namespace:glh
set_bit_on	math_tools.h	/^inline uint32_t set_bit_on(const uint32_t field, uint32_t index)$/;"	f	namespace:glh
set_buffer_clear	glhack.cpp	/^void RenderPassSettings::set_buffer_clear(Buffer buffer)$/;"	f	class:glh::RenderPassSettings
set_camera	glh_scenemanagement.h	/^    void set_camera(Camera* camera){ camera_ = camera; }$/;"	f	class:glh::RenderPass
set_difference	shims_and_types.h	/^    void set_difference(const SortedArray& cmp, SortedArray& out) const {$/;"	f	struct:glh::SortedArray
set_font	glh_scene_extensions.h	/^    void set_font(const std::string& name, float size){$/;"	f	class:glh::GlyphPane
set_input_address	glh_dynamic_graph.h	/^        void set_input_address(const std::string& input_name, constvalue_t_ptr ptr){$/;"	f	struct:glh::DynamicGraph::DynamicNode
set_intersection	shims_and_types.h	/^    void set_intersection(const SortedArray& cmp, SortedArray& out) const {$/;"	f	struct:glh::SortedArray
set_marked	persistent_containers.h	/^    void set_marked(const T* ptr)$/;"	f	struct:glh::Chunk
set_marked_if_contained	persistent_containers.h	/^    void set_marked_if_contained(const T* ptr)$/;"	f	class:glh::ChunkBox
set_marked_if_contained_array	persistent_containers.h	/^    void set_marked_if_contained_array(const T* ptr, size_t size)$/;"	f	class:glh::ChunkBox
set_marked_if_contains	persistent_containers.h	/^    bool set_marked_if_contains(const T* elem)$/;"	f	struct:glh::Chunk
set_marked_if_contains_array	persistent_containers.h	/^    bool set_marked_if_contains_array(const T* start, const size_t count)$/;"	f	struct:glh::Chunk
set_mat4	glhack.h	/^    void set_mat4(cstring name, const mat4& mat){mat4_[name] = mat;}$/;"	f	class:glh::RenderEnvironment
set_material	glh_scenemanagement.cpp	/^void set_material(SceneTree::Node& node, RenderEnvironment& material){$/;"	f	namespace:glh
set_material	glh_scenemanagement.cpp	/^void set_material(SceneTree::Node& node, cstring& name, const float var){$/;"	f	namespace:glh
set_material	glh_scenemanagement.cpp	/^void set_material(SceneTree::Node& node, cstring& name, const vec4& var){$/;"	f	namespace:glh
set_mesh	glhack.h	/^    void set_mesh(DefaultMesh* meshptr){$/;"	f	class:glh::FullRenderable
set_movement_mapper_generator	glh_uicontext.h	/^    void set_movement_mapper_generator(MovementMapperGen mapper){ mapper_gen_ = mapper; }$/;"	f	class:glh::UiContext
set_output	glh_dynamic_graph.h	/^        void set_output(const std::string& output_name, const Value& val){$/;"	f	struct:glh::DynamicGraph::DynamicNode
set_output	glh_dynamic_graph.h	/^        void set_output(const std::string& output_name, const Value::t& type){$/;"	f	struct:glh::DynamicGraph::DynamicNode
set_output	glh_dynamic_graph.h	/^        void set_output(const std::string& output_name, const Value::t& type, const V& val){$/;"	f	struct:glh::DynamicGraph::DynamicNode
set_output	glh_dynamic_graph.h	/^        void set_output(const std::string& output_name, const float val){$/;"	f	struct:glh::DynamicGraph::DynamicNode
set_output	masp.cpp	/^void Masp::set_output(std::ostream* os)$/;"	f	class:masp::Masp
set_queue_filter	glh_scenemanagement.h	/^    void set_queue_filter(RenderQueue::node_filter_fun_t fun){ active_filter_ = fun; }$/;"	f	class:glh::RenderPass
set_renderable	glh_scenemanagement.h	/^        void set_renderable(FullRenderable* renderable){renderable_ = renderable;}$/;"	f	class:glh::SceneTree::Node
set_scalar	glhack.h	/^    void set_scalar(cstring name, const float val){scalar_[name] = val;}$/;"	f	class:glh::RenderEnvironment
set_texture2d	glhack.h	/^    void set_texture2d(cstring name, Texture* tex){texture2d_[name] = tex;}$/;"	f	class:glh::RenderEnvironment
set_union	shims_and_types.h	/^    void set_union(const SortedArray& cmp, SortedArray& out) const {$/;"	f	struct:glh::SortedArray
set_vec4	glhack.h	/^    void set_vec4(cstring name, const vec4& vec){vec4_[name] = vec;}$/;"	f	class:glh::RenderEnvironment
set_view_to_screen_transform	glh_scenemanagement.h	/^    void set_view_to_screen_transform(const mat4& view_to_screen){$/;"	f	class:glh::Camera
set_world_to_camera_view_transform	glh_scenemanagement.h	/^    void set_world_to_camera_view_transform(const mat4& camera_to_view){$/;"	f	class:glh::Camera
set_zero	math_tools.h	/^    void set_zero(){memset(data_, sizeof(data_), 0);}$/;"	f	struct:glh::ArrayN
settings_	glh_scenemanagement.h	/^    std::list<RenderPassSettings> settings_;$/;"	m	class:glh::RenderPass
setup_context	glh_scenemanagement.h	/^    std::tuple<Box<int,2>, bool> setup_context(int pointer_x, int pointer_y){$/;"	f	class:glh::RenderPicker
sh_fragment_fix_color	glh_default_assets.cpp	/^    const char* sh_fragment_fix_color =$/;"	m	namespace:glh::__anon3	file:
sh_fragment_selection_color	glh_default_assets.cpp	/^    const char* sh_fragment_selection_color =$/;"	m	namespace:glh::__anon3	file:
sh_geometry	glh_default_assets.cpp	/^    const char* sh_geometry = "";$/;"	m	namespace:glh::__anon3	file:
sh_geometry	glh_uicontext.cpp	/^const char* sh_geometry = "";$/;"	m	namespace:glh	file:
sh_vertex_obj	glh_default_assets.cpp	/^    const char* sh_vertex_obj =$/;"	m	namespace:glh::__anon3	file:
shader_mapping_tokens	glprogramvars.cpp	/^ShaderMappingTokens shader_mapping_tokens()$/;"	f	namespace:glh
shader_program	glhack.cpp	/^ShaderProgram* shader_program(ProgramHandle* handle){return static_cast<ShaderProgram*>(handle);}$/;"	f	namespace:glh
shader_program	glhack.cpp	/^const ShaderProgram* shader_program(const ProgramHandle* handle){return static_cast<const ShaderProgram*>(handle);}$/;"	f	namespace:glh
shader_type_tokens	glprogramvars.cpp	/^ShaderTypeTokens shader_type_tokens()$/;"	f	namespace:glh
shift_	glh_scene_extensions.h	/^    bool shift_;$/;"	m	struct:glh::Modifiers
shiftsigned	stb_image.c	/^static int shiftsigned(int v, int shift, int bits)$/;"	f	file:
sig_	glbuffers.h	/^    BufferSignature      sig_;$/;"	m	class:glh::VertexChunk
signature	glbuffers.h	/^    BufferSignature signature() const {return sig_;}$/;"	f	class:glh::VertexChunk
simplex_noise	glh_generators.cpp	/^double simplex_noise(double x, double y)$/;"	f	namespace:glh
simplex_noise	glh_generators.cpp	/^double simplex_noise(double x, double y, double z)$/;"	f	namespace:glh
simplex_noise	glh_generators.cpp	/^double simplex_noise(double x, double y, double z, double w)$/;"	f	namespace:glh
sinks_	glh_dynamic_graph.h	/^        std::map<std::string, Value> sinks_;   \/\/> Available sinks - "prototypes". TODO: use only Value::Type!$/;"	m	struct:glh::DynamicGraph::DynamicNode
size	glbuffers.h	/^    size_t size(){return sig_.size_bytes_;}$/;"	f	class:glh::VertexChunk
size	glh_font.h	/^    size_t size(){ return coords_.size(); }$/;"	f	struct:glh::GlyphCoords
size	glh_image.h	/^    int size() const {return width_ * height_ * channels_;}$/;"	f	class:glh::Image32
size	glh_image.h	/^    int size() const {return width_ * height_ * channels_;}$/;"	f	class:glh::Image8
size	glh_scene_extensions.h	/^    size_t size(){return text_fields_.size();}$/;"	f	class:glh::TextField
size	glh_typedefs.h	/^    static size_t size(const t type){$/;"	f	class:glh::TypeId
size	masp.cpp	/^        size_t size = 0;$/;"	m	namespace:masp	file:
size	masp_classwrap.h	/^    size_t size() const{$/;"	f	class:masp::ArgWrap
size	math_tools.h	/^    vec_t size() const {return max_ - min_;}$/;"	f	struct:glh::Box
size	persistent_containers.h	/^        const size_t size() const$/;"	f	class:glh::PListPool::List
size	persistent_containers.h	/^        const size_t size() const$/;"	f	class:glh::PMapPool::Map
size	persistent_containers.h	/^        size_t size(){ return count_bits(used);}$/;"	f	struct:glh::PMapPool::Node
size	shims_and_types.h	/^    size_t size() const {return size_;}$/;"	f	class:glh::AlignedArray
size	shims_and_types.h	/^    size_t size(){ return string.size(); }$/;"	f	struct:glh::TextLine
size	shims_and_types.h	/^    size_t size(){return data_.size();}$/;"	f	struct:glh::SortedArray
size	stb_image.c	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon34	file:
size	stb_image.c	/^   uint8  size[257];$/;"	m	struct:__anon25	file:
size	stb_image.c	/^   uint8  size[288];$/;"	m	struct:__anon29	file:
size_	shims_and_types.h	/^    size_t                  size_;$/;"	m	class:glh::ArenaQueue
size_	shims_and_types.h	/^    size_t size_;$/;"	m	class:glh::AlignedArray
size_bytes_	glbuffers.h	/^    ptrdiff_t size_bytes_; \/\/> Size of data in bytes.$/;"	m	struct:glh::BufferSignature
skip	stb_image.c	/^   void     (*skip)  (void *user,unsigned n);            \/\/ skip the next 'n' bytes$/;"	m	struct:__anon22	file:
skip	stb_image.c	/^static void skip(stbi *s, int n)$/;"	f	file:
sleep_for	tinythread.h	/^  template <class _Rep, class _Period> void sleep_for(const chrono::duration<_Rep, _Period>& aTime)$/;"	f	namespace:tthread::this_thread
smoothstep	math_tools.h	/^inline double smoothstep(const double x){return (1.0 - 2.0*(-1.0 + x))* x * x;}$/;"	f	namespace:glh
smoothstep	math_tools.h	/^inline float smoothstep(const float x){return (1.0f - 2.0f*(-1.0f + x))* x * x;}$/;"	f	namespace:glh
solve_dependencies	glh_dynamic_graph.h	/^    void solve_dependencies(){$/;"	f	class:glh::DynamicGraph
sorted_nodes_	glh_dynamic_graph.h	/^    std::vector<id_t>    sorted_nodes_;$/;"	m	class:glh::DfsForestSort
source_factor_	glhack.h	/^        GLenum  source_factor_;$/;"	m	struct:glh::RenderPassSettings::BlendSettings
sources_	glh_dynamic_graph.h	/^        std::map<std::string, Value> sources_; \/\/> Available sources.                    or not. This way we can have a default value inplace.$/;"	m	struct:glh::DynamicGraph::DynamicNode
sp_select_program_	glh_uicontext.h	/^    glh::ProgramHandle* sp_select_program_;$/;"	m	class:glh::UiContext
span_is_empty	math_tools.h	/^bool span_is_empty(const typename Math<T>::span_t& span){return span[0] >= span[1];}$/;"	f	namespace:glh
span_t	math_tools.h	/^        span_t(const T& first, const T& second){data[0] = first; data[1] = second;}$/;"	f	class:glh::Math::span_t
span_t	math_tools.h	/^    class span_t {$/;"	c	class:glh::Math
split_container	shims_and_types.h	/^std::vector<C> split_container(const C& container, size_t n)$/;"	f	namespace:glh
stack_	glh_scenemanagement.h	/^        std::stack<Iterator> stack_;$/;"	m	class:glh::SceneTree::tree_iterator
stack_	shims_and_types.h	/^    typename std::aligned_storage <sizeof(T), std::alignment_of<T>::value>::type stack_[MaxDepth];$/;"	m	class:glh::FixedStack
start	glbase.cpp	/^bool App::start()$/;"	f	class:glh::App
start	math_tools.h	/^    float start; \/\/> Inclusive range start.$/;"	m	struct:glh::RandomRange
start	math_tools.h	/^    int32_t start; \/\/> Inclusive range start.$/;"	m	struct:glh::RandomRange
start_callbacks	stb_image.c	/^static void start_callbacks(stbi *s, stbi_io_callbacks *c, void *user)$/;"	f	file:
start_event_handling	glh_scenemanagement.h	/^    Focus start_event_handling(){$/;"	f	class:glh::FocusContext
start_file	stb_image.c	/^static void start_file(stbi *s, FILE *f)$/;"	f	file:
start_mem	stb_image.c	/^static void start_mem(stbi *s, uint8 const *buffer, int len)$/;"	f	file:
start_x	stb_image.c	/^   int start_x, start_y;$/;"	m	struct:stbi_gif_struct	file:
start_y	stb_image.c	/^   int start_x, start_y;$/;"	m	struct:stbi_gif_struct	file:
state	glbase.h	/^    Input::ButtonState state;      \/\/> MouseButton, Key: ButtonState$/;"	m	class:glh::InputEvent
state	math_tools.h	/^    tinymt32_t state;$/;"	m	struct:glh::Random
static_array_size	shims_and_types.h	29;"	d
status	tinymt32.h	/^    uint32_t status[4];$/;"	m	struct:TINYMT32_T
status	tinymt64.h	/^    uint64_t status[2];$/;"	m	struct:TINYMT64_T
stb_free_data	glh_image.cpp	/^    void      stb_free_data(uint8_t* ptr){stbi_image_free(ptr);}$/;"	f	namespace:glh::__anon4
stb_image_write_test	stb_image_write.h	/^typedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];$/;"	t
stbi	stb_image.c	/^} stbi;$/;"	t	typeref:struct:__anon23	file:
stbi_YCbCr_installed	stb_image.c	/^static stbi_YCbCr_to_RGB_run stbi_YCbCr_installed = YCbCr_to_RGB_row;$/;"	v	file:
stbi_YCbCr_to_RGB_run	stb_image.c	/^typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);$/;"	t	file:
stbi__ZHASH	stb_image_write.h	262;"	d
stbi__crc32	stb_image_write.h	/^unsigned int stbi__crc32(unsigned char *buffer, int len)$/;"	f
stbi__paeth	stb_image_write.h	/^static unsigned char stbi__paeth(int a, int b, int c)$/;"	f
stbi__sbcount	stb_image_write.h	194;"	d
stbi__sbfree	stb_image_write.h	195;"	d
stbi__sbgrow	stb_image_write.h	191;"	d
stbi__sbgrowf	stb_image_write.h	/^static void *stbi__sbgrowf(void **arr, int increment, int itemsize)$/;"	f
stbi__sbm	stb_image_write.h	186;"	d
stbi__sbmaybegrow	stb_image_write.h	190;"	d
stbi__sbn	stb_image_write.h	187;"	d
stbi__sbneedgrow	stb_image_write.h	189;"	d
stbi__sbpush	stb_image_write.h	193;"	d
stbi__sbraw	stb_image_write.h	185;"	d
stbi__wp32	stb_image_write.h	382;"	d
stbi__wpcrc	stb_image_write.h	/^static void stbi__wpcrc(unsigned char **data, int len)$/;"	f
stbi__wpng4	stb_image_write.h	381;"	d
stbi__wptag	stb_image_write.h	383;"	d
stbi__zhash	stb_image_write.h	/^static unsigned int stbi__zhash(unsigned char *data)$/;"	f
stbi__zlib_add	stb_image_write.h	251;"	d
stbi__zlib_bitrev	stb_image_write.h	/^static int stbi__zlib_bitrev(int code, int codebits)$/;"	f
stbi__zlib_countm	stb_image_write.h	/^static unsigned int stbi__zlib_countm(unsigned char *a, unsigned char *b, int limit)$/;"	f
stbi__zlib_flush	stb_image_write.h	250;"	d
stbi__zlib_flushf	stb_image_write.h	/^static unsigned char *stbi__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)$/;"	f
stbi__zlib_huff	stb_image_write.h	259;"	d
stbi__zlib_huff1	stb_image_write.h	255;"	d
stbi__zlib_huff2	stb_image_write.h	256;"	d
stbi__zlib_huff3	stb_image_write.h	257;"	d
stbi__zlib_huff4	stb_image_write.h	258;"	d
stbi__zlib_huffa	stb_image_write.h	253;"	d
stbi__zlib_huffb	stb_image_write.h	260;"	d
stbi_bmp_info	stb_image.c	/^static int stbi_bmp_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_bmp_load	stb_image.c	/^static stbi_uc *stbi_bmp_load(stbi *s,int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_bmp_test	stb_image.c	/^static int stbi_bmp_test(stbi *s)$/;"	f	file:
stbi_convert_iphone_png_to_rgb	stb_image.c	/^void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)$/;"	f
stbi_de_iphone	stb_image.c	/^static void stbi_de_iphone(png *z)$/;"	f	file:
stbi_de_iphone_flag	stb_image.c	/^static int stbi_de_iphone_flag = 0;$/;"	v	file:
stbi_dequantize_t	stb_image.c	/^typedef uint8 stbi_dequantize_t;$/;"	t	file:
stbi_dequantize_t	stb_image.c	/^typedef unsigned short stbi_dequantize_t;$/;"	t	file:
stbi_failure_reason	stb_image.c	/^const char *stbi_failure_reason(void)$/;"	f
stbi_fill_gif_background	stb_image.c	/^static void stbi_fill_gif_background(stbi_gif *g)$/;"	f	file:
stbi_gif	stb_image.c	/^} stbi_gif;$/;"	t	typeref:struct:stbi_gif_struct	file:
stbi_gif_header	stb_image.c	/^static int stbi_gif_header(stbi *s, stbi_gif *g, int *comp, int is_info)$/;"	f	file:
stbi_gif_info	stb_image.c	/^static int stbi_gif_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_gif_info_raw	stb_image.c	/^static int stbi_gif_info_raw(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_gif_load	stb_image.c	/^static stbi_uc *stbi_gif_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_gif_load_next	stb_image.c	/^static uint8 *stbi_gif_load_next(stbi *s, stbi_gif *g, int *comp, int req_comp)$/;"	f	file:
stbi_gif_lzw	stb_image.c	/^} stbi_gif_lzw;$/;"	t	typeref:struct:stbi_gif_lzw_struct	file:
stbi_gif_lzw_struct	stb_image.c	/^typedef struct stbi_gif_lzw_struct {$/;"	s	file:
stbi_gif_parse_colortable	stb_image.c	/^static void stbi_gif_parse_colortable(stbi *s, uint8 pal[256][4], int num_entries, int transp)$/;"	f	file:
stbi_gif_struct	stb_image.c	/^typedef struct stbi_gif_struct$/;"	s	file:
stbi_gif_test	stb_image.c	/^static int stbi_gif_test(stbi *s)$/;"	f	file:
stbi_hdr_info	stb_image.c	/^static int stbi_hdr_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_hdr_load	stb_image.c	/^static float *stbi_hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_hdr_test	stb_image.c	/^static int stbi_hdr_test(stbi* s)$/;"	f	file:
stbi_hdr_to_ldr_gamma	stb_image.c	/^void   stbi_hdr_to_ldr_gamma(float gamma) { h2l_gamma_i = 1\/gamma; }$/;"	f
stbi_hdr_to_ldr_scale	stb_image.c	/^void   stbi_hdr_to_ldr_scale(float scale) { h2l_scale_i = 1\/scale; }$/;"	f
stbi_idct_8x8	stb_image.c	/^typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);$/;"	t	file:
stbi_idct_installed	stb_image.c	/^static stbi_idct_8x8 stbi_idct_installed = idct_block;$/;"	v	file:
stbi_image_free	stb_image.c	/^void stbi_image_free(void *retval_from_stbi_load)$/;"	f
stbi_info	stb_image.c	/^int stbi_info(char const *filename, int *x, int *y, int *comp)$/;"	f
stbi_info_from_callbacks	stb_image.c	/^int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)$/;"	f
stbi_info_from_file	stb_image.c	/^int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)$/;"	f
stbi_info_from_memory	stb_image.c	/^int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)$/;"	f
stbi_info_main	stb_image.c	/^static int stbi_info_main(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_inline	stb_image.c	351;"	d	file:
stbi_inline	stb_image.c	353;"	d	file:
stbi_inline	stb_image.c	356;"	d	file:
stbi_install_YCbCr_to_RGB	stb_image.c	/^void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)$/;"	f
stbi_install_idct	stb_image.c	/^void stbi_install_idct(stbi_idct_8x8 func)$/;"	f
stbi_io_callbacks	stb_image.c	/^} stbi_io_callbacks;$/;"	t	typeref:struct:__anon22	file:
stbi_is_hdr	stb_image.c	/^extern int      stbi_is_hdr          (char const *filename)$/;"	f
stbi_is_hdr_from_callbacks	stb_image.c	/^extern int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)$/;"	f
stbi_is_hdr_from_file	stb_image.c	/^extern int      stbi_is_hdr_from_file(FILE *f)$/;"	f
stbi_is_hdr_from_memory	stb_image.c	/^int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)$/;"	f
stbi_jpeg_info	stb_image.c	/^static int stbi_jpeg_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_jpeg_info_raw	stb_image.c	/^static int stbi_jpeg_info_raw(jpeg *j, int *x, int *y, int *comp)$/;"	f	file:
stbi_jpeg_load	stb_image.c	/^static unsigned char *stbi_jpeg_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_jpeg_test	stb_image.c	/^static int stbi_jpeg_test(stbi *s)$/;"	f	file:
stbi_ldr_to_hdr_gamma	stb_image.c	/^void   stbi_ldr_to_hdr_gamma(float gamma) { l2h_gamma = gamma; }$/;"	f
stbi_ldr_to_hdr_scale	stb_image.c	/^void   stbi_ldr_to_hdr_scale(float scale) { l2h_scale = scale; }$/;"	f
stbi_load	stb_image.c	/^unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_callbacks	stb_image.c	/^unsigned char *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_file	stb_image.c	/^unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_memory	stb_image.c	/^unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_main	stb_image.c	/^static unsigned char *stbi_load_main(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_loadf	stb_image.c	/^float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_callbacks	stb_image.c	/^float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_file	stb_image.c	/^float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_memory	stb_image.c	/^float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_main	stb_image.c	/^float *stbi_loadf_main(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_lrot	stb_image.c	382;"	d	file:
stbi_lrot	stb_image.c	384;"	d	file:
stbi_out_gif_code	stb_image.c	/^static void stbi_out_gif_code(stbi_gif *g, uint16 code)$/;"	f	file:
stbi_pic_info	stb_image.c	/^static int stbi_pic_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_pic_load	stb_image.c	/^static stbi_uc *stbi_pic_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_pic_test	stb_image.c	/^static int stbi_pic_test(stbi *s)$/;"	f	file:
stbi_png_info	stb_image.c	/^static int      stbi_png_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_png_info_raw	stb_image.c	/^static int stbi_png_info_raw(png *p, int *x, int *y, int *comp)$/;"	f	file:
stbi_png_load	stb_image.c	/^static unsigned char *stbi_png_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_png_partial	stb_image.c	/^int stbi_png_partial; \/\/ a quick hack to only allow decoding some of a PNG... I should implement real streaming support instead$/;"	v
stbi_png_test	stb_image.c	/^static int stbi_png_test(stbi *s)$/;"	f	file:
stbi_process_gif_raster	stb_image.c	/^static uint8 *stbi_process_gif_raster(stbi *s, stbi_gif *g)$/;"	f	file:
stbi_psd_info	stb_image.c	/^static int stbi_psd_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_psd_load	stb_image.c	/^static stbi_uc *stbi_psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_psd_test	stb_image.c	/^static int stbi_psd_test(stbi *s)$/;"	f	file:
stbi_resample	stb_image.c	/^} stbi_resample;$/;"	t	typeref:struct:__anon28	file:
stbi_rewind	stb_image.c	/^static void stbi_rewind(stbi *s)$/;"	f	file:
stbi_set_unpremultiply_on_load	stb_image.c	/^void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)$/;"	f
stbi_stdio_callbacks	stb_image.c	/^static stbi_io_callbacks stbi_stdio_callbacks =$/;"	v	file:
stbi_tga_info	stb_image.c	/^int stbi_tga_info(stbi *s, int *x, int *y, int *comp)$/;"	f
stbi_tga_load	stb_image.c	/^static stbi_uc *stbi_tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_tga_test	stb_image.c	/^static int stbi_tga_test(stbi *s)$/;"	f	file:
stbi_uc	stb_image.c	/^typedef unsigned char stbi_uc;$/;"	t	file:
stbi_unpremultiply_on_load	stb_image.c	/^static int stbi_unpremultiply_on_load = 0;$/;"	v	file:
stbi_write_bmp	stb_image_write.h	/^int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)$/;"	f
stbi_write_png	stb_image_write.h	/^int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)$/;"	f
stbi_write_png_to_mem	stb_image_write.h	/^unsigned char *stbi_write_png_to_mem(unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)$/;"	f
stbi_write_tga	stb_image_write.h	/^int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)$/;"	f
stbi_zlib_compress	stb_image_write.h	/^unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)$/;"	f
stbi_zlib_decode_buffer	stb_image.c	/^int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)$/;"	f
stbi_zlib_decode_malloc	stb_image.c	/^char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)$/;"	f
stbi_zlib_decode_malloc_guesssize	stb_image.c	/^char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)$/;"	f
stbi_zlib_decode_malloc_guesssize_headerflag	stb_image.c	/^char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)$/;"	f
stbi_zlib_decode_noheader_buffer	stb_image.c	/^int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)$/;"	f
stbi_zlib_decode_noheader_malloc	stb_image.c	/^char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)$/;"	f
stbiw_uint32	stb_image_write.h	/^typedef unsigned int stbiw_uint32;$/;"	t
stbtt_BakeFontBitmap	stb_truetype.h	/^extern int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	f
stbtt_CompareUTF8toUTF16_bigendian	stb_truetype.h	/^int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2) $/;"	f
stbtt_FindGlyphIndex	stb_truetype.h	/^int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)$/;"	f
stbtt_FindMatchingFont	stb_truetype.h	/^int stbtt_FindMatchingFont(const unsigned char *font_collection, const char *name_utf8, stbtt_int32 flags)$/;"	f
stbtt_FlattenCurves	stb_truetype.h	/^stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)$/;"	f
stbtt_FreeBitmap	stb_truetype.h	/^void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)$/;"	f
stbtt_FreeShape	stb_truetype.h	/^void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)$/;"	f
stbtt_GetBakedQuad	stb_truetype.h	/^void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)$/;"	f
stbtt_GetCodepointBitmap	stb_truetype.h	/^unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBitmapBox	stb_truetype.h	/^void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapBoxSubpixel	stb_truetype.h	/^void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapSubpixel	stb_truetype.h	/^unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBox	stb_truetype.h	/^int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetCodepointHMetrics	stb_truetype.h	/^void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetCodepointKernAdvance	stb_truetype.h	/^int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)$/;"	f
stbtt_GetCodepointShape	stb_truetype.h	/^int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)$/;"	f
stbtt_GetFontBoundingBox	stb_truetype.h	/^void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetFontNameString	stb_truetype.h	/^const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)$/;"	f
stbtt_GetFontOffsetForIndex	stb_truetype.h	/^int stbtt_GetFontOffsetForIndex(const unsigned char *font_collection, int index)$/;"	f
stbtt_GetFontVMetrics	stb_truetype.h	/^void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)$/;"	f
stbtt_GetGlyphBitmap	stb_truetype.h	/^unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBitmapBox	stb_truetype.h	/^void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapBoxSubpixel	stb_truetype.h	/^void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapSubpixel	stb_truetype.h	/^unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBox	stb_truetype.h	/^int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetGlyphHMetrics	stb_truetype.h	/^void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetGlyphKernAdvance	stb_truetype.h	/^int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f
stbtt_GetGlyphShape	stb_truetype.h	/^int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt_InitFont	stb_truetype.h	/^int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data2, int fontstart)$/;"	f
stbtt_IsGlyphEmpty	stb_truetype.h	/^int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt_MakeCodepointBitmap	stb_truetype.h	/^void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)$/;"	f
stbtt_MakeCodepointBitmapSubpixel	stb_truetype.h	/^void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)$/;"	f
stbtt_MakeGlyphBitmap	stb_truetype.h	/^void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)$/;"	f
stbtt_MakeGlyphBitmapSubpixel	stb_truetype.h	/^void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)$/;"	f
stbtt_Rasterize	stb_truetype.h	/^void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)$/;"	f
stbtt_ScaleForMappingEmToPixels	stb_truetype.h	/^float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)$/;"	f
stbtt_ScaleForPixelHeight	stb_truetype.h	/^float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)$/;"	f
stbtt__CompareUTF8toUTF16_bigendian_prefix	stb_truetype.h	/^static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(const stbtt_uint8 *s1, stbtt_int32 len1, const stbtt_uint8 *s2, stbtt_int32 len2) $/;"	f
stbtt__GetGlyfOffset	stb_truetype.h	/^static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt__active_edge	stb_truetype.h	/^typedef struct stbtt__active_edge$/;"	s
stbtt__active_edge	stb_truetype.h	/^} stbtt__active_edge;$/;"	t	typeref:struct:stbtt__active_edge
stbtt__add_point	stb_truetype.h	/^static void stbtt__add_point(stbtt__point *points, int n, float x, float y)$/;"	f
stbtt__bitmap	stb_truetype.h	/^} stbtt__bitmap;$/;"	t	typeref:struct:__anon39
stbtt__check_size16	stb_truetype.h	/^   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];$/;"	t
stbtt__check_size32	stb_truetype.h	/^   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];$/;"	t
stbtt__close_shape	stb_truetype.h	/^static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,$/;"	f
stbtt__edge	stb_truetype.h	/^typedef struct stbtt__edge {$/;"	s
stbtt__edge	stb_truetype.h	/^} stbtt__edge;$/;"	t	typeref:struct:stbtt__edge
stbtt__edge_compare	stb_truetype.h	/^static int stbtt__edge_compare(const void *p, const void *q)$/;"	f
stbtt__fill_active_edges	stb_truetype.h	/^static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)$/;"	f
stbtt__find_table	stb_truetype.h	/^static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)$/;"	f
stbtt__isfont	stb_truetype.h	/^static int stbtt__isfont(const stbtt_uint8 *font)$/;"	f
stbtt__matches	stb_truetype.h	/^static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)$/;"	f
stbtt__matchpair	stb_truetype.h	/^static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)$/;"	f
stbtt__point	stb_truetype.h	/^} stbtt__point;$/;"	t	typeref:struct:__anon46
stbtt__rasterize	stb_truetype.h	/^static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)$/;"	f
stbtt__rasterize_sorted_edges	stb_truetype.h	/^static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)$/;"	f
stbtt__tesselate_curve	stb_truetype.h	/^static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)$/;"	f
stbtt_aligned_quad	stb_truetype.h	/^} stbtt_aligned_quad;$/;"	t	typeref:struct:__anon36
stbtt_bakedchar	stb_truetype.h	/^} stbtt_bakedchar;$/;"	t	typeref:struct:__anon35
stbtt_fontinfo	stb_truetype.h	/^typedef struct stbtt_fontinfo$/;"	s
stbtt_fontinfo	stb_truetype.h	/^} stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_int16	stb_truetype.h	/^   typedef signed   short  stbtt_int16;$/;"	t
stbtt_int32	stb_truetype.h	/^   typedef signed   int    stbtt_int32;$/;"	t
stbtt_int8	stb_truetype.h	/^   typedef signed   char   stbtt_int8;$/;"	t
stbtt_setvertex	stb_truetype.h	/^static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)$/;"	f
stbtt_tag	stb_truetype.h	779;"	d
stbtt_tag4	stb_truetype.h	778;"	d
stbtt_uint16	stb_truetype.h	/^   typedef unsigned short  stbtt_uint16;$/;"	t
stbtt_uint32	stb_truetype.h	/^   typedef unsigned int    stbtt_uint32;$/;"	t
stbtt_uint8	stb_truetype.h	/^   typedef unsigned char   stbtt_uint8;$/;"	t
stbtt_vertex	stb_truetype.h	/^   } stbtt_vertex;$/;"	t	typeref:struct:__anon38
stbtt_vertex_type	stb_truetype.h	561;"	d
stdio_eof	stb_image.c	/^static int stdio_eof(void *user)$/;"	f	file:
stdio_read	stb_image.c	/^static int stdio_read(void *user, char *data, int size)$/;"	f	file:
stdio_skip	stb_image.c	/^static void stdio_skip(void *user, unsigned n)$/;"	f	file:
step	stb_image.c	/^   int parse, step;$/;"	m	struct:stbi_gif_struct	file:
stop	glbase.h	/^    void stop(const char* msg)$/;"	f	class:glh::Autotimer
stored_size	gltexture.h	/^struct TextureUnitData{const uint8_t* bound_image; Texture* bound_texture; size_t stored_size;};$/;"	m	struct:glh::TextureUnitData
stride	glh_image.h	/^    int stride() const {return width_ * channels_;}$/;"	f	class:glh::Image32
stride	glh_image.h	/^    int stride() const {return width_ * channels_;}$/;"	f	class:glh::Image8
stride	stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon39
stride_	glh_image.h	/^    int      stride_;$/;"	m	class:glh::Image32
stride_	glh_image.h	/^    int      stride_;$/;"	m	class:glh::Image8
string	masp.h	/^        std::string* string; \/\/> Data for string | symbol$/;"	m	union:masp::Value::__anon18
string	shims_and_types.h	/^    std::string string;$/;"	m	struct:glh::TextLine
string_numerator	glbase.cpp	/^StringNumerator& App::string_numerator(){return string_numerator_;}$/;"	f	class:glh::App
string_numerator_	glbase.h	/^    StringNumerator                  string_numerator_;$/;"	m	class:glh::App
string_split	shims_and_types.cpp	/^std::list<TextLine> string_split(const char* str, const char* delim)$/;"	f	namespace:glh
string_to_file	iotools.cpp	/^bool string_to_file(const char* path, const char* string)$/;"	f
string_to_patharray	glh_scenemanagement.cpp	/^PathArray string_to_patharray(const std::string& str)$/;"	f	namespace:glh
string_to_value	masp.cpp	/^masp_result string_to_value(Masp& m, const char* str)$/;"	f	namespace:masp
string_value_is	masp.cpp	/^static bool string_value_is(const Value& v, const char* str)$/;"	f	namespace:masp
sub	geometry.h	/^Eigen::Matrix<T,3,1,0,3,1> sub(const Point<T>& b, const Point<T>& a)$/;"	f	namespace:glh
success	masp.cpp	/^    bool success(){return result == OK;}$/;"	f	struct:masp::ScopeError
suffix	stb_image.c	/^   uint8 suffix;$/;"	m	struct:stbi_gif_lzw_struct	file:
symbol_value_is	masp.cpp	/^static bool symbol_value_is(const Value& v, const char* str)$/;"	f	namespace:masp
t	glbase.h	/^    double t;$/;"	m	class:glh::Autotimer
t	glh_dynamic_graph.h	/^        enum t{Empty, Scalar, Vector2, Vector3, Vector4};$/;"	g	struct:glh::DynamicGraph::Value
t	glh_timebased_signals.h	/^        enum t{Arbitrary};};$/;"	g	struct:glh::Animation::ChannelName
t	glh_timebased_signals.h	/^        enum t{Linear, Smoothstep};$/;"	g	struct:glh::Animation::Easing
t	glh_timebased_signals.h	/^        enum t{Scalar, Verson};}; \/\/ Either regular scalar or rotation encoded in verson (unit quaternion).$/;"	g	struct:glh::Animation::VarType
t	glh_typedefs.h	/^    enum t$/;"	g	class:glh::EntityType
t	glh_typedefs.h	/^    enum t{Float32};$/;"	g	class:glh::TypeId
t	glh_typedefs.h	/^    enum t{Value,Index, T_LAST};$/;"	g	class:glh::ChannelType
t	glh_uicontext.h	/^        enum t{ ColorInterpolation };$/;"	g	struct:glh::UiContext::Technique
t	glh_uicontext.h	/^        enum t{$/;"	g	struct:glh::UiContext::Event
t	iotools.h	/^    enum t{File, Directory, Unsupported};$/;"	g	struct:FilesystemReference
t	math_tools.h	/^    enum t{Nearest, Linear};$/;"	g	class:glh::InterpolationType
t0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon36
t1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon36
t_	masp_classwrap.h	/^    std::shared_ptr<T> t_;$/;"	m	class:masp::WrappedObject
tail_	shims_and_types.h	/^    Node* tail_;$/;"	m	class:glh::PooledList
tail_from	shims_and_types.h	/^T tail_from(const T& container, size_t index){$/;"	f	namespace:glh
target	gltexture.h	/^    Target         target;$/;"	m	class:glh::TextureType
technique	math_tools.h	/^    void technique(InterpolationType::t t) {interpolation_technique_ = t;}$/;"	f	class:glh::Sampler1D
temp_bitmap	stb_truetype.h	/^unsigned char temp_bitmap[512*512];$/;"	v
tex	glh_font.h	/^        struct pos_ref_t{ vec2& pos; vec2& tex; };$/;"	m	struct:glh::textured_quad2d_t::iterator::pos_ref_t
tex_	glh_font.h	/^    quad2d_coord_t tex_;$/;"	m	struct:glh::textured_quad2d_t
text_field_	glh_scene_extensions.h	/^    TextField        text_field_;$/;"	m	class:glh::GlyphPane
text_field_bounds_	glh_scene_extensions.h	/^    Box2f            text_field_bounds_;$/;"	m	class:glh::GlyphPane
text_fields_	glh_scene_extensions.h	/^    std::vector<TextLinePtr> text_fields_;$/;"	m	class:glh::TextField
texture2d_	glhack.h	/^    std::map<std::string, Texture*> texture2d_;$/;"	m	class:glh::RenderEnvironment
texture_height_	glh_font.h	/^    int         texture_height_;$/;"	m	struct:glh::FontConfig
texture_unit_	glprogramvars.h	/^    int texture_unit_; \/\/> Texture unit to use, specific for a program.$/;"	m	class:glh::ShaderVar
texture_width_	glh_font.h	/^    int         texture_width_;$/;"	m	struct:glh::FontConfig
textured_quad2d_t	glh_font.h	/^struct textured_quad2d_t{$/;"	s	namespace:glh
textures_	glhack.cpp	/^    std::list<TexturePtr>                   textures_;$/;"	m	class:glh::GraphicsManagerInt	file:
tga_info	stb_image.c	/^static int tga_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
tga_load	stb_image.c	/^static stbi_uc *tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
tga_test	stb_image.c	/^static int tga_test(stbi *s)$/;"	f	file:
this_thread	tinythread.h	/^namespace this_thread {$/;"	n	namespace:tthread
thread	tinythread.cpp	/^thread::thread(void (*aFunction)(void *), void * aArg)$/;"	f	class:tthread::thread
thread	tinythread.h	/^    thread() : mHandle(0), mNotAThread(true)$/;"	f	class:tthread::thread
thread	tinythread.h	/^class thread {$/;"	c	namespace:tthread
thread_local	tinythread.h	140;"	d
thread_local	tinythread.h	142;"	d
time	glbase.cpp	/^double App::time()$/;"	f	class:glh::App
tinymt32_generate_32double	tinymt32.h	/^inline static double tinymt32_generate_32double(tinymt32_t * random) {$/;"	f
tinymt32_generate_float	tinymt32.h	/^inline static float tinymt32_generate_float(tinymt32_t * random) {$/;"	f
tinymt32_generate_float01	tinymt32.h	/^inline static float tinymt32_generate_float01(tinymt32_t * random) {$/;"	f
tinymt32_generate_float12	tinymt32.h	/^inline static float tinymt32_generate_float12(tinymt32_t * random) {$/;"	f
tinymt32_generate_floatOC	tinymt32.h	/^inline static float tinymt32_generate_floatOC(tinymt32_t * random) {$/;"	f
tinymt32_generate_floatOO	tinymt32.h	/^inline static float tinymt32_generate_floatOO(tinymt32_t * random) {$/;"	f
tinymt32_generate_uint32	tinymt32.h	/^inline static uint32_t tinymt32_generate_uint32(tinymt32_t * random) {$/;"	f
tinymt32_get_mexp	tinymt32.h	/^inline static int tinymt32_get_mexp($/;"	f
tinymt32_get_mexp	tinymt32.h	/^inline static int tinymt32_get_mexp(tinymt32_t * random) {$/;"	f
tinymt32_init	tinymt32.c	/^void tinymt32_init(tinymt32_t * random, uint32_t seed) {$/;"	f
tinymt32_init_by_array	tinymt32.c	/^void tinymt32_init_by_array(tinymt32_t * random, uint32_t init_key[],$/;"	f
tinymt32_next_state	tinymt32.h	/^inline static void tinymt32_next_state(tinymt32_t * random) {$/;"	f
tinymt32_t	tinymt32.h	/^typedef struct TINYMT32_T tinymt32_t;$/;"	t	typeref:struct:TINYMT32_T
tinymt32_temper	tinymt32.h	/^inline static uint32_t tinymt32_temper(tinymt32_t * random) {$/;"	f
tinymt32_temper_conv	tinymt32.h	/^inline static float tinymt32_temper_conv(tinymt32_t * random) {$/;"	f
tinymt32_temper_conv_open	tinymt32.h	/^inline static float tinymt32_temper_conv_open(tinymt32_t * random) {$/;"	f
tinymt64_generate_double	tinymt64.h	/^inline static double tinymt64_generate_double(tinymt64_t * random) {$/;"	f
tinymt64_generate_double01	tinymt64.h	/^inline static double tinymt64_generate_double01(tinymt64_t * random) {$/;"	f
tinymt64_generate_double12	tinymt64.h	/^inline static double tinymt64_generate_double12(tinymt64_t * random) {$/;"	f
tinymt64_generate_doubleOC	tinymt64.h	/^inline static double tinymt64_generate_doubleOC(tinymt64_t * random) {$/;"	f
tinymt64_generate_doubleOO	tinymt64.h	/^inline static double tinymt64_generate_doubleOO(tinymt64_t * random) {$/;"	f
tinymt64_generate_uint64	tinymt64.h	/^inline static uint64_t tinymt64_generate_uint64(tinymt64_t * random) {$/;"	f
tinymt64_get_mexp	tinymt64.h	/^inline static int tinymt64_get_mexp($/;"	f
tinymt64_get_mexp	tinymt64.h	/^inline static int tinymt64_get_mexp(tinymt64_t * random) {$/;"	f
tinymt64_init	tinymt64.c	/^void tinymt64_init(tinymt64_t * random, uint64_t seed) {$/;"	f
tinymt64_init_by_array	tinymt64.c	/^void tinymt64_init_by_array(tinymt64_t * random, const uint64_t init_key[],$/;"	f
tinymt64_next_state	tinymt64.h	/^inline static void tinymt64_next_state(tinymt64_t * random) {$/;"	f
tinymt64_t	tinymt64.h	/^typedef struct TINYMT64_T tinymt64_t;$/;"	t	typeref:struct:TINYMT64_T
tinymt64_temper	tinymt64.h	/^inline static uint64_t tinymt64_temper(tinymt64_t * random) {$/;"	f
tinymt64_temper_conv	tinymt64.h	/^inline static double tinymt64_temper_conv(tinymt64_t * random) {$/;"	f
tinymt64_temper_conv_open	tinymt64.h	/^inline static double tinymt64_temper_conv_open(tinymt64_t * random) {$/;"	f
tmat	tinymt32.h	/^    uint32_t tmat;$/;"	m	struct:TINYMT32_T
tmat	tinymt64.h	/^    uint64_t tmat;$/;"	m	struct:TINYMT64_T
to_byte	conversion.c	/^static inline float to_byte(float v) {$/;"	f	file:
to_byte_table	conversion.c	/^static unsigned short to_byte_table[0x10000];$/;"	v	file:
to_float	masp.h	/^    double to_float() const$/;"	f	struct:masp::Number
to_float	math_tools.h	/^inline float   to_float(const double d){return static_cast<float>(d);}$/;"	f	namespace:glh
to_float	math_tools.h	/^inline float   to_float(const uint8_t u){return static_cast<float>(u);}$/;"	f	namespace:glh
to_int	masp.h	/^    int to_int() const$/;"	f	struct:masp::Number
to_int	math_tools.h	/^inline int     to_int(const double d){return static_cast<int>(d);}$/;"	f	namespace:glh
to_newline	masp.cpp	/^    void to_newline()$/;"	f	class:masp::ValueParser
to_newline	masp.cpp	/^const char* to_newline(const char* begin, const char* end)$/;"	f	namespace:masp
to_number	masp.h	/^ template<> inline masp::Number to_number<masp::Number,double>(double d){return masp::Number::make(d);}$/;"	f
to_number	masp.h	/^ template<> inline masp::Number to_number<masp::Number,int>(int i){return masp::Number::make(i);}$/;"	f
to_number	math_tools.h	/^R to_number(P in){return (R) in;}$/;"	f
to_pair	shims_and_types.h	/^std::pair<T, V> to_pair(const T& t, const V& v){return std::pair<T, V>(t,v);}$/;"	f	namespace:glh
to_string	shims_and_types.h	/^cstring to_string(const T& value)$/;"	f	namespace:glh
to_t	glh_typedefs.h	/^    static t to_t(uint32_t num){return num < LAST_TYPE ? t(num) : Unknown;}$/;"	f	class:glh::EntityType
to_type	math_tools.h	/^    static T to_type(const NUM& n){return static_cast<T>(n);}$/;"	f	class:glh::Math
to_ubyte	math_tools.h	/^inline uint8_t to_ubyte(const float f){return static_cast<uint8_t>(f);}$/;"	f	namespace:glh
to_value	masp_classwrap.h	/^inline masp::Value to_value<bool>(masp::Masp& m, const bool& val){return masp::make_value_boolean(val);}$/;"	f	namespace:masp
to_value	masp_classwrap.h	/^inline masp::Value to_value<std::string>(masp::Masp& m, const std::string& str){return masp::make_value_string(str);}$/;"	f	namespace:masp
to_value	masp_classwrap.h	/^masp::Value to_value(masp::Masp& m, const std::tuple<P0, P1>& input)$/;"	f	namespace:masp
to_vec	math_tools.h	/^    complement_t to_vec() const{$/;"	f	struct:glh::ArrayN
todo	stb_image.c	/^   int restart_interval, todo;$/;"	m	struct:__anon26	file:
token_strings_to_regex	glhack.cpp	/^void token_strings_to_regex(std::ostream& os, const T& tokens)$/;"	f	namespace:glh
top	glh_scenemanagement.h	/^        Iterator& top(){return stack_.top();}$/;"	f	class:glh::SceneTree::tree_iterator
top	shims_and_types.h	/^    T* top()$/;"	f	class:glh::FixedStack
tq	stb_image.c	/^      int tq;$/;"	m	struct:__anon26::__anon27	file:
transfer_position_data_to_mesh	glh_scene_extensions.cpp	/^void transfer_position_data_to_mesh(GlyphCoords& coords,$/;"	f	namespace:glh
transfer_vertexdata_to_gpu	glhack.h	/^    void transfer_vertexdata_to_gpu(){$/;"	f	class:glh::FullRenderable
transform3	math_tools.h	/^typedef Eigen::Transform<float, 3, Eigen::Affine> transform3;$/;"	t	namespace:glh
transform_	glh_scenemanagement.h	/^        Transform transform_; \/\/ local to parent transform$/;"	m	class:glh::SceneTree::Node
transform_box	math_tools.h	/^Box<T,N> transform_box(M& tr, const Box<T,N>& box){$/;"	f	namespace:glh
transparent	stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
tree_	glh_scene_extensions.h	/^    SceneTree tree_; \/\/ TODO: Split SceneTree from SceneAssets?$/;"	m	class:glh::SceneAssets
tree_iterator	glh_scenemanagement.h	/^        tree_iterator(Node* root):current_(root){}$/;"	f	class:glh::SceneTree::tree_iterator
tree_iterator	glh_scenemanagement.h	/^    class tree_iterator{$/;"	c	class:glh::SceneTree
tree_world_bounds_AAB_	glh_scenemanagement.h	/^        Box3f tree_world_bounds_AAB_; \/\/ Bounds of object and children in world coordinates$/;"	m	class:glh::SceneTree::Node
triangles_	geometry.cpp	/^    std::vector<Triangle> triangles_;$/;"	m	class:glh::UnstructuredMeshImp	file:
try_find_referenced	glhack.cpp	/^    typename Collection::const_iterator try_find_referenced(const Collection& c, const Elem& e){$/;"	f	class:glh::GraphicsManagerInt
try_get_node	glh_dynamic_graph.h	/^    DynamicNode* try_get_node(const node_id_t& node){$/;"	f	class:glh::DynamicGraph
try_get_sourcevar	glh_dynamic_graph.h	/^        constvalue_t_ptr try_get_sourcevar(const std::string& varname){$/;"	f	struct:glh::DynamicGraph::DynamicNode
try_get_value	persistent_containers.h	/^        ConstOption<V> try_get_value(const K& key) const$/;"	f	class:glh::PMapPool::Map
try_get_value	shims_and_types.h	/^typename M::mapped_type* try_get_value(M& map, typename const M::key_type& key)$/;"	f	namespace:glh
try_lock	fast_mutex.h	/^    inline bool try_lock()$/;"	f	class:tthread::fast_mutex
try_lock	tinythread.h	/^    inline bool try_lock()$/;"	f	class:tthread::mutex
try_lock	tinythread.h	/^    inline bool try_lock()$/;"	f	class:tthread::recursive_mutex
try_read	glh_dynamic_graph.h	/^    static bool try_read(const Value& val, V& res){$/;"	f	class:glh::DynamicGraph
try_replace_value	persistent_containers.h	/^        bool try_replace_value(const K& key, const V& value)$/;"	f	class:glh::PMapPool::Map
try_set_var	glh_dynamic_graph.h	/^    void try_set_var(RenderEnvironment& env, const std::string& name){$/;"	f	class:glh::NodeSource
ttBYTE	stb_truetype.h	758;"	d
ttCHAR	stb_truetype.h	759;"	d
ttFixed	stb_truetype.h	760;"	d
ttLONG	stb_truetype.h	/^   stbtt_int32 ttLONG(const stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttLONG	stb_truetype.h	767;"	d
ttSHORT	stb_truetype.h	/^   stbtt_int16 ttSHORT(const stbtt_uint8 *p)   { return p[0]*256 + p[1]; }$/;"	f
ttSHORT	stb_truetype.h	765;"	d
ttULONG	stb_truetype.h	/^   stbtt_uint32 ttULONG(const stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttULONG	stb_truetype.h	766;"	d
ttUSHORT	stb_truetype.h	/^   stbtt_uint16 ttUSHORT(const stbtt_uint8 *p) { return p[0]*256 + p[1]; }$/;"	f
ttUSHORT	stb_truetype.h	764;"	d
ttf_buffer	stb_truetype.h	/^char ttf_buffer[1<<20];$/;"	v
ttf_buffer	stb_truetype.h	/^char ttf_buffer[1<<25];$/;"	v
tthread	fast_mutex.h	/^namespace tthread {$/;"	n
tthread	tinythread.cpp	/^namespace tthread {$/;"	n	file:
tthread	tinythread.h	/^namespace tthread {$/;"	n
type	glbase.h	/^    EventType type;$/;"	m	class:glh::InputEvent
type	glh_timebased_signals.h	/^    struct Signature{VarType type; ChannelName name;};$/;"	m	struct:glh::Animation::Signature
type	glprogramvars.h	/^    Type        type;$/;"	m	class:glh::ShaderVar
type	gltexture.h	/^    TextureType type;$/;"	m	class:glh::Texture
type	masp.h	/^    Type type;$/;"	m	class:masp::Value
type	masp.h	/^    Type type;$/;"	m	struct:masp::Number
type	persistent_containers.h	/^        NodeType type; $/;"	m	struct:glh::PMapPool::Node
type	stb_image.c	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon34	file:
type	stb_image.c	/^   uint32 type;$/;"	m	struct:__anon31	file:
type	stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon38
type_	glbuffers.h	/^    TypeId::t type_;       \/\/> Type of data held.$/;"	m	struct:glh::BufferSignature
type_	glh_dynamic_graph.h	/^        t type_;$/;"	m	struct:glh::DynamicGraph::Value
type_	iotools.h	/^    t type_;$/;"	m	struct:FilesystemReference
type_count	glprogramvars.cpp	/^size_t ShaderVar::type_count(Type t){$/;"	f	class:glh::ShaderVar
type_dim	glprogramvars.h	/^    typedef std::tuple<TypeId::t, int32_t> type_dim;$/;"	t	class:glh::ShaderVar
type_is	masp.cpp	/^bool type_is(Value& v, Type t){return v.type == t;}$/;"	f	namespace:masp
typeid_and_dim	glprogramvars.h	/^    static type_dim typeid_and_dim(Type t)$/;"	f	class:glh::ShaderVar
typename_	glh_dynamic_graph.h	/^        std::string                  typename_;$/;"	m	struct:glh::DynamicGraph::DynamicNode
typeof_entry	iotools.cpp	/^static FilesystemReference::t typeof_entry(dirent *entry){$/;"	f	file:
ui_context	glh_app_services.h	/^    UiContext&    ui_context(){ return *ui_context_; }$/;"	f	class:glh::AppServices
ui_context_	glh_app_services.h	/^    std::shared_ptr<UiContext> ui_context_;$/;"	m	class:glh::AppServices
uictx_sh_fragment_selection_color	glh_uicontext.cpp	/^const char* uictx_sh_fragment_selection_color = $/;"	m	namespace:glh	file:
uictx_sh_vertex_obj	glh_uicontext.cpp	/^const char* uictx_sh_vertex_obj   = $/;"	m	namespace:glh	file:
uictx_sp_select	glh_uicontext.cpp	/^const char* uictx_sp_select  = "sp_selecting";$/;"	m	namespace:glh	file:
uint	stb_image.c	/^typedef unsigned int   uint;$/;"	t	file:
uint16	stb_image.c	/^typedef unsigned short uint16;$/;"	t	file:
uint32	stb_image.c	/^typedef unsigned int   uint32;$/;"	t	file:
uint8	stb_image.c	/^typedef unsigned char  uint8;$/;"	t	file:
uniform_vars	glhack.cpp	/^    ShaderVarList uniform_vars;$/;"	m	class:glh::ShaderProgram	file:
unlock	fast_mutex.h	/^    inline void unlock()$/;"	f	class:tthread::fast_mutex
unlock	tinythread.h	/^    inline void unlock()$/;"	f	class:tthread::mutex
unlock	tinythread.h	/^    inline void unlock()$/;"	f	class:tthread::recursive_mutex
unsafe_copy	shims_and_types.h	/^void unsafe_copy(II begin, II end, OI out)$/;"	f	namespace:glh
update	glbase.cpp	/^bool App::update()$/;"	f	class:glh::App
update	glbase.h	/^    AppUpdate update;$/;"	m	struct:glh::AppConfig
update	glh_app_services.h	/^    void update(){$/;"	f	class:glh::AppServices
update	glh_scene_extensions.h	/^    void update(){$/;"	f	class:glh::SceneAssets
update	glh_scenemanagement.h	/^    void update(){$/;"	f	class:glh::SceneTree
update	glh_scenemanagement.h	/^    void update(App* app){$/;"	f	class:glh::Camera
update	glh_timebased_signals.h	/^        void update(float t){if(!is_done_) is_done_ = event_(t);}$/;"	f	class:glh::DynamicSystem::Event
update	glh_timebased_signals.h	/^    void update(float t){$/;"	f	class:glh::DynamicSystem
update	glh_uicontext.h	/^    void update(){$/;"	f	class:glh::UiContext
update	glh_uicontext.h	/^    void update(SceneTree& scene){$/;"	f	struct:glh::SelectionWorld
update_bounds	glh_scenemanagement.h	/^        Box3f& update_bounds(){$/;"	f	class:glh::SceneTree::Node
update_cursor_pos	glh_scene_extensions.h	/^    void update_cursor_pos(){$/;"	f	class:glh::GlyphPane
update_cursor_pos_to_end_of_line	glh_scene_extensions.h	/^    void update_cursor_pos_to_end_of_line()$/;"	f	class:glh::GlyphPane
update_event_state	glh_scenemanagement.h	/^        void update_event_state(){$/;"	f	struct:glh::FocusContext::Focus
update_ids	glh_scenemanagement.h	/^     void update_ids(){$/;"	f	class:glh::RenderPicker
update_line_numbers	glh_scene_extensions.h	/^    void update_line_numbers(){$/;"	f	class:glh::TextField
update_queue	glh_scenemanagement.h	/^    void update_queue(SceneTree& scene){$/;"	f	class:glh::RenderPass
update_queue_filtered	glh_scenemanagement.h	/^    void update_queue_filtered(SceneTree& scene){$/;"	f	class:glh::RenderPass
update_representation	glh_scene_extensions.h	/^    void update_representation()$/;"	f	class:glh::GlyphPane
update_transforms	glh_scenemanagement.h	/^        void update_transforms(){$/;"	f	class:glh::SceneTree::Node
update_transforms	glh_scenemanagement.h	/^        void update_transforms(const mat4& parent_local_to_world){$/;"	f	class:glh::SceneTree::Node
upload_image_data	gltexture.cpp	/^void Texture::upload_image_data(GLuint texture_object){$/;"	f	class:glh::Texture
upload_sampler_parameters	gltexture.cpp	/^void Texture::upload_sampler_parameters(){$/;"	f	class:glh::Texture
upload_texture_image	glhack.cpp	/^static void upload_texture_image(GraphicsManagerInt& manager, Texture& t){$/;"	f	namespace:glh
us_ascii_tolower	glh_scene_extensions.cpp	/^char us_ascii_tolower(char c){$/;"	f	namespace:glh
us_ascii_toupper	glh_scene_extensions.cpp	/^char us_ascii_toupper(char c){$/;"	f	namespace:glh
use	glhack.cpp	/^    void use() {glUseProgram(program_handle);}$/;"	f	class:glh::ShaderProgram
used	persistent_containers.h	/^        uint32_t used;$/;"	m	struct:glh::PMapPool::Node
used_elements	persistent_containers.h	/^    uint32_t used_elements;$/;"	m	struct:glh::Chunk
user_input	glbase.cpp	/^UserInput& App::user_input()$/;"	f	class:glh::App
user_input_	glbase.h	/^    UserInput                        user_input_;$/;"	m	class:glh::App
userdata	stb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo
v	stb_image.c	/^      int h,v;$/;"	m	struct:__anon26::__anon27	file:
v_	shims_and_types.h	/^        const Value& v_;$/;"	m	struct:glh::BiMap::KeyInserter
valid	annotated_result.h	/^    bool valid(){return valid_;}$/;"	f	class:glh::AnnotatedResult
valid	glh_scenemanagement.h	/^            bool valid(){return i_ != end_;}$/;"	f	struct:glh::SceneTree::tree_iterator::Iterator
valid	stb_truetype.h	/^   int valid;$/;"	m	struct:stbtt__active_edge
valid_	annotated_result.h	/^    bool valid_;$/;"	m	class:glh::AnnotatedResult
validate_uint32	stb_image.c	/^typedef unsigned char validate_uint32[sizeof(uint32)==4 ? 1 : -1];$/;"	t	file:
value	glh_scenemanagement.h	/^            Node* value(){return *i_;}$/;"	f	struct:glh::SceneTree::tree_iterator::Iterator
value	masp.h	/^    } value;$/;"	m	class:masp::Value	typeref:union:masp::Value::__anon18
value	masp.h	/^    }value;$/;"	m	struct:masp::Number	typeref:union:masp::Number::__anon17
value	persistent_containers.h	/^        }value;$/;"	m	struct:glh::PMapPool::Node	typeref:union:glh::PMapPool::Node::__anon20
value	stb_image.c	/^   uint16 value[288]; $/;"	m	struct:__anon29	file:
value_	annotated_result.h	/^    typename std::aligned_storage <sizeof(T), std::alignment_of<T>::value>::type value_[1];$/;"	m	class:glh::AnnotatedResult
value_	glh_dynamic_graph.h	/^        array4 value_;$/;"	m	struct:glh::DynamicGraph::Value
value_	glh_dynamic_graph.h	/^    double value_;$/;"	m	class:glh::LimitedIncrementalValue
value_boolean	masp.cpp	/^bool value_boolean(const Value& v){$/;"	f	namespace:masp
value_function	masp.cpp	/^PrimitiveFunction value_function(const Value& v)$/;"	f	namespace:masp::__anon15
value_increment_references	masp.cpp	/^void value_increment_references(const Value& v)$/;"	f	namespace:masp::__anon14
value_iter	persistent_containers.h	/^        NodeValueIterator value_iter;$/;"	m	class:glh::PMapPool::node_iterator
value_list	masp.cpp	/^inline List* value_list(const Value& v){return v.type == LIST ? v.value.list : 0;}$/;"	f	namespace:masp
value_list_first	masp.cpp	/^inline const Value* value_list_first(const Value& v)$/;"	f	namespace:masp
value_list_fourth	masp.cpp	/^inline const Value* value_list_fourth(const Value& v)$/;"	f	namespace:masp
value_list_nth	masp.cpp	/^inline const Value* value_list_nth(const Value& v, size_t n)$/;"	f	namespace:masp
value_list_second	masp.cpp	/^inline const Value* value_list_second(const Value& v)$/;"	f	namespace:masp
value_list_third	masp.cpp	/^inline const Value* value_list_third(const Value& v)$/;"	f	namespace:masp
value_map	masp.cpp	/^Map* value_map(const Value& v){return v.type == MAP ? v.value.map : 0;}$/;"	f	namespace:masp
value_number	masp.cpp	/^inline Number value_number(const Value& v){return v.type == NUMBER ? v.value.number : Number::make(0);}$/;"	f	namespace:masp
value_number_array	masp.cpp	/^NumberArray* value_number_array(Value& v){return v.type == NUMBER_ARRAY ? v.value.number_array : 0;}$/;"	f	namespace:masp
value_object	masp.cpp	/^IObject* value_object(const Value& v){return v.type == OBJECT ? v.value.object : 0;}$/;"	f	namespace:masp
value_size	shims_and_types.h	/^    size_t value_size() const { return sizeof(T);}$/;"	f	class:glh::AlignedArray
value_string	masp.cpp	/^const char* value_string(const Value& v){$/;"	f	namespace:masp
value_t	math_tools.h	/^    typedef Value               value_t;$/;"	t	class:glh::InterpolatingMap
value_to_string	masp.cpp	/^std::string value_to_string(const Value& v)$/;"	f	namespace:masp
value_to_string_helper	masp.cpp	/^static void value_to_string_helper(std::ostream& os, const Value& v, PrefixHelper prfx)$/;"	f	namespace:masp
value_to_typed_string	masp.cpp	/^std::string value_to_typed_string(const Value* v)$/;"	f	namespace:masp
value_type	masp.cpp	/^Type value_type(const Value* v)$/;"	f	namespace:masp
value_type	persistent_containers.h	/^        typedef KeyValue value_type;$/;"	t	class:glh::PMapPool::Map
value_type	persistent_containers.h	/^        typedef T value_type;$/;"	t	class:glh::PListPool::List
value_type	shims_and_types.h	/^    typedef T  value_type;$/;"	t	class:glh::AlignedArray
value_type	shims_and_types.h	/^    typedef T value_type;$/;"	t	class:glh::Pool
value_type	shims_and_types.h	/^    typedef T value_type;$/;"	t	class:glh::PooledList
value_type	shims_and_types.h	/^    typedef T value_type;$/;"	t	struct:glh::SortedArray
value_type	shims_and_types.h	/^    typedef std::pair<Key,Value> value_type;$/;"	t	class:glh::BiMap
value_type_to_string	masp.cpp	/^std::string value_type_to_string(const Value& v)$/;"	f	namespace:masp
value_vector	masp.cpp	/^Vector* value_vector(Value& v){return v.type == VECTOR ? v.value.vector : 0;}$/;"	f	namespace:masp
value_vector	masp.cpp	/^inline Vector* value_vector(const Value& v){return v.type == VECTOR ? v.value.vector : 0;}$/;"	f	namespace:masp
values	stb_image.c	/^   uint8  values[256];$/;"	m	struct:__anon25	file:
values_to_keys_	shims_and_types.h	/^    InverseMap values_to_keys_;$/;"	m	class:glh::BiMap
var_id_t	glh_dynamic_graph.h	/^    typedef std::string   var_id_t;$/;"	t	class:glh::DynamicGraph
vars_	glh_dynamic_graph.h	/^    std::list<std::string> vars_;$/;"	m	class:glh::NodeSource
vec2	math_tools.h	/^typedef Eigen::Vector2f vec2;$/;"	t	namespace:glh
vec2i	math_tools.h	/^typedef Eigen::Vector2i vec2i;$/;"	t	namespace:glh
vec3	math_tools.h	/^typedef Eigen::Vector3f vec3;$/;"	t	namespace:glh
vec3_t	math_tools.h	/^    typedef Eigen::Matrix<T, 3, 1> vec3_t;$/;"	t	class:glh::Math
vec4	math_tools.h	/^typedef Eigen::Vector4f vec4;$/;"	t	namespace:glh
vec4_	glhack.h	/^    std::map<std::string, vec4,  std::less<std::string>, Eigen::aligned_allocator<std::pair<std::string, vec4> >> vec4_;$/;"	m	class:glh::RenderEnvironment
vec4i	math_tools.h	/^typedef Eigen::Vector4i vec4i;$/;"	t	namespace:glh
vec_of_point	geometry.h	/^Eigen::Matrix<T,4,1,0,4,1> vec_of_point(const Point<T>& b)$/;"	f	namespace:glh
vec_p	math_tools.h	/^    typedef Eigen::Matrix<T, N+1, 1> vec_p;$/;"	t	struct:glh::Box
vec_t	math_tools.h	/^    typedef Eigen::Matrix<T, N, 1>   vec_t;$/;"	t	struct:glh::Box
vector	masp.h	/^        Vector*      vector;$/;"	m	union:masp::Value::__anon18
verify_matching_types	glhack.cpp	/^bool verify_matching_types(ShaderVar::Type stype, TypeId::t t, int32_t components){$/;"	f	namespace:glh
vertex_data_	glh_dynamic_graph.h	/^    std::vector<V>                      vertex_data_;$/;"	m	class:glh::AdjacencyListGraph
vertex_handle	glhack.cpp	/^    GLuint vertex_handle;$/;"	m	class:glh::ShaderProgram	file:
vertex_id	glh_dynamic_graph.h	/^    typedef int                                vertex_id;$/;"	t	class:glh::AdjacencyListGraph
vertex_input_vars	glhack.cpp	/^    ShaderVarList vertex_input_vars;$/;"	m	class:glh::ShaderProgram	file:
vertex_list_t	glh_dynamic_graph.h	/^    typedef List<vertex_id>                    vertex_list_t;$/;"	t	class:glh::AdjacencyListGraph
vertex_shader	glhack.cpp	/^    std::string vertex_shader;$/;"	m	class:glh::ShaderProgram	file:
view_to_screen_	glh_scenemanagement.h	/^    mat4 view_to_screen_;   \/\/ To NDC. $/;"	m	class:glh::Camera
visited_	glh_dynamic_graph.h	/^    std::map<id_t, bool> visited_;$/;"	m	class:glh::DfsForestSort
vs	stb_image.c	/^   int hs,vs;   \/\/ expansion factor in each axis$/;"	m	struct:__anon28	file:
w	stb_image.c	/^   int w,h;$/;"	m	struct:stbi_gif_struct	file:
w	stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon39
w2	stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon26::__anon27	file:
w_	glh_generators.cpp	/^        const double x_, y_, z_, w_;$/;"	m	struct:glh::SimplexNoise::Grad	file:
w_lores	stb_image.c	/^   int w_lores; \/\/ horizontal pixels pre-expansion $/;"	m	struct:__anon28	file:
wait	tinythread.h	/^    inline void wait(_mutexT &aMutex)$/;"	f	class:tthread::condition_variable
wclosedir	win32_dirent.h	251;"	d
wdirent	win32_dirent.h	247;"	d
wdirp	win32_dirent.h	/^    struct _WDIR *wdirp;$/;"	m	struct:DIR	typeref:struct:DIR::_WDIR
width	glbase.h	/^    int width;$/;"	m	struct:glh::AppConfig
width	gltexture.h	/^    GLsizei width;$/;"	m	class:glh::Texture
width_	glh_image.h	/^    int      width_;$/;"	m	class:glh::Image32
width_	glh_image.h	/^    int      width_;$/;"	m	class:glh::Image8
wopendir	win32_dirent.h	249;"	d
world_bounds_AAB_	glh_scenemanagement.h	/^        Box3f world_bounds_AAB_;$/;"	m	class:glh::SceneTree::Node
world_to_camera	glh_scenemanagement.h	/^    mat4 world_to_camera(){ return node_->local_to_world_.inverse(); }$/;"	f	class:glh::Camera
world_to_camera_view_	glh_scenemanagement.h	/^    mat4 world_to_camera_view_;   \/\/ Affine transform based on node$/;"	m	class:glh::Camera
world_to_screen_	glh_scenemanagement.h	/^    mat4 world_to_screen_; \/\/ compute per frame, view_to_screen_ * world_to_camera_view_$/;"	m	class:glh::Camera
wrap	masp_classwrap.h	/^    void wrap(T* t){$/;"	f	class:masp::ArgWrap
wrap	masp_classwrap.h	/^    void wrap(T* t, R... rest){$/;"	f	class:masp::ArgWrap
wrap_function	masp_classwrap.h	/^PrimitiveFunction wrap_function(R (*mmbr)(P0)){return FunWrap1_1<R, P0>(mmbr);}$/;"	f	namespace:masp
wrap_function	masp_classwrap.h	/^PrimitiveFunction wrap_function(R (*mmbr)(P0, P1)){return FunWrap1_2<R, P0, P1>(mmbr);}$/;"	f	namespace:masp
wrap_function	masp_classwrap.h	/^PrimitiveFunction wrap_function(R (*mmbr)(void)){return FunWrap1_0<R>(mmbr);}$/;"	f	namespace:masp
wrap_function	masp_classwrap.h	/^PrimitiveFunction wrap_function(void (*mmbr)(P0)){return FunWrap0_1<P0>(mmbr);}$/;"	f	namespace:masp
wrap_function	masp_classwrap.h	/^inline PrimitiveFunction wrap_function(void (*mmbr)(void)){return FunWrap0_0(mmbr);}$/;"	f	namespace:masp
wrap_member	masp_classwrap.h	/^PrimitiveFunction wrap_member(void (T::*mmbr)(P0)){$/;"	f	namespace:masp
wrap_member	masp_classwrap.h	/^PrimitiveFunction wrap_member(void (T::*mmbr)(void)){$/;"	f	namespace:masp
wrapper_function	tinythread.cpp	/^unsigned WINAPI thread::wrapper_function(void * aArg)$/;"	f	class:tthread::thread
wreaddir	win32_dirent.h	250;"	d
wrewinddir	win32_dirent.h	252;"	d
write	iotools.cpp	/^bool OutputFile::write(const char* str)$/;"	f	class:OutputFile
write3	stb_image_write.h	/^static void write3(FILE *f, unsigned char a, unsigned char b, unsigned char c)$/;"	f
write_image_png	glh_image.cpp	/^bool write_image_png(const Image8& image, const char* path)$/;"	f	namespace:glh
write_pixel_coords_for_string	glh_font.cpp	/^std::tuple<float, float> FontContext::write_pixel_coords_for_string(const std::string& string,$/;"	f	class:glh::FontContext
write_pixels	stb_image_write.h	/^static void write_pixels(FILE *f, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad)$/;"	f
write_str	iotools.cpp	/^bool OutputFile::write_str(std::string& str)$/;"	f	class:OutputFile
writefv	stb_image_write.h	/^static void writefv(FILE *f, const char *fmt, va_list v)$/;"	f
x	geometry.h	/^template<class T> struct Point{T x, y, z;};$/;"	m	struct:glh::Point
x	stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon26::__anon27	file:
x	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon38
x	stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon46
x	stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
x0	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon36
x0	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon35
x1	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon36
x1	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon35
x_	glh_generators.cpp	/^        const double x_, y_, z_, w_;$/;"	m	struct:glh::SimplexNoise::Grad	file:
xadvance	stb_truetype.h	/^   float xoff,yoff,xadvance;   $/;"	m	struct:__anon35
xcept	glh_scene_extensions.h	/^    void xcept(const std::string& msg){$/;"	f	class:glh::SceneAssets
xoff	stb_truetype.h	/^   float xoff,yoff,xadvance;   $/;"	m	struct:__anon35
y	geometry.h	/^template<class T> struct Point{T x, y, z;};$/;"	m	struct:glh::Point
y	stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon26::__anon27	file:
y	stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy;$/;"	m	struct:__anon38
y	stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon46
y0	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y0	stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon36
y0	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon35
y1	stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y1	stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon36
y1	stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon35
y_	glh_generators.cpp	/^        const double x_, y_, z_, w_;$/;"	m	struct:glh::SimplexNoise::Grad	file:
yield	tinythread.h	/^  inline void yield()$/;"	f	namespace:tthread::this_thread
yoff	stb_truetype.h	/^   float xoff,yoff,xadvance;   $/;"	m	struct:__anon35
ypos	stb_image.c	/^   int ypos;    \/\/ which pre-expansion row we're on$/;"	m	struct:__anon28	file:
ystep	stb_image.c	/^   int ystep;   \/\/ how far through vertical expansion we are$/;"	m	struct:__anon28	file:
z	geometry.h	/^template<class T> struct Point{T x, y, z;};$/;"	m	struct:glh::Point
z_	glh_generators.cpp	/^        const double x_, y_, z_, w_;$/;"	m	struct:glh::SimplexNoise::Grad	file:
z_distance	stb_image.c	/^   zhuffman z_length, z_distance;$/;"	m	struct:__anon30	file:
z_expandable	stb_image.c	/^   int   z_expandable;$/;"	m	struct:__anon30	file:
z_length	stb_image.c	/^   zhuffman z_length, z_distance;$/;"	m	struct:__anon30	file:
zbuf	stb_image.c	/^} zbuf;$/;"	t	typeref:struct:__anon30	file:
zbuffer	stb_image.c	/^   uint8 *zbuffer, *zbuffer_end;$/;"	m	struct:__anon30	file:
zbuffer_end	stb_image.c	/^   uint8 *zbuffer, *zbuffer_end;$/;"	m	struct:__anon30	file:
zbuild_huffman	stb_image.c	/^static int zbuild_huffman(zhuffman *z, uint8 *sizelist, int num)$/;"	f	file:
zget8	stb_image.c	/^stbi_inline static int zget8(zbuf *z)$/;"	f	file:
zhuffman	stb_image.c	/^} zhuffman;$/;"	t	typeref:struct:__anon29	file:
zhuffman_decode	stb_image.c	/^stbi_inline static int zhuffman_decode(zbuf *a, zhuffman *z)$/;"	f	file:
zout	stb_image.c	/^   char *zout;$/;"	m	struct:__anon30	file:
zout_end	stb_image.c	/^   char *zout_end;$/;"	m	struct:__anon30	file:
zout_start	stb_image.c	/^   char *zout_start;$/;"	m	struct:__anon30	file:
zreceive	stb_image.c	/^stbi_inline static unsigned int zreceive(zbuf *z, int n)$/;"	f	file:
~AlignedArray	shims_and_types.h	/^    ~AlignedArray()$/;"	f	class:glh::AlignedArray
~AnnotatedResult	annotated_result.h	/^    ~AnnotatedResult()$/;"	f	class:glh::AnnotatedResult
~BufferHandle	glbuffers.h	/^    ~BufferHandle(){if(handle_) glDeleteBuffers(1, &handle_);}$/;"	f	class:glh::BufferHandle
~Collectable	managed_structures.h	/^    virtual ~Collectable(){}$/;"	f	class:Collectable
~Env	masp.cpp	/^    ~Env()$/;"	f	class:masp::Masp::Env
~EvaluationException	masp.h	/^    ~EvaluationException(){}$/;"	f	class:masp::EvaluationException
~Focus	glh_scenemanagement.h	/^        ~Focus(){}$/;"	f	struct:glh::FocusContext::Focus
~FunBase	masp_classwrap.h	/^    virtual ~FunBase(){}$/;"	f	class:masp::FunBase
~GarbageCollecting	managed_structures.h	/^    virtual ~GarbageCollecting(){}$/;"	f	class:GarbageCollecting
~GlyphPane	glh_scene_extensions.h	/^    ~GlyphPane(){$/;"	f	class:glh::GlyphPane
~GraphicsException	glsystem.h	/^    ~GraphicsException(){}$/;"	f	class:glh::GraphicsException
~GraphicsManagerInt	glhack.cpp	/^    ~GraphicsManagerInt(){}$/;"	f	class:glh::GraphicsManagerInt
~IObject	masp.h	/^    virtual ~IObject(){}$/;"	f	class:masp::IObject
~Image32	glh_image.cpp	/^Image32::~Image32(){if(data_) dealloc_(data_);}$/;"	f	class:glh::Image32
~Image8	glh_image.cpp	/^Image8::~Image8(){if(data_) dealloc_(data_);}$/;"	f	class:glh::Image8
~InputFile	iotools.cpp	/^InputFile::~InputFile(){if(file_) file_.close();}$/;"	f	class:InputFile
~List	persistent_containers.h	/^        ~List(){if(head_) pool_.remove_ref(head_);}$/;"	f	class:glh::PListPool::List
~Map	persistent_containers.h	/^        ~Map()$/;"	f	class:glh::PMapPool::Map
~Masp	masp.cpp	/^Masp::~Masp()$/;"	f	class:masp::Masp
~Node	persistent_containers.h	/^        ~Node()$/;"	f	struct:glh::PMapPool::Node
~OutOfRangeException	shims_and_types.h	/^    ~OutOfRangeException(){}$/;"	f	class:glh::OutOfRangeException
~OutputFile	iotools.cpp	/^OutputFile::~OutputFile(){if(file_) file_.close();}$/;"	f	class:OutputFile
~PListPool	persistent_containers.h	/^    ~PListPool()$/;"	f	class:glh::PListPool
~PMapPool	persistent_containers.h	/^    ~PMapPool()$/;"	f	class:glh::PMapPool
~ShaderProgram	glhack.cpp	/^    ~ShaderProgram(){release_program(*this);}$/;"	f	class:glh::ShaderProgram
~UnstructuredMesh	geometry.h	/^    virtual ~UnstructuredMesh(){}$/;"	f	class:glh::UnstructuredMesh
~UnstructuredMeshImp	geometry.cpp	/^    virtual ~UnstructuredMeshImp(){}$/;"	f	class:glh::UnstructuredMeshImp
~Value	masp.cpp	/^Value::~Value()$/;"	f	class:masp::Value
~WrappedObject	masp_classwrap.h	/^    virtual ~WrappedObject(){}$/;"	f	class:masp::WrappedObject
~condition_variable	tinythread.cpp	/^condition_variable::~condition_variable()$/;"	f	class:tthread::condition_variable
~condition_variable	tinythread.h	/^    ~condition_variable()$/;"	f	class:tthread::condition_variable
~fast_mutex	fast_mutex.h	/^    ~fast_mutex()$/;"	f	class:tthread::fast_mutex
~lock_guard	tinythread.h	/^    ~lock_guard()$/;"	f	class:tthread::lock_guard
~mutex	tinythread.h	/^    ~mutex()$/;"	f	class:tthread::mutex
~recursive_mutex	tinythread.h	/^    ~recursive_mutex()$/;"	f	class:tthread::recursive_mutex
~thread	tinythread.cpp	/^thread::~thread()$/;"	f	class:tthread::thread
